"""
Exploit Manager
This module manages the exploit process by handling authentication,
configuration retrieval, and dispatching exploits to the target IP teams.

"""

import io
import re
import sys
import time
import asyncio
import requests

from typing import Any
from array import array
from pathlib import Path
from threading import local
from .logger import StatusCode, log_status
from concurrent.futures import ThreadPoolExecutor


thread_local = local()

# ty 0xMatte for the ThreadSafe <3
class ThreadSafeStdout:
    """
    A thread-safe wrapper for standard output to ensure that
    """
    def write(self, text):
        return self._get_buffer().write(text)

    def _get_buffer(self):
        return getattr(thread_local, "buf", sys.__stdout__)

    def __getattr__(self, attr):
        return getattr(self._get_buffer(), attr)


# Redirect standard output to the thread-local buffer
sys.stdout = ThreadSafeStdout()


def get_auth_token() -> str:
    """
    Get the authentication token from the session file.

    Returns:
        str: The authentication token.
    """

    session_path = Path.home().joinpath(".config", "cookiefarm", "session")

    with open(session_path) as session_file:
        token = session_file.read().strip()

    return token


def get_ip_teams(
    server_address: str, config_api_path: str = "/api/v1/config"
) -> tuple[array[int], str, str]:
    """
    Get the IP teams from the server.

    Args:
        server_address (str): The address of the server.
        config_api_path (str): The API path for configuration.
    Returns:
        tuple[array[int], str]: A tuple containing an array of IP teams and the format of IP teams.
    Raises:
        ValueError: If the response from the server is not ok.
    """

    response = requests.get(
        f"{server_address}{config_api_path}",
        headers={
            "Content-Type": "application/json",
            "Cookie": f"token={get_auth_token()}",
        },
    )
    if not response.ok:
        log_status(StatusCode.FATAL, "Failed to get config")
        exit(1)

    config_json = response.json()

    regex_flag = config_json["client"]["regex_flag"]
    my_ip_team = int(config_json["client"]["my_team_ip"].split(".")[2])
    ip_teams = array("H", range(my_ip_team))

    for i in range(my_ip_team + 1, int(config_json["client"]["range_ip_teams"]) + 1):
        ip_teams.append(i)

    return ip_teams, config_json["client"]["format_ip_teams"], regex_flag


def extract_flag(source: str | list[str], regex: re.Pattern) -> set[str | Any]:
    """
    Extract flags from the source using the provided regex.

    Args:
        source (str|list[str]): The source string or list of strings to extract flags from.
        regex (Pattern): The regex pattern to match the flags.
    Returns:
        list[str]: A list of extracted flags.
    Raises:
        ValueError: If the source is empty or if the regex does not match.
        TypeError: If the source is not a string or a list of strings.
    """
    if not source:
        log_status(StatusCode.ERROR, "Source cannot be empty")
        return set()

    if isinstance(source, list):
        if not all(isinstance(item, str) for item in source):
            log_status(StatusCode.ERROR, "All items in the list must be strings")
            return set()

        return set(match for item in source for match in regex.findall(item))

    if not isinstance(source, str):
        log_status(StatusCode.ERROR, "Source must be a string or a list of strings")
        return set()

    if not regex.search(source):
        return set()

    return set(regex.findall(source))


async def execute_exploit(
    exploit_function,
    ip_team: str,
    port_service: int,
    regex: re.Pattern,
    name_service: str,
) -> tuple[str, set[str]]:
    """
    Execute the exploit function asynchronously for the specified IP team and port service.

    This function runs the provided exploit function in a separate thread using asyncio's to_thread,
    allowing non-blocking execution. It then extracts any flags from the exploit's output
    using the provided regex pattern.

    Args:
        exploit_function (function): The exploit function to be dispatched.
        ip_team (str): The IP team to target.
        port_service (int): The port service to target.
        regex (Pattern): The regex pattern to match the flags.
        name_service (str): The name of the service.
    Returns:
        tuple[str, list[str]]: A tuple containing the IP team and a list of extracted flags.
    """
    try:
        result_exploit = await asyncio.to_thread(
            exploit_function, ip_team, port_service, name_service
        )
    except Exception as e:
        log_status(
            StatusCode.ERROR,
            str(e),
            team_id=int(ip_team.split(".")[2]),
            port_service=port_service,
            name_service=name_service,
        )
        return ip_team, set()
    return ip_team, extract_flag(result_exploit, regex)


async def dispatch_exploits(
    exploit_function,
    ip_teams: array[int],
    ip_format: str,
    port_service: int,
    regex: re.Pattern,
    thread_number: int,
    name_service: str,
):
    """
    Dispatch the exploits for the given IP teams and port service.
    Print the results in JSON format in standard output.

    Args:
        exploit_function (function): The exploit function to be executed.
        ip_teams (array[int]): The array of IP teams to target.
        ip_format (str): The format of the IP teams.
        port_service (int): The port service to target.
        regex (Pattern): The regex pattern to match the flags.
        thread_number (int): The number of threads to use for the attack.
        name_service (str): Name of service
    """
    executor = ThreadPoolExecutor(max_workers=thread_number)
    loop = asyncio.get_running_loop()
    loop.set_default_executor(executor)

    tasks = [
        execute_exploit(
            exploit_function=exploit_function,
            ip_team=ip_format.format(ip_team),
            port_service=port_service,
            regex=regex,
            name_service=name_service,
        )
        for ip_team in ip_teams
    ]

    for task in asyncio.as_completed(tasks):
        result = await task
        ip = result[0]
        flags = result[1]

        if not flags:
            log_status(
                StatusCode.FAILED,
                "No flags found",
                team_id=int(ip.split(".")[2]),
                port_service=port_service,
                name_service=name_service,
            )
        else:
            for flag in flags:
                log_status(
                    StatusCode.SUCCESS,
                    "Flag Found",
                    team_id=int(ip.split(".")[2]),
                    port_service=port_service,
                    flag_code=flag,
                    name_service=name_service,
                )


def attack_loop(
    exploit_function,
    ip_teams: array[int],
    ip_format: str,
    port_service: int,
    flag_regex: re.Pattern,
    tick_time: int,
    thread_number: int,
    name_service: str,
):
    """
    Run the exploit function in a loop with a specified tick time.

    Args:
        exploit_function (function): The exploit function to be executed.
        ip_teams (array[int]): The array of IP teams to target.
        ip_format (str): The format of the IP teams.
        port_service (int): The port service to target.
        flag_regex (Pattern): The regex pattern to match the flags.
        tick_time (int): The time interval between each execution of the exploit function.
        thread_number (int): The number of threads to use for the attack.
        name_service (str): Name of service
    """

    while True:
        start_time = time.time()

        asyncio.run(
            dispatch_exploits(
                exploit_function=exploit_function,
                ip_teams=ip_teams,
                ip_format=ip_format,
                port_service=port_service,
                regex=flag_regex,
                thread_number=thread_number,
                name_service=name_service,
            )
        )

        elapsed_time = time.time() - start_time
        sleep_time = max(0, tick_time - elapsed_time)
        time.sleep(sleep_time)


def exploit_manager(func):
    """
    Decorator to manage the exploit process.
    """

    def wrapper(*_args, **kwargs):

        def exploit_function_wrapper(*args, **kwargs):
            """
            Wrapper function to redirect standard output to a thread-local buffer.
            """
            buf = io.StringIO()
            thread_local.buf = buf

            try:
                func(*args, **kwargs)
            finally:
                del thread_local.buf
                out = buf.getvalue()
                buf.close()
                return out


        ip_teams, ip_format, regex_flag = get_ip_teams(
            server_address=f"http://{sys.argv[1]}"
        )

        attack_loop(
            exploit_function=exploit_function_wrapper,
            ip_teams=ip_teams,
            ip_format=ip_format,
            tick_time=int(sys.argv[2]),
            flag_regex=re.compile(regex_flag),
            thread_number=int(sys.argv[3]),
            port_service=int(sys.argv[4]),
            name_service=sys.argv[5],
        )

    return wrapper()
