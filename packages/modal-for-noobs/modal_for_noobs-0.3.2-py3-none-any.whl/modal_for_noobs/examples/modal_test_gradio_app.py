# üöÄ Modal Deployment Script (Async Generated)
# Generated by modal-for-noobs - https://github.com/arthrod/modal-for-noobs
# Deployment Mode: minimum
# Following Modal's technical design philosophy for high-performance cloud computing
# Timeout: 3600s | Scaledown: 1200s

import gradio as gr
import modal
from fastapi import FastAPI
from gradio.routes import mount_gradio_app

# üéØ Create Modal App with semantic naming
app = modal.App("modal-for-noobs-test_gradio_app")

# üê≥ Container Image Configuration
# Optimized for minimum workloads with performance-tuned dependencies
image = modal.Image.debian_slim(python_version="3.11").pip_install("gradio", "fastapi[standard]", "uvicorn", "httpx", "markdown2")

# üì¶ Original Gradio Application Code
# Embedded for seamless execution in Modal's cloud infrastructure
import gradio as gr


def greet(name, intensity):
    """Simple greeting function."""
    return "Hello, " + name + "!" * int(intensity)


# Create a Gradio interface
demo = gr.Interface(
    fn=greet,
    inputs=[gr.Textbox(label="Name", placeholder="Enter your name"), gr.Slider(minimum=1, maximum=10, step=1, label="Enthusiasm Level")],
    outputs=gr.Textbox(label="Greeting"),
    title="Easy Modal Test App",
    description="A simple greeting application for testing easy-modal CLI",
)

if __name__ == "__main__":
    demo.launch(strict_cors=False)  # Allow localhost, HuggingFace, and Modal cross-origin requests


# ‚ö° Modal Function Configuration
# Engineered for scalability, performance, and reliability
@app.function(
    image=image,
    min_containers=1,
    max_containers=1,  # Single container for session consistency and state management
    timeout=3600,  # Configurable timeout for workload requirements
    scaledown_window=1200,  # Optimized scale-down for cost efficiency
)
@modal.concurrent(max_inputs=100)  # High concurrency for production-grade performance
@modal.asgi_app()
def deploy_gradio():
    """Deploy Gradio app with Modal's high-performance infrastructure.

    This deployment function implements:
    - Smart Gradio interface detection using global scope analysis
    - FastAPI integration following Modal's ASGI architecture patterns
    - Performance optimization for concurrent request handling
    - Error handling and fallback mechanisms for production reliability
    """
    # üîç Smart Gradio Interface Detection
    # Using global scope analysis for maximum compatibility
    demo = None

    # Primary detection: Check common Gradio interface names
    if "demo" in globals():
        demo = globals()["demo"]
    elif "app" in globals() and hasattr(globals()["app"], "queue"):
        demo = globals()["app"]
    elif "interface" in globals():
        demo = globals()["interface"]
    elif "iface" in globals():
        demo = globals()["iface"]

    # Fallback detection: Comprehensive global scope scan
    if demo is None:
        for var_name, var_value in globals().items():
            if hasattr(var_value, "queue") and hasattr(var_value, "launch"):
                demo = var_value
                break

    # üö® Fail-safe error handling with descriptive messaging
    if demo is None:
        raise ValueError(
            "Could not find Gradio interface in the application. "
            "Ensure your app defines a Gradio interface as 'demo', 'app', 'interface', or 'iface'."
        )

    # üöÄ Performance Configuration
    # Optimized queue size for responsiveness and throughput
    demo.queue(max_size=10)

    # üîó FastAPI Integration
    # Following Modal's recommended ASGI architecture patterns
    fastapi_app = FastAPI(
        title="Modal-for-noobs Gradio App",
        description="High-performance Gradio deployment on Modal cloud infrastructure",
        version="1.0.0",
        docs_url="/docs",  # Enable API documentation
        redoc_url="/redoc",  # Enable alternative API documentation
    )

    return mount_gradio_app(fastapi_app, demo, path="/")


# üèÉ‚Äç‚ôÇÔ∏è Direct execution support for local testing
if __name__ == "__main__":
    app.run()
