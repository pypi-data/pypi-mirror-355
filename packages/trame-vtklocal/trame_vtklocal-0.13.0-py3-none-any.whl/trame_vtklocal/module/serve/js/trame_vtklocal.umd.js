(function(v,S){typeof exports=="object"&&typeof module<"u"?S(exports,require("vue")):typeof define=="function"&&define.amd?define(["exports","vue"],S):(v=typeof globalThis<"u"?globalThis:v||self,S(v.trame_vtklocal={},v.Vue))})(this,function(v,S){"use strict";const I=[],k={};function E(){let t,e;return{promise:new Promise((n,r)=>{t=n,e=r}),resolve:t,reject:e}}function $(t){return t!=null&&t.Id?t:JSON.parse(t)}function B(t){return t!=null&&t.Id?JSON.stringify(t):t}function J(t,e){return t.rendering===e.rendering&&t.exec===e.exec}function P(t){return(t==null?void 0:t.rendering)==="webgpu"?(console.log("WASM use WebGPU"),{preRun:[function(e){e.ENV.VTK_GRAPHICS_BACKEND="WEBGPU"}]}):(console.log("WASM use WebGL2"),{})}function q(t){return k[t]||(k[t]=new Promise(function(e,s){if(I.indexOf(t)===-1){I.push(t);var n=document.createElement("script");n.type="module",n.src=t,n.onload=e,n.onerror=s,document.body.appendChild(n)}else e(!1)})),k[t]}class H{constructor(){this.loaded=!1,this.loadingPending=null,this.wasm=null,this.config={},this.runtimes=[]}async load(e,s={rendering:"webgl",exec:"sync"}){var n,r;if(this.config=s,!this.loaded)if(this.loadingPending)await this.loadingPending;else{const{promise:a,resolve:h}=E();if(this.loadingPending=a,((n=this.config)==null?void 0:n.rendering)==="webgpu"&&(this.config.exec="async"),!window.createVTKWASM){let l=null;document.querySelectorAll("script").forEach(o=>{if(o.src.includes("vtkWebAssembly")){const{promise:i,resolve:d}=E();o.onload=d,l=i}}),l&&await l}if(!window.createVTKWASM){let l=null,o=null;if(l=`${e}/vtkWebAssembly${((r=this.config)==null?void 0:r.exec)==="async"?"Async":""}.mjs`,(await fetch(l)).ok&&(o=l),o||(l=`${e}/vtkWasmSceneManager.mjs`,(await fetch(l)).ok&&(o=l)),!o)throw new Error(`Could not fetch wasm bundle from ${e}`);console.log("WASM use",o),await q(o)}window.createVTKWASM&&(this.wasm=await window.createVTKWASM(P(this.config))),this.loaded=!0,h()}}async createRemoteSession(e){var n;if(this.wasm)if((n=this.wasm)!=null&&n.isAsync&&this.wasm.isAsync()){if(!e||J(this.config,e))return console.log("(Main runtime in async)"),new this.wasm.vtkRemoteSession;{console.log("(New in async)");const r=await window.createVTKWASM(P(e||this.config));return new r.vtkRemoteSession}}else{console.log("(New in sync)");const r=await window.createVTKWASM(P(e||this.config));return new r.vtkRemoteSession}const s=await window.createVTKWasmSceneManager();return s.initialize(),s}createStandaloneSession(){if(!this.wasm)throw new Error("Current WASM version does not support standalone mode");return new this.wasm.vtkStandaloneSession}createStateDecorator(){return this.wasm?$:B}}function R(t){return`${t.charAt(0).toLowerCase()}${t.slice(1)}`}function L(t){return`${t.charAt(0).toUpperCase()}${t.slice(1)}`}function D(t){const e={};return Object.entries(t).forEach(([s,n])=>{e[L(s)]=n}),e}function F(t){const e={};return Object.entries(t).forEach(([s,n])=>{e[R(s)]=n}),e}function U(t,e,s){if(!t.get)return{};const n=t.get(s),r={};return Object.keys(n).forEach(a=>{r[R(a)]=()=>e.decorateResult(t.get(s)[a])}),r}function X(t,e,s){if(!t.get)return{};const n=t.get(s),r={};return Object.keys(n).forEach(a=>{r[R(a)]=h=>t.set(s,e.decorateKwargs({[a]:h}))}),r}function C(t,e,s,n,r){if(s.has(r)&&s.get(r).deref())return s.get(r).deref();const a=[];function h(b){return t.set(r,n.decorateKwargs(D(b)))}function l(b,g){const p=t.observe(r,b,g);return a.push(p),p}function o(b){const g=a.indexOf(b);return g!==-1&&a.splice(g,1),t.unObserve(r,b)}function i(){for(;a.length;)o(a.pop())}const d=U(t,n,r),f=X(t,n,r),m={id:r,obj:{Id:r},set:h,observe:l,unObserve:o,unObserveAll:i},y=new Proxy(m,{get(b,g,p){if(g==="then")return p;if(g==="state")return t.get?F(t.get(r)):(t.updateStateFromObject(r),F(t.getState(r)));if(g==="delete"){const O=t.destroy(r);if(O){const W=s.delete(r);e.delete(W)}return O}return d[g]?d[g]():(b[g]||(b[g]=async(...O)=>n.decorateResult(await t.invoke(r,L(g),n.decorateArgs(O)))),b[g])},set(b,g,p){return f[g]&&f[g](p),p}});return s.set(r,new WeakRef(y)),e.set(y,!0),y}function Q(t,e,s){function n(d){return e.has(d)}function r(d){const f={};return Object.entries(d).forEach(([m,y])=>{e.has(y)?f[m]=y.obj:f[m]=y}),f}function a(d){return d.map(f=>e.has(f)?f.obj:f)}const h={isVtkObject:n,decorateKwargs:r,decorateArgs:a};function l(d){return d==null?d:d!=null&&d.Id?C(t,e,s,h,d.Id):d}h.decorateResult=l;function o(d){return C(t,e,s,h,d.Id||d)}function i(d,f){const m=t.create(d);return f&&t.set(m,r(D(f))),C(t,e,s,h,m)}return new Proxy({getVtkObject:o},{get(d,f,m){return f==="then"?m:(d[f]||(d[f]=y=>i(f,y)),d[f])}})}async function Y(t,e={}){const s=new WeakMap,n=new Map,r=new H;await r.load(t,e);const a=r.createStandaloneSession();return Q(a,s,n)}const{promise:Z,resolve:ee,reject:te}=E(),x=document.querySelector("#vtk-wasm");if(x){const t=x.dataset.url||".",e=JSON.parse(x.dataset.config||"{}");window.vtkReady=Z,Y(t,e).then(s=>{window.vtk=s,ee(s)})}else te('No script with id="vtk-wasm"');const A={};class K{constructor(){this.sceneManager=null,this.loaded=!1,this.updateInProgress=0,this.currentMTime=1,this.stateMTimes={},this.hashesMTime={},this.pendingArrays={},this.networkFetchState=null,this.networkFetchHash=null,this.networkFetchStatus=null,this.cameraIds=new Set,this.stateCache={},this.renderWindowIds=new Set,this.renderWindowIdToInteractorId=new Map,this.renderWindowSizes={},this.vtkProxyCache=new WeakMap,this.idToRef=new Map,this.internalWrapMethods={},this.internalWrapMethods.isVtkObject=e=>this.vtkProxyCache.has(e),this.internalWrapMethods.decorateKwargs=e=>{const s={};return Object.entries(e).forEach(([n,r])=>{this.vtkProxyCache.has(r)?s[n]=r.obj:s[n]=r}),s},this.internalWrapMethods.decorateArgs=e=>e.map(s=>this.vtkProxyCache.has(s)?s.obj:s),this.internalWrapMethods.decorateResult=e=>e==null?e:e!=null&&e.Id?C(this.sceneManager,this.vtkProxyCache,this.idToRef,this.internalWrapMethods,e.Id):e,this.offlineCanvasContainer=document.createElement("div"),this.offlineCanvasContainer.setAttribute("class","unused-canvas"),document.body.appendChild(this.offlineCanvasContainer)}async load(e,s){A[e]||(A[e]=new H),await A[e].load(e,s),this.sceneManager=await A[e].createRemoteSession(s),this.stateDecorator=A[e].createStateDecorator(),this.loaded=!0,this.sceneManager.skipProperty&&(this.sceneManager.skipProperty("vtkRenderWindow","Size"),["vtkWin32OpenGLRenderWindow","vtkXOpenGLRenderWindow","vtkCocoaRenderWindow","vtkWebAssemblyOpenGLRenderWindow"].forEach(n=>this.sceneManager.skipProperty(n,"Size")))}bindNetwork(e,s,n){this.networkFetchState=e,this.networkFetchHash=s,this.networkFetchStatus=n}freeMemory(e=0){const s=this.sceneManager.getTotalBlobMemoryUsage(),n=Number(e);if(s>n){const r={};let a=this.currentMTime;for(Object.entries(this.hashesMTime).forEach(([h,l])=>{l<a&&(a=l);const o=l.toString();r[o]?r[o].push(h):r[o]=[h]});this.sceneManager.getTotalBlobMemoryUsage()>n;){const h=r[a];if(h)for(let l=0;l<h.length;l++)this.sceneManager.unRegisterBlob(h[l]),delete this.hashesMTime[h[l]];a++}}}async fetchState(e){const s=await this.networkFetchState(e);return this.patchState(s)}patchState(e){var s;if(e.length>0){const n=JSON.parse(e),{Id:r,MTime:a}=n;if(this.stateMTimes[r]=a,!this.sceneManager.skipProperty||!this.sceneManager.bindRenderWindow){if(this.renderWindowIds.has(r)&&((s=n==null?void 0:n.Interactor)!=null&&s.Id))return this.renderWindowIdToInteractorId.set(n.Interactor.Id,r),n.CanvasSelector=this.getCanvasSelector(r),delete n.Size,this.renderWindowSizes[r]&&(n.Size=this.renderWindowSizes[r]),n.ClassName="vtkCocoaRenderWindow",JSON.stringify(n);if(this.renderWindowIdToInteractorId.has(r))return n.CanvasSelector=this.getCanvasSelector(this.renderWindowIdToInteractorId.get(r)),JSON.stringify(n)}return e}}async fetchHash(e){if(this.pendingArrays[e]){await this.pendingArrays[e],this.hashesMTime[e]=this.currentMTime,delete this.pendingArrays[e];return}const s=await this.networkFetchHash(e);return this.sceneManager.registerBlob(e,s),this.hashesMTime[e]=this.currentMTime,s}pushHash(e,s){return this.pendingArrays[e]=new Promise(n=>{s.arrayBuffer?s.arrayBuffer().then(r=>{this.sceneManager.registerBlob(e,new Uint8Array(r)),this.hashesMTime[e]=this.currentMTime,n()}):(this.sceneManager.registerBlob(e,s),this.hashesMTime[e]=this.currentMTime,n())}),this.pendingArrays[e]}async update(e,s=!1){if(this.renderWindowIds.add(e),this.updateInProgress++,this.updateInProgress===1)try{const n=await this.networkFetchStatus(e),r=[],a=[],h=n.force_push||[];for(let o=0;o<h.length;o++)delete this.stateMTimes[h[o]];n.ids.forEach(([o,i])=>{(!this.stateMTimes[o]||this.stateMTimes[o]<i)&&a.push(this.fetchState(o))}),n.hashes.forEach(o=>{this.hashesMTime[o]||r.push(this.fetchHash(o)),this.hashesMTime[o]=this.currentMTime}),n.cameras.forEach(o=>this.cameraIds.add(Number(o))),n.ignore_ids.forEach(o=>this.sceneManager.unRegisterState(o)),await Promise.all(r),await Promise.all(Object.values(this.pendingArrays));const l=await Promise.all(a);for(this.currentMTime++;l.length;){const o=l.pop();o&&this.sceneManager.registerState(this.stateDecorator(o))}try{this.sceneManager.updateObjectsFromStates();const[o,i]=this.renderWindowSizes[e]||[10,10];this.sceneManager.setSize(e,o,i),s&&this.sceneManager.bindRenderWindow&&this.sceneManager.bindRenderWindow(e,this.getCanvasSelector(e)),await this.sceneManager.render(e)}catch(o){console.error("WASM update failed"),console.log(o)}}catch(n){console.error("Error in update",n)}finally{this.updateInProgress--,this.updateInProgress&&(this.updateInProgress=0,await this.update(e))}}getState(e,s=!1){const n=Number(e);return s&&this.stateCache[n]?this.stateCache[n]:this.sceneManager.get?this.sceneManager.get(n):(this.sceneManager.updateStateFromObject(n),this.sceneManager.getState(n))}clearStateCache(){this.stateCache={}}getStateValue(e,s=!1){const n=Array.isArray(e)?e:[e];let r=null;for(let a=0;a<n.length;a++){const h=n[a];a===0?r=this.getState(h,s):(r=r[h],r.Id&&(r=this.getState(r.Id,s)))}return r}getCanvasSelector(e){return`.vtk-wasm-${e}`}bindCanvasToDOM(e,s){const n=this.getCanvasSelector(e);let r=this.offlineCanvasContainer.querySelector(n);return r||(r=document.createElement("canvas"),r.setAttribute("class",n.substring(1)),r.setAttribute("tabindex","0")),s.appendChild(r),n}unbindCanvasToDOM(e){const s=this.getCanvasSelector(e),n=document.querySelector(s);n&&this.offlineCanvasContainer.appendChild(n)}async setSize(e,s,n){this.renderWindowSizes[e]=[s,n];const r=this.getCanvasSelector(e),a=document.querySelector(r);a&&(a.width=s,a.height=n,this.sceneManager.setSize(e,s,n),await this.sceneManager.render(e))}getVtkObject(e){return C(this.sceneManager,this.vtkProxyCache,this.idToRef,this.internalWrapMethods,e)}}const T={};function V(t,e,s){return function(){e.clearStateCache();for(const[n,r]of Object.entries(s)){const a={};for(const[h,l]of Object.entries(r))a[h]=e.getStateValue(l,!0);t.state.set(n,a)}e.clearStateCache()}}const _={VtkLocal:{emits:["updated","memory-vtk","memory-arrays","camera","invoke-response"],props:{useHandler:{type:String},renderWindow:{type:Number},eagerSync:{type:Boolean,default:!1},cacheSize:{type:Number,default:1e8},wsClient:{type:Object},verbosity:{type:Object,default:()=>({objectManager:null,invoker:null,deserializer:null,serializer:null})},config:{type:Object,default:()=>({rendering:"webgl",exec:"sync"})},listeners:{type:Object}},setup(t,{emit:e}){t.useHandler&&!T[t.useHandler]&&(T[t.useHandler]=new K);const s=S.inject("trame"),n=s.state.get("__trame_vtklocal_wasm_url"),r=[],a=[],h=S.ref(null),l=t.wsClient||(s==null?void 0:s.client),o=S.toRef(t,"listeners"),i=t.useHandler?T[t.useHandler]:new K;let d=null;async function f(u){return await l.getConnection().getSession().call("vtklocal.get.state",[u])}async function m(u){const w=await l.getConnection().getSession().call("vtklocal.get.hash",[u]);return w.arrayBuffer?new Uint8Array(await w.arrayBuffer()):w}async function y(u){return await l.getConnection().getSession().call("vtklocal.get.status",[u])}function b([u]){u.type==="state"&&i.pushState(u.content),u.type==="blob"&&i.pushHash(u.hash,u.content)}async function g(){const u=l.getConnection().getSession();d=u.subscribe("vtklocal.subscriptions",b),await u.call("vtklocal.subscribe.update",[t.renderWindow,1])}async function p(){const u=l.getConnection().getSession();d&&(u.unsubscribe(d),d=null),await u.call("vtklocal.subscribe.update",[t.renderWindow,-1])}async function O(){const{width:u,height:c}=h.value.getBoundingClientRect(),w=Math.floor(u*window.devicePixelRatio+.5),M=Math.floor(c*window.devicePixelRatio+.5);await i.setSize(t.renderWindow,w,M)}let W=new ResizeObserver(O);function se(){i.freeMemory(t.cacheSize),e("memory-vtk",i.sceneManager.getTotalVTKDataObjectMemoryUsage()),e("memory-arrays",i.sceneManager.getTotalBlobMemoryUsage())}async function G(u=!1){i.loaded&&(await i.update(t.renderWindow,u),e("updated"),se())}function re(u){i.sceneManager.resetCamera(u),i.sceneManager.render(t.renderWindow)}async function ie(u,c,w){const M=await i.sceneManager.invoke(u,c,w);return M.Id&&M.Success&&(M.Value=i.getState(M.Id)),e("invoke-response",M),M}function ae(){i.sceneManager.printSceneManagerInformation()}S.onMounted(async()=>{i.bindNetwork(f,m,y),i.loaded||await i.load(n,t.config);const u=i.bindCanvasToDOM(t.renderWindow,S.unref(h));S.unref(h).querySelector(u).setAttribute("style","position: absolute; left: 0; top: 0; width: 100%; height: 100%;"),t.eagerSync&&g(),W&&W.observe(S.unref(h)),S.watchEffect(()=>{const c=t.verbosity;c.objectManager&&i.sceneManager.setObjectManagerLogVerbosity&&i.sceneManager.setObjectManagerLogVerbosity(c.objectManager),c.invoker&&i.sceneManager.setInvokerLogVerbosity&&i.sceneManager.setInvokerLogVerbosity(c.invoker),c.deserializer&&i.sceneManager.setDeserializerLogVerbosity&&i.sceneManager.setDeserializerLogVerbosity(c.deserializer),c.serializer&&i.sceneManager.setSerializerLogVerbosity&&i.sceneManager.setSerializerLogVerbosity(c.serializer)}),await G(!0),i.sceneManager.addObserver?i.cameraIds.forEach(c=>{r.push([c,i.sceneManager.addObserver(c,"ModifiedEvent",()=>{e("camera",i.getState(c))})])}):i.cameraIds.forEach(c=>{r.push([c,i.sceneManager.observe(c,"ModifiedEvent",()=>{e("camera",i.getState(c))})])}),S.watchEffect(()=>{if(i.sceneManager.removeObserver){for(;a.length;){const[c,w]=a.pop();i.sceneManager.removeObserver(c,w)}for(const[c,w]of Object.entries(o.value||{})){const M=Number(c);for(const[z,N]of Object.entries(w||{})){const j=V(s,i,N);a.push([M,i.sceneManager.addObserver(M,z,j)]),j()}}}else{for(;a.length;){const[c,w]=a.pop();i.sceneManager.unObserve(c,w)}for(const[c,w]of Object.entries(o.value||{})){const M=Number(c);for(const[z,N]of Object.entries(w||{})){const j=V(s,i,N);a.push([M,i.sceneManager.observe(M,z,j)]),j()}}}}),i.sceneManager.startEventLoop(t.renderWindow)||console.error("Could not startEventLoop for",t.renderWindow)}),S.onBeforeUnmount(()=>{d&&p();const u=i.sceneManager.removeObserver?"removeObserver":"unObserve";for(;r.length;){const[c,w]=r.pop();i.sceneManager[u](c,w)}for(;a.length;){const[c,w]=a.pop();i.sceneManager[u](c,w)}i.sceneManager.stopEventLoop(t.renderWindow),W&&(W.disconnect(),W=null),i.unbindCanvasToDOM(t.renderWindow)});function oe(u){V(s,i,u)()}function ce(u){return i.getVtkObject(u)}function le(){t.useHandler&&T[t.useHandler]&&delete T[t.useHandler]}return{container:h,update:G,resetCamera:re,evalStateExtract:oe,invoke:ie,printSceneManagerInformation:ae,detachHandler:le,getVtkObject:ce}},template:'<div ref="container" style="position: relative; width: 100%; height: 100%;"></div>'}};function ne(t){Object.keys(_).forEach(e=>{t.component(e,_[e])})}v.install=ne,Object.defineProperty(v,Symbol.toStringTag,{value:"Module"})});
