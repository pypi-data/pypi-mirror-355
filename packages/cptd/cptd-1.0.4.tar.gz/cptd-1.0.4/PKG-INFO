Metadata-Version: 2.4
Name: cptd
Version: 1.0.4
Summary: CPTD CLI
Author: Asbjorn Rasen
Author-email: asbjornrasen@gmail.com
Classifier: Programming Language :: Python :: 3
Classifier: License :: OSI Approved :: MIT License
Classifier: Operating System :: OS Independent
Requires-Python: >=3.7
Description-Content-Type: text/markdown
Requires-Dist: argcomplete>=1.12.0
Dynamic: author
Dynamic: author-email
Dynamic: classifier
Dynamic: description
Dynamic: description-content-type
Dynamic: requires-dist
Dynamic: requires-python
Dynamic: summary

### **🔧 What is CPTD CLI?**

**CPTD CLI** is a flexible command-line system and the primary tool for automating, extending, and managing the functions of the system.

It allows you to:

* manage tasks, events, and DSL files,
* **create your own commands and extensions**,
* **integrate commands with external tools** (scripts, APIs, Git, CI/CD),
* **share commands between users**,
* run commands both from a local directory and from centralized repositories.

🧠 **CPTD CLI is not just an interface — it is a full-fledged *operational shell***
It serves as a bridge between:

* **The CPTD DSL** — a structured text format for defining goals, projects, tasks, and events;
* **User Interfaces** (current and future) — graphical environments that use CLI as their core engine;
* **User and system commands** — extendable automation modules developed within the ecosystem;
* **External tools and scripts** — through launching, exporting, analysis, reporting, and automation.

📦 It’s not just a way to run a command in the terminal — it’s a **universal control layer** through which the user and the system exchange data, actions, and logic.
The CLI enables you to **not just execute code**, but to **orchestrate thinking, structure, and execution**, unifying the DSL, visual UI, and operational logic into a cohesive architecture.

---

### **🧩 Why CPTD CLI is Important and Unique**

#### ✅ **1. Flexibility and Extensibility**

* Every command is just a regular Python file with a defined interface.
* You can **create your own command in under 5 minutes**.
* Supports **automatic dependency installation**: the command declares what it needs.
* Commands are distributed with their own **manifest**: `name`, `description`, `author`, `version`, etc.
* All commands in the shared repository undergo strict security review.

#### ✅ **2. Centralized and Decentralized Modes**

* You can use local commands (`./commands/`) or connect to a **shared repository** where users exchange scripts and utilities.
* The system supports a standard format for distributed CLI command repositories.

#### ✅ **3. Empowerment for Admins and Users**

* Admins can write commands that:

  * analyze user activity,
  * generate reports and strategic plans,
  * check licenses and enforce security policies.
* Users can automate repetitive actions, create templates, plan workflows, and document their activities.

#### ✅ **4. Minimalism + Power**

* The CLI remains **lightweight** and **intuitive**: everything is stored in plain files.
* No internet, no heavy installations, no cloud dependency.
* Runs equally well on **Windows, Linux, and macOS**.
* Fully **offline-capable**, secure, and suited for controlled environments.

---

### 🛠 Examples of Why CPTD CLI is Indispensable

| Command           | Description                                            |
| ----------------- | ------------------------------------------------------ |
| `cptd init`       | Quickly initialize project folder structure            |
| `cptd dashboard`  | Display goals, projects, and tasks in a dashboard view |
| `cptd parse`      | Parse and analyze DSL files, extract key insights      |
| `cptd newcommand` | Generate a scaffold for a new user-defined command     |
| `cptd setpath`    | Define environment paths and DSL variables             |
| `cptd report`     | Generate progress reports from CPTD files              |
| `cptd command`    | Add user-defined or system-level command modules       |
| `cptd .......`    | Your custom commands and shared tools                  |

---

### 🚀 **Why You Should Use CPTD CLI**

* **Control**: Full access to your structure, data, and command logic — no third-party dependencies.
* **Security**: No tracking, no external data flow — fully local. Ideal for internal, secure, or classified environments.
* **Scalability**: Works from a single-user setup to a 100+ member team without structural changes.
* **Compatibility**: Git-based workflow, Python integration, CI/CD support.
* **Ecosystem Growth**: Connect hundreds of unique commands, share them, and build a unified DSL-driven ecosystem.

---

## 🔁 **CPTD CLI as a Platform for Expansion and Exchange**

**CPTD CLI** is not just a control tool — it is a **development platform**, designed for sharing, customization, and functional expansion through user-defined commands.

### 🔨 Create Your Own Commands

* CPTD CLI commands are regular Python modules with a minimal structure.
* Any user can build a command in 1–2 minutes using the `cptd newcommand` template.
* Commands are described with a manifest: `name`, `version`, `author`, `description`, `dependencies`.

### 🌐 Share and Connect

* Commands can be **distributed**, shared, and loaded from shared repositories.
* Follows a **plugin-like modular design**, similar to systems like Obsidian or Homebrew.
* Supports loading from network, GitHub, or local storage — and centralized connection for team use.

### ⚙️ Automatic Dependency Handling

* On first run, a command can **automatically install required dependencies** from its manifest.
* No need for users to manually configure the environment — the system handles it.

### 📌 Why It Matters

* **Flexibility**: Adapt the CLI to any workflow — from license validation to automated reporting.
* **Scalability**: Individual users or teams can expand functionality independently.
* **Community Power**: Build and share a growing library of commands and solutions.
* **Autonomy**: Everything runs locally, transparently, and without hidden mechanisms.

---

**CPTD CLI is not just a terminal. It is an expandable command system through which users can build, automate, and share tools that actually work.**

---
