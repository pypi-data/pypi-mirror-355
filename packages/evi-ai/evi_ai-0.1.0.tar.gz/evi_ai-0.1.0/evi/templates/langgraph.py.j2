# LangGraph Agent System
# Generated by evi - Multi-Agent Framework Generator

from typing import TypedDict, Annotated, Sequence, List
from typing_extensions import Annotated
from langgraph.graph import StateGraph
from langchain_openai import ChatOpenAI
from langchain.schema import HumanMessage, SystemMessage, AIMessage
from langchain_core.tools import tool

# Define the state
class GraphState(TypedDict):
    {% for attr in state %}
    {{ attr.name }}: {{ attr.type }}  # {{ attr.description }}
    {% endfor %}

# Initialize tools
{% for tool in tools %}
@tool("{{ tool.name }}")
def {{ tool.name }}({{ ", ".join(tool.args) }}) -> str:
    """{{ tool.description }}"""
    # TODO: Implement the tool functionality
    return "Result from {{ tool.name }}"

{% endfor %}

# Define node functions
{% for node in nodes %}
{% if node.type == "agent" %}
def {{ node.name }}_node(state: GraphState) -> GraphState:
    """{{ node.description }}"""
    messages = [
        SystemMessage(content="You are an assistant helping with a task."),
        HumanMessage(content=f"Current state: {state}")
    ]
    
    model = ChatOpenAI(temperature=0)
    response = model.invoke(messages)
    
    # Process response and update state
    # TODO: Add custom processing here
    
    return {**state, "messages": state["messages"] + [response]}
{% elif node.type == "tool" %}
def {{ node.name }}_node(state: GraphState) -> GraphState:
    """{{ node.description }}"""
    # TODO: Implement tool logic here
    {% if node.config.tool %}
    result = {{ node.config.tool }}(**state["{{ node.config.input }}"])
    return {**state, "{{ node.config.output }}": result}
    {% else %}
    # Default implementation
    return state
    {% endif %}
{% elif node.type == "conditional" %}
def {{ node.name }}_node(state: GraphState) -> str:
    """{{ node.description }}"""
    # Define the routing logic
    # TODO: Implement conditional logic here
    condition = "default"  # Replace with actual condition check
    return condition
{% endif %}
{% endfor %}

# Build the graph
def build_graph():
    workflow = StateGraph(GraphState)
    
    # Add nodes
    {% for node in nodes %}
    workflow.add_node("{{ node.name }}", {{ node.name }}_node)
    {% endfor %}
    
    # Add edges
    {% for edge in edges %}
    {% if edge.condition %}
    workflow.add_conditional_edges(
        "{{ edge.source }}",
        lambda state: {{ edge.source }}_node(state),
        {
            "{{ edge.condition }}": "{{ edge.target }}"
        }
    )
    {% else %}
    workflow.add_edge("{{ edge.source }}", "{{ edge.target }}")
    {% endif %}
    {% endfor %}
    
    # Set entrypoint
    workflow.set_entry_point("{{ entrypoint }}")
    
    return workflow.compile()

# Create the graph
graph = build_graph()

# Initialize state
initial_state = GraphState(
    {% for attr in state %}
    {{ attr.name }}={{ attr.default|default("None") }},
    {% endfor %}
)

# Run the graph
if __name__ == "__main__":
    for output in graph.stream(initial_state):
        if "END" not in output:
            print(f"Output: {output}")
