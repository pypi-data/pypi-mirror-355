// frontend/templates/control_widget.html
var control_widget_default = '<div class="widget control-widget">\n  <div class="control-buttons">\n    <button id="btn-toggle-play"></button>\n  </div>\n  <div class="progress-slider">\n    <input\n      type="range"\n      min="0"\n      max="1"\n      value="0"\n      step="0.01"\n      class="slider"\n      id="input-range-progress"\n    />\n  </div>\n  <div class="time-display">\n    <span id="span-current-time" class="time">00:00</span>\n    <span class="seperator">/</span>\n    <span id="span-total-time" class="time">00:00</span>\n  </div>\n</div>\n';

// frontend/control_widget.ts
var ControlWidget = class {
  constructor({ model, el }) {
    this.lastAnimationFrameTimestamp = null;
    this.animationFrameRequestId = null;
    this.model = model;
    this.el = el;
    this.currentTime = this.model.get("sync_time");
    this.el.innerHTML = control_widget_default;
    this.btnTogglePlay = el.querySelector("#btn-toggle-play");
    this.inputRangeProgress = el.querySelector("#input-range-progress");
    this.spanCurrentTime = el.querySelector("#span-current-time");
    this.spanTotalTime = el.querySelector("#span-total-time");
    this.btnTogglePlay.innerHTML = this.model.get("icons").play;
    this.spanTotalTime.innerHTML = this.formatTime(this.model.get("duration"));
    this.btnTogglePlay.addEventListener(
      "click",
      this.btnTogglePlayClicked.bind(this)
    );
    this.inputRangeProgress.addEventListener(
      "change",
      this.inputRangeProgressChanged.bind(this)
    );
  }
  inputRangeProgressChanged(event) {
    const value = +event.target.value;
    this.currentTime = value * this.model.get("duration");
    this.model.set("sync_time", this.currentTime);
    this.model.save_changes();
  }
  btnTogglePlayClicked() {
    this.model.set("sync_time", this.currentTime);
    this.model.set("is_running", !this.model.get("is_running"));
    this.model.save_changes();
  }
  step(timestamp) {
    if (!this.lastAnimationFrameTimestamp)
      this.lastAnimationFrameTimestamp = timestamp;
    const delta = timestamp - this.lastAnimationFrameTimestamp;
    this.lastAnimationFrameTimestamp = timestamp;
    if (this.model.get("is_running")) {
      const duration = this.model.get("duration");
      this.currentTime = Math.min(this.currentTime + delta / 1e3, duration);
      this.inputRangeProgress.value = (this.currentTime / duration).toFixed(2);
      this.spanCurrentTime.innerHTML = this.formatTime(this.currentTime);
    }
    this.animationFrameRequestId = requestAnimationFrame(this.step);
  }
  syncTimeChanged() {
    this.currentTime = this.model.get("sync_time");
    this.inputRangeProgress.value = (this.currentTime / this.model.get("duration")).toFixed(2);
  }
  isRunningChanged() {
    this.btnTogglePlay.innerHTML = !this.model.get("is_running") ? this.model.get("icons").play : this.model.get("icons").pause;
  }
  formatTime(seconds) {
    const hrs = Math.floor(seconds / 3600);
    const mins = Math.floor(seconds % 3600 / 60);
    const secs = Math.floor(seconds % 60);
    const paddedMins = String(mins).padStart(2, "0");
    const paddedSecs = String(secs).padStart(2, "0");
    return hrs > 0 ? `${String(hrs).padStart(2, "0")}:${paddedMins}:${paddedSecs}` : `${paddedMins}:${paddedSecs}`;
  }
  render() {
    this.model.on("change:sync_time", this.syncTimeChanged.bind(this));
    this.model.on("change:is_running", this.isRunningChanged.bind(this));
    this.step = this.step.bind(this);
    this.animationFrameRequestId = requestAnimationFrame(this.step);
  }
  destroy() {
    cancelAnimationFrame(this.animationFrameRequestId);
  }
};
var control_widget_default2 = {
  render(props) {
    const widget = new ControlWidget(props);
    widget.render();
    return () => widget.destroy();
  }
};
export {
  control_widget_default2 as default
};
//# sourceMappingURL=data:application/json;base64,ewogICJ2ZXJzaW9uIjogMywKICAic291cmNlcyI6IFsiLi4vLi4vLi4vZnJvbnRlbmQvdGVtcGxhdGVzL2NvbnRyb2xfd2lkZ2V0Lmh0bWwiLCAiLi4vLi4vLi4vZnJvbnRlbmQvY29udHJvbF93aWRnZXQudHMiXSwKICAic291cmNlc0NvbnRlbnQiOiBbIjxkaXYgY2xhc3M9XCJ3aWRnZXQgY29udHJvbC13aWRnZXRcIj5cbiAgPGRpdiBjbGFzcz1cImNvbnRyb2wtYnV0dG9uc1wiPlxuICAgIDxidXR0b24gaWQ9XCJidG4tdG9nZ2xlLXBsYXlcIj48L2J1dHRvbj5cbiAgPC9kaXY+XG4gIDxkaXYgY2xhc3M9XCJwcm9ncmVzcy1zbGlkZXJcIj5cbiAgICA8aW5wdXRcbiAgICAgIHR5cGU9XCJyYW5nZVwiXG4gICAgICBtaW49XCIwXCJcbiAgICAgIG1heD1cIjFcIlxuICAgICAgdmFsdWU9XCIwXCJcbiAgICAgIHN0ZXA9XCIwLjAxXCJcbiAgICAgIGNsYXNzPVwic2xpZGVyXCJcbiAgICAgIGlkPVwiaW5wdXQtcmFuZ2UtcHJvZ3Jlc3NcIlxuICAgIC8+XG4gIDwvZGl2PlxuICA8ZGl2IGNsYXNzPVwidGltZS1kaXNwbGF5XCI+XG4gICAgPHNwYW4gaWQ9XCJzcGFuLWN1cnJlbnQtdGltZVwiIGNsYXNzPVwidGltZVwiPjAwOjAwPC9zcGFuPlxuICAgIDxzcGFuIGNsYXNzPVwic2VwZXJhdG9yXCI+Lzwvc3Bhbj5cbiAgICA8c3BhbiBpZD1cInNwYW4tdG90YWwtdGltZVwiIGNsYXNzPVwidGltZVwiPjAwOjAwPC9zcGFuPlxuICA8L2Rpdj5cbjwvZGl2PlxuIiwgImltcG9ydCB0eXBlIHsgQW55TW9kZWwsIFJlbmRlclByb3BzIH0gZnJvbSAnQGFueXdpZGdldC90eXBlcyc7XG5pbXBvcnQgJy4vc3R5bGVzL3dpZGdldC5jc3MnO1xuaW1wb3J0ICcuL3N0eWxlcy9jb250cm9sX3dpZGdldC5jc3MnO1xuaW1wb3J0IGNvbnRyb2xUZW1wbGF0ZSBmcm9tICcuL3RlbXBsYXRlcy9jb250cm9sX3dpZGdldC5odG1sJztcblxuaW50ZXJmYWNlIENvbnRyb2xXaWRnZXRNb2RlbCB7XG4gIGlzX3J1bm5pbmc6IGJvb2xlYW47XG4gIGR1cmF0aW9uOiBudW1iZXI7XG4gIHN5bmNfdGltZTogbnVtYmVyO1xuICBpY29uczoge1xuICAgIHBsYXk6IHN0cmluZztcbiAgICBwYXVzZTogc3RyaW5nO1xuICB9O1xufVxuXG5jbGFzcyBDb250cm9sV2lkZ2V0IHtcbiAgZWw6IEhUTUxFbGVtZW50O1xuICBtb2RlbDogQW55TW9kZWw8Q29udHJvbFdpZGdldE1vZGVsPjtcblxuICBjdXJyZW50VGltZTogbnVtYmVyO1xuICBsYXN0QW5pbWF0aW9uRnJhbWVUaW1lc3RhbXA6IERPTUhpZ2hSZXNUaW1lU3RhbXAgfCBudWxsID0gbnVsbDtcbiAgYW5pbWF0aW9uRnJhbWVSZXF1ZXN0SWQ6IG51bWJlciB8IG51bGwgPSBudWxsO1xuXG4gIGJ0blRvZ2dsZVBsYXk6IEhUTUxCdXR0b25FbGVtZW50O1xuICBpbnB1dFJhbmdlUHJvZ3Jlc3M6IEhUTUxJbnB1dEVsZW1lbnQ7XG4gIHNwYW5DdXJyZW50VGltZTogSFRNTFNwYW5FbGVtZW50O1xuICBzcGFuVG90YWxUaW1lOiBIVE1MU3BhbkVsZW1lbnQ7XG5cbiAgY29uc3RydWN0b3IoeyBtb2RlbCwgZWwgfTogUmVuZGVyUHJvcHM8Q29udHJvbFdpZGdldE1vZGVsPikge1xuICAgIHRoaXMubW9kZWwgPSBtb2RlbDtcbiAgICB0aGlzLmVsID0gZWw7XG5cbiAgICB0aGlzLmN1cnJlbnRUaW1lID0gdGhpcy5tb2RlbC5nZXQoJ3N5bmNfdGltZScpO1xuXG4gICAgLy8gSW5pdGlhbGl6ZSBET00gZWxlbWVudHNcbiAgICB0aGlzLmVsLmlubmVySFRNTCA9IGNvbnRyb2xUZW1wbGF0ZTtcbiAgICB0aGlzLmJ0blRvZ2dsZVBsYXkgPSBlbC5xdWVyeVNlbGVjdG9yKCcjYnRuLXRvZ2dsZS1wbGF5JykhO1xuICAgIHRoaXMuaW5wdXRSYW5nZVByb2dyZXNzID0gZWwucXVlcnlTZWxlY3RvcignI2lucHV0LXJhbmdlLXByb2dyZXNzJykhO1xuICAgIHRoaXMuc3BhbkN1cnJlbnRUaW1lID0gZWwucXVlcnlTZWxlY3RvcignI3NwYW4tY3VycmVudC10aW1lJykhO1xuICAgIHRoaXMuc3BhblRvdGFsVGltZSA9IGVsLnF1ZXJ5U2VsZWN0b3IoJyNzcGFuLXRvdGFsLXRpbWUnKSE7XG5cbiAgICAvLyBTZXQgaW5pdGlhbCBzdGF0ZSBVSVxuICAgIHRoaXMuYnRuVG9nZ2xlUGxheS5pbm5lckhUTUwgPSB0aGlzLm1vZGVsLmdldCgnaWNvbnMnKS5wbGF5O1xuICAgIHRoaXMuc3BhblRvdGFsVGltZS5pbm5lckhUTUwgPSB0aGlzLmZvcm1hdFRpbWUodGhpcy5tb2RlbC5nZXQoJ2R1cmF0aW9uJykpO1xuXG4gICAgLy8gRXZlbnQgbGlzdGVuZXJlc1xuICAgIHRoaXMuYnRuVG9nZ2xlUGxheS5hZGRFdmVudExpc3RlbmVyKFxuICAgICAgJ2NsaWNrJyxcbiAgICAgIHRoaXMuYnRuVG9nZ2xlUGxheUNsaWNrZWQuYmluZCh0aGlzKVxuICAgICk7XG4gICAgdGhpcy5pbnB1dFJhbmdlUHJvZ3Jlc3MuYWRkRXZlbnRMaXN0ZW5lcihcbiAgICAgICdjaGFuZ2UnLFxuICAgICAgdGhpcy5pbnB1dFJhbmdlUHJvZ3Jlc3NDaGFuZ2VkLmJpbmQodGhpcylcbiAgICApO1xuICB9XG5cbiAgaW5wdXRSYW5nZVByb2dyZXNzQ2hhbmdlZChldmVudDogRXZlbnQpIHtcbiAgICBjb25zdCB2YWx1ZSA9ICsoZXZlbnQudGFyZ2V0IGFzIEhUTUxJbnB1dEVsZW1lbnQpLnZhbHVlO1xuICAgIHRoaXMuY3VycmVudFRpbWUgPSB2YWx1ZSAqIHRoaXMubW9kZWwuZ2V0KCdkdXJhdGlvbicpO1xuICAgIHRoaXMubW9kZWwuc2V0KCdzeW5jX3RpbWUnLCB0aGlzLmN1cnJlbnRUaW1lKTtcbiAgICB0aGlzLm1vZGVsLnNhdmVfY2hhbmdlcygpO1xuICB9XG5cbiAgYnRuVG9nZ2xlUGxheUNsaWNrZWQoKSB7XG4gICAgdGhpcy5tb2RlbC5zZXQoJ3N5bmNfdGltZScsIHRoaXMuY3VycmVudFRpbWUpO1xuICAgIHRoaXMubW9kZWwuc2V0KCdpc19ydW5uaW5nJywgIXRoaXMubW9kZWwuZ2V0KCdpc19ydW5uaW5nJykpO1xuICAgIHRoaXMubW9kZWwuc2F2ZV9jaGFuZ2VzKCk7XG4gIH1cblxuICBzdGVwKHRpbWVzdGFtcDogRE9NSGlnaFJlc1RpbWVTdGFtcCkge1xuICAgIGlmICghdGhpcy5sYXN0QW5pbWF0aW9uRnJhbWVUaW1lc3RhbXApXG4gICAgICB0aGlzLmxhc3RBbmltYXRpb25GcmFtZVRpbWVzdGFtcCA9IHRpbWVzdGFtcDtcbiAgICBjb25zdCBkZWx0YSA9IHRpbWVzdGFtcCAtIHRoaXMubGFzdEFuaW1hdGlvbkZyYW1lVGltZXN0YW1wO1xuICAgIHRoaXMubGFzdEFuaW1hdGlvbkZyYW1lVGltZXN0YW1wID0gdGltZXN0YW1wO1xuXG4gICAgaWYgKHRoaXMubW9kZWwuZ2V0KCdpc19ydW5uaW5nJykpIHtcbiAgICAgIGNvbnN0IGR1cmF0aW9uID0gdGhpcy5tb2RlbC5nZXQoJ2R1cmF0aW9uJyk7XG4gICAgICB0aGlzLmN1cnJlbnRUaW1lID0gTWF0aC5taW4odGhpcy5jdXJyZW50VGltZSArIGRlbHRhIC8gMTAwMCwgZHVyYXRpb24pO1xuICAgICAgdGhpcy5pbnB1dFJhbmdlUHJvZ3Jlc3MudmFsdWUgPSAodGhpcy5jdXJyZW50VGltZSAvIGR1cmF0aW9uKS50b0ZpeGVkKDIpO1xuICAgICAgdGhpcy5zcGFuQ3VycmVudFRpbWUuaW5uZXJIVE1MID0gdGhpcy5mb3JtYXRUaW1lKHRoaXMuY3VycmVudFRpbWUpO1xuICAgIH1cblxuICAgIHRoaXMuYW5pbWF0aW9uRnJhbWVSZXF1ZXN0SWQgPSByZXF1ZXN0QW5pbWF0aW9uRnJhbWUodGhpcy5zdGVwKTtcbiAgfVxuXG4gIHN5bmNUaW1lQ2hhbmdlZCgpIHtcbiAgICB0aGlzLmN1cnJlbnRUaW1lID0gdGhpcy5tb2RlbC5nZXQoJ3N5bmNfdGltZScpO1xuICAgIHRoaXMuaW5wdXRSYW5nZVByb2dyZXNzLnZhbHVlID0gKFxuICAgICAgdGhpcy5jdXJyZW50VGltZSAvIHRoaXMubW9kZWwuZ2V0KCdkdXJhdGlvbicpXG4gICAgKS50b0ZpeGVkKDIpO1xuICB9XG5cbiAgaXNSdW5uaW5nQ2hhbmdlZCgpIHtcbiAgICB0aGlzLmJ0blRvZ2dsZVBsYXkuaW5uZXJIVE1MID0gIXRoaXMubW9kZWwuZ2V0KCdpc19ydW5uaW5nJylcbiAgICAgID8gdGhpcy5tb2RlbC5nZXQoJ2ljb25zJykucGxheVxuICAgICAgOiB0aGlzLm1vZGVsLmdldCgnaWNvbnMnKS5wYXVzZTtcbiAgfVxuXG4gIGZvcm1hdFRpbWUoc2Vjb25kczogbnVtYmVyKTogc3RyaW5nIHtcbiAgICBjb25zdCBocnMgPSBNYXRoLmZsb29yKHNlY29uZHMgLyAzNjAwKTtcbiAgICBjb25zdCBtaW5zID0gTWF0aC5mbG9vcigoc2Vjb25kcyAlIDM2MDApIC8gNjApO1xuICAgIGNvbnN0IHNlY3MgPSBNYXRoLmZsb29yKHNlY29uZHMgJSA2MCk7XG5cbiAgICBjb25zdCBwYWRkZWRNaW5zID0gU3RyaW5nKG1pbnMpLnBhZFN0YXJ0KDIsICcwJyk7XG4gICAgY29uc3QgcGFkZGVkU2VjcyA9IFN0cmluZyhzZWNzKS5wYWRTdGFydCgyLCAnMCcpO1xuXG4gICAgcmV0dXJuIGhycyA+IDBcbiAgICAgID8gYCR7U3RyaW5nKGhycykucGFkU3RhcnQoMiwgJzAnKX06JHtwYWRkZWRNaW5zfToke3BhZGRlZFNlY3N9YFxuICAgICAgOiBgJHtwYWRkZWRNaW5zfToke3BhZGRlZFNlY3N9YDtcbiAgfVxuXG4gIHJlbmRlcigpIHtcbiAgICB0aGlzLm1vZGVsLm9uKCdjaGFuZ2U6c3luY190aW1lJywgdGhpcy5zeW5jVGltZUNoYW5nZWQuYmluZCh0aGlzKSk7XG4gICAgdGhpcy5tb2RlbC5vbignY2hhbmdlOmlzX3J1bm5pbmcnLCB0aGlzLmlzUnVubmluZ0NoYW5nZWQuYmluZCh0aGlzKSk7XG5cbiAgICB0aGlzLnN0ZXAgPSB0aGlzLnN0ZXAuYmluZCh0aGlzKTtcbiAgICB0aGlzLmFuaW1hdGlvbkZyYW1lUmVxdWVzdElkID0gcmVxdWVzdEFuaW1hdGlvbkZyYW1lKHRoaXMuc3RlcCk7XG4gIH1cblxuICBkZXN0cm95KCkge1xuICAgIGNhbmNlbEFuaW1hdGlvbkZyYW1lKHRoaXMuYW5pbWF0aW9uRnJhbWVSZXF1ZXN0SWQhKTtcbiAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCB7XG4gIHJlbmRlcihwcm9wczogUmVuZGVyUHJvcHM8Q29udHJvbFdpZGdldE1vZGVsPikge1xuICAgIGNvbnN0IHdpZGdldCA9IG5ldyBDb250cm9sV2lkZ2V0KHByb3BzKTtcbiAgICB3aWRnZXQucmVuZGVyKCk7XG4gICAgcmV0dXJuICgpID0+IHdpZGdldC5kZXN0cm95KCk7XG4gIH0sXG59O1xuIl0sCiAgIm1hcHBpbmdzIjogIjtBQUFBOzs7QUNlQSxJQUFNLGdCQUFOLE1BQW9CO0FBQUEsRUFhbEIsWUFBWSxFQUFFLE9BQU8sR0FBRyxHQUFvQztBQVI1RCx1Q0FBMEQ7QUFDMUQsbUNBQXlDO0FBUXZDLFNBQUssUUFBUTtBQUNiLFNBQUssS0FBSztBQUVWLFNBQUssY0FBYyxLQUFLLE1BQU0sSUFBSSxXQUFXO0FBRzdDLFNBQUssR0FBRyxZQUFZO0FBQ3BCLFNBQUssZ0JBQWdCLEdBQUcsY0FBYyxrQkFBa0I7QUFDeEQsU0FBSyxxQkFBcUIsR0FBRyxjQUFjLHVCQUF1QjtBQUNsRSxTQUFLLGtCQUFrQixHQUFHLGNBQWMsb0JBQW9CO0FBQzVELFNBQUssZ0JBQWdCLEdBQUcsY0FBYyxrQkFBa0I7QUFHeEQsU0FBSyxjQUFjLFlBQVksS0FBSyxNQUFNLElBQUksT0FBTyxFQUFFO0FBQ3ZELFNBQUssY0FBYyxZQUFZLEtBQUssV0FBVyxLQUFLLE1BQU0sSUFBSSxVQUFVLENBQUM7QUFHekUsU0FBSyxjQUFjO0FBQUEsTUFDakI7QUFBQSxNQUNBLEtBQUsscUJBQXFCLEtBQUssSUFBSTtBQUFBLElBQ3JDO0FBQ0EsU0FBSyxt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
