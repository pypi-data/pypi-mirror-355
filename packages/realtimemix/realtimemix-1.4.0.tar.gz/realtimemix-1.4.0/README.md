# realtimemix

![Python](https://img.shields.io/badge/python-3.9+-blue.svg)
![License](https://img.shields.io/badge/license-MIT-green.svg)
![Version](https://img.shields.io/badge/version-1.1.1-orange.svg)

ä¸€ä¸ªé«˜æ€§èƒ½çš„Pythonå®æ—¶éŸ³é¢‘æ··éŸ³å¼•æ“ï¼Œä¸“ä¸ºä¸“ä¸šéŸ³é¢‘åº”ç”¨ã€è¯­éŸ³å¤„ç†å’Œå¤šåª’ä½“é¡¹ç›®è®¾è®¡ã€‚

## âœ¨ æ ¸å¿ƒç‰¹æ€§

### ğŸµ å®æ—¶éŸ³é¢‘å¤„ç†
- **ä½å»¶è¿Ÿæ··éŸ³** - å¯é…ç½®ç¼“å†²åŒºå¤§å°ï¼Œæ”¯æŒä¸“ä¸šçº§éŸ³é¢‘å»¶è¿Ÿæ§åˆ¶
- **å¤šè½¨å¹¶è¡Œå¤„ç†** - åŒæ—¶å¤„ç†å¤šè¾¾32+ä¸ªéŸ³é¢‘è½¨é“ï¼Œçº¿ç¨‹å®‰å…¨è®¾è®¡
- **é›¶å»¶è¿Ÿåˆ‡æ¢** - æ”¯æŒç¬æ—¶éŸ³é¢‘åˆ‡æ¢ï¼Œæ— æ·¡å…¥æ·¡å‡ºå»¶è¿Ÿ
- **é«˜è´¨é‡é‡é‡‡æ ·** - é›†æˆlibrosa/scipyé«˜çº§éŸ³é¢‘å¤„ç†ç®—æ³•

### ğŸšï¸ ä¸“ä¸šéŸ³é¢‘åŠŸèƒ½
- **Matcheringé›†æˆ** - å†…ç½®ä¸“ä¸šéŸ³é¢‘åŒ¹é…æŠ€æœ¯ï¼Œè‡ªåŠ¨å‡è¡¡ã€å“åº¦å’Œé¢‘ç‡åŒ¹é…
- **å“åº¦åˆ†æä¸åŒ¹é…** - RMSå“åº¦è®¡ç®—ï¼Œè‡ªåŠ¨éŸ³é‡çº§åˆ«åŒ¹é…
- **äº¤å‰æ·¡å…¥æ·¡å‡º** - ä¸“ä¸šçº§éŸ³é¢‘è¿‡æ¸¡æ•ˆæœ
- **æ¸©å’ŒEQå¤„ç†** - å‡å°‘é‡‘å±éŸ³è‰²çš„æ™ºèƒ½éŸ³é¢‘å¤„ç†

### ğŸ’¾ å¤§æ–‡ä»¶æ”¯æŒ
- **æµå¼æ’­æ”¾** - æ”¯æŒGBçº§å¤§æ–‡ä»¶çš„å†…å­˜é«˜æ•ˆæ’­æ”¾
- **æ™ºèƒ½ç¼“å­˜** - ä¼˜åŒ–çš„ç¼“å†²æ± å’Œå†…å­˜ç®¡ç†
- **å¼‚æ­¥åŠ è½½** - éé˜»å¡éŸ³é¢‘æ–‡ä»¶åŠ è½½ï¼Œæ”¯æŒè¿›åº¦å›è°ƒ
- **é™éŸ³å¡«å……** - ç²¾ç¡®çš„éŸ³é¢‘æ—¶åºæ§åˆ¶å’Œå¯¹é½

### ğŸ”Š éŸ³é¢‘æ•ˆæœä¸æ§åˆ¶
- **å®æ—¶éŸ³é‡æ§åˆ¶** - åŠ¨æ€éŸ³é‡è°ƒèŠ‚ï¼Œæ”¯æŒæ¸å˜æ•ˆæœ
- **å˜é€Ÿæ’­æ”¾** - ä¿æŒéŸ³è°ƒçš„é€Ÿåº¦è°ƒèŠ‚ï¼ˆå¯é€‰pyrubberbandæ”¯æŒï¼‰
- **å¾ªç¯æ’­æ”¾** - æ— ç¼å¾ªç¯ï¼Œæ”¯æŒç²¾ç¡®å¾ªç¯ç‚¹æ§åˆ¶
- **å¤šç§éŸ³é¢‘æ ¼å¼** - é€šè¿‡soundfileæ”¯æŒWAVã€FLACã€MP3ç­‰æ ¼å¼

### â° å®æ—¶ä½ç½®å›è°ƒ **[æ–°åŠŸèƒ½]**
- **é«˜ç²¾åº¦å›è°ƒ** - 5-15msç²¾åº¦çš„éŸ³é¢‘ä½ç½®å›è°ƒæœºåˆ¶
- **TTSç²¾ç¡®æ’å…¥** - æ”¯æŒåœ¨éŸ³é¢‘ç‰¹å®šä½ç½®ç²¾ç¡®æ’å…¥è¯­éŸ³
- **å…¨å±€ä½ç½®ç›‘å¬** - å®æ—¶ç›‘æ§æ‰€æœ‰è½¨é“çš„æ’­æ”¾ä½ç½®
- **å¤šè½¨é“å›è°ƒ** - æ”¯æŒå¤šä¸ªè½¨é“çš„ç‹¬ç«‹ä½ç½®å›è°ƒç®¡ç†

## ğŸ› ï¸ å®‰è£…

### åŸºç¡€å®‰è£…
```bash
pip install realtimemix
```

### é«˜è´¨é‡éŸ³é¢‘å¤„ç†ï¼ˆæ¨èï¼‰
```bash
pip install realtimemix[high-quality]
```

### Matcheringä¸“ä¸šéŸ³é¢‘åŒ¹é…
```bash
pip install matchering
```

### æ—¶é—´æ‹‰ä¼¸åŠŸèƒ½
```bash
pip install realtimemix[time-stretch]
```

### å®Œæ•´åŠŸèƒ½å®‰è£…
```bash
pip install realtimemix[all]
pip install matchering
```

### å¼€å‘ç¯å¢ƒ
```bash
git clone https://github.com/birchkwok/realtimemix.git
cd realtimemix
pip install -e .[dev]
pip install matchering
```

## ğŸš€ å¿«é€Ÿå¼€å§‹

### åŸºç¡€éŸ³é¢‘æ’­æ”¾

```python
import numpy as np
from realtimemix import AudioEngine

# åˆå§‹åŒ–éŸ³é¢‘å¼•æ“
engine = AudioEngine(
    sample_rate=48000,    # é«˜é‡‡æ ·ç‡
    buffer_size=1024,     # ä½å»¶è¿Ÿç¼“å†²
    channels=2            # ç«‹ä½“å£°
)

# å¯åŠ¨å¼•æ“
engine.start()

# åŠ è½½éŸ³é¢‘æ–‡ä»¶
engine.load_track("background", "music.wav", auto_normalize=True)
engine.load_track("voice", "speech.wav")

# æ’­æ”¾æ§åˆ¶
engine.play("background", loop=True, fade_in=True)
engine.play("voice", volume=0.8)

# å®æ—¶æ§åˆ¶
engine.set_volume("background", 0.3)  # é™ä½èƒŒæ™¯éŸ³ä¹
engine.crossfade("background", "voice", duration=1.5)  # äº¤å‰æ·¡å…¥æ·¡å‡º

# æ¸…ç†
engine.shutdown()
```

### å®æ—¶ä½ç½®å›è°ƒåº”ç”¨

```python
from realtimemix import AudioEngine

# åˆå§‹åŒ–éŸ³é¢‘å¼•æ“
engine = AudioEngine(sample_rate=48000, buffer_size=1024)
engine.start()

# åŠ è½½ä¸»éŸ³é¢‘
engine.load_track("main_audio", "podcast.wav")

# å®šä¹‰TTSæ’å…¥å›è°ƒ
def insert_tts_callback(track_id, target_time, actual_time):
    """åœ¨æŒ‡å®šä½ç½®ç²¾ç¡®æ’å…¥TTSè¯­éŸ³"""
    print(f"ğŸ¯ TTSæ’å…¥è§¦å‘: {actual_time:.3f}s (ç›®æ ‡: {target_time:.3f}s)")
    
    # é™ä½ä¸»éŸ³é¢‘éŸ³é‡
    engine.set_volume("main_audio", 0.2)
    
    # æ’­æ”¾TTSæ’å…¥
    engine.load_track("tts_insert", "ç”Ÿæˆçš„è¯­éŸ³.wav")
    engine.play("tts_insert", volume=0.8)
    
    # 3ç§’åæ¢å¤ä¸»éŸ³é¢‘
    def restore_main():
        engine.stop("tts_insert")
        engine.set_volume("main_audio", 0.8)
    
    # å»¶è¿Ÿæ¢å¤ï¼ˆå®é™…åº”ç”¨ä¸­å¯ä»¥ç›‘å¬TTSæ’­æ”¾å®Œæˆï¼‰
    import threading
    threading.Timer(3.0, restore_main).start()

# æ³¨å†Œç²¾ç¡®ä½ç½®å›è°ƒï¼ˆåœ¨25.5ç§’å¤„æ’å…¥TTSï¼‰
success = engine.register_position_callback(
    track_id="main_audio",
    target_time=25.5,
    callback_func=insert_tts_callback,
    tolerance=0.010  # 10mså®¹å¿åº¦
)

if success:
    print("âœ… ä½ç½®å›è°ƒæ³¨å†ŒæˆåŠŸ")
    
    # å¼€å§‹æ’­æ”¾
    engine.play("main_audio")
    
    # è·å–å›è°ƒç»Ÿè®¡
    stats = engine.get_position_callback_stats()
    print(f"æ´»è·ƒå›è°ƒæ•°: {stats['active_callbacks']}")

# æ¸…ç†
engine.shutdown()
```

### å…¨å±€ä½ç½®ç›‘å¬ç¤ºä¾‹

```python
from realtimemix import AudioEngine

engine = AudioEngine()
engine.start()

# å…¨å±€ä½ç½®ç›‘å¬å™¨
def position_monitor(track_id: str, position: float):
    """ç›‘æ§æ‰€æœ‰è½¨é“çš„æ’­æ”¾ä½ç½®"""
    minutes = int(position // 60)
    seconds = position % 60
    print(f"ğŸµ {track_id}: {minutes:02d}:{seconds:05.2f}")

# æ³¨å†Œå…¨å±€ç›‘å¬å™¨
engine.add_global_position_listener(position_monitor)

# åŠ è½½å¹¶æ’­æ”¾å¤šä¸ªè½¨é“
engine.load_track("bgm", "background.wav")
engine.load_track("voice", "speech.wav")

engine.play("bgm", loop=True, volume=0.3)
engine.play("voice", volume=0.8)

# ç§»é™¤ç›‘å¬å™¨
engine.remove_global_position_listener(position_monitor)
```

### ä¸“ä¸šéŸ³é¢‘åŒ¹é…ï¼ˆMatcheringï¼‰

```python
from realtimemix import AudioEngine

engine = AudioEngine()
engine.start()

# 1. åŠ è½½ä¸»éŸ³è½¨ï¼ˆå‚è€ƒéŸ³è½¨ï¼‰
engine.load_track("main_audio", "ä¸»éŸ³é¢‘.wav")

# 2. ä½¿ç”¨MatcheringåŠ è½½å¹¶åŒ¹é…å‰¯éŸ³è½¨
success = engine.load_track_with_matchering(
    track_id="sub_audio",
    file_path="å‰¯éŸ³é¢‘.wav",
    reference_track_id="main_audio",
    reference_start_sec=10.0,      # ä»ä¸»éŸ³é¢‘10ç§’å¤„å¼€å§‹å‚è€ƒ
    reference_duration_sec=5.0,    # å‚è€ƒ5ç§’ç‰‡æ®µ
    gentle_matchering=True         # ä½¿ç”¨æ¸©å’Œå¤„ç†å‡å°‘é‡‘å±éŸ³è‰²
)

if success:
    # æ’­æ”¾åŒ¹é…åçš„éŸ³é¢‘ï¼ŒéŸ³è´¨å’Œå“åº¦å·²è‡ªåŠ¨åŒ¹é…
    engine.play("main_audio")
    # åœ¨åˆé€‚æ—¶æœºåˆ‡æ¢åˆ°å‰¯éŸ³è½¨ï¼ŒéŸ³è´¨å®Œç¾è¡”æ¥
    engine.crossfade("main_audio", "sub_audio", duration=0.1)

engine.shutdown()
```

### è¯­éŸ³æ— ç¼èåˆåº”ç”¨

```python
from realtimemix import AudioEngine

class SpeechFusion:
    def __init__(self):
        self.engine = AudioEngine(sample_rate=48000, channels=2)
        self.engine.start()
    
    def fuse_speech(self, main_file: str, insert_file: str, insert_at: float):
        """åœ¨æŒ‡å®šæ—¶é—´ç‚¹æ— ç¼æ’å…¥è¯­éŸ³ç‰‡æ®µ"""
        
        # åŠ è½½ä¸»è¯­éŸ³
        self.engine.load_track("main", main_file)
        
        # ä½¿ç”¨MatcheringåŠ è½½æ’å…¥è¯­éŸ³ï¼Œè‡ªåŠ¨åŒ¹é…ä¸»è¯­éŸ³ç‰¹å¾
        success = self.engine.load_track_with_matchering(
            track_id="insert",
            file_path=insert_file,
            reference_track_id="main",
            reference_start_sec=insert_at,
            reference_duration_sec=3.0,
            silent_lpadding_ms=100  # 100mså‰ç½®é™éŸ³å¯¹é½
        )
        
        if success:
            # æ’­æ”¾ä¸»è¯­éŸ³åˆ°åˆ‡æ¢ç‚¹
            self.engine.play("main")
            self._wait_to_position(insert_at)
            
            # é›¶å»¶è¿Ÿç¬æ—¶åˆ‡æ¢
            self.engine.set_volume("main", 0.0)
            self.engine.play("insert", volume=0.8)
            
            # æ’å…¥è¯­éŸ³æ’­æ”¾å®Œæ¯•åæ¢å¤ä¸»è¯­éŸ³
            insert_duration = self._get_track_duration("insert")
            self._wait_duration(insert_duration)
            self.engine.set_volume("insert", 0.0)
            self.engine.set_volume("main", 0.8)
    
    def _wait_to_position(self, seconds: float):
        import time
        time.sleep(seconds)
    
    def _wait_duration(self, seconds: float):
        import time
        time.sleep(seconds)
    
    def _get_track_duration(self, track_id: str) -> float:
        info = self.engine.get_track_info(track_id)
        return info.get('duration', 0.0) if info else 0.0

# ä½¿ç”¨ç¤ºä¾‹
fusion = SpeechFusion()
fusion.fuse_speech("é•¿ç¯‡è¯­éŸ³.wav", "æ’å…¥ç‰‡æ®µ.wav", insert_at=30.0)
```

### å¤§æ–‡ä»¶æµå¼æ’­æ”¾

```python
from realtimemix import AudioEngine

# é’ˆå¯¹å¤§æ–‡ä»¶ä¼˜åŒ–çš„é…ç½®
engine = AudioEngine(
    enable_streaming=True,
    streaming_threshold_mb=50,    # 50MBä»¥ä¸Šå¯ç”¨æµå¼æ’­æ”¾
    max_tracks=8                  # é™åˆ¶å¹¶å‘è½¨é“æ•°
)

engine.start()

# åŠ è½½å¤§æ–‡ä»¶ï¼ˆè‡ªåŠ¨å¯ç”¨æµå¼æ’­æ”¾ï¼‰
def on_progress(track_id, progress, message=""):
    print(f"åŠ è½½è¿›åº¦ {track_id}: {progress:.1%} - {message}")

def on_complete(track_id, success, error=None):
    if success:
        print(f"å¤§æ–‡ä»¶ {track_id} åŠ è½½æˆåŠŸï¼Œå¼€å§‹æ’­æ”¾")
        engine.play(track_id)
    else:
        print(f"åŠ è½½å¤±è´¥: {error}")

engine.load_track(
    "large_audio", 
    "å¤§éŸ³é¢‘æ–‡ä»¶.wav",
    progress_callback=on_progress,
    on_complete=on_complete
)

# å¼‚æ­¥åŠ è½½ï¼Œä¸é˜»å¡ä¸»çº¿ç¨‹
print("ç»§ç»­æ‰§è¡Œå…¶ä»–ä»»åŠ¡...")
```

## ğŸ“š æ ¸å¿ƒAPIå‚è€ƒ

### AudioEngine

#### æ„é€ å‡½æ•°

```python
AudioEngine(
    sample_rate=48000,           # é‡‡æ ·ç‡
    buffer_size=1024,            # ç¼“å†²åŒºå¤§å°
    channels=2,                  # å£°é“æ•°
    max_tracks=32,               # æœ€å¤§è½¨é“æ•°
    device=None,                 # éŸ³é¢‘è®¾å¤‡
    stream_latency='low',        # å»¶è¿Ÿçº§åˆ«
    enable_streaming=True,       # å¯ç”¨æµå¼æ’­æ”¾
    streaming_threshold_mb=100   # æµå¼æ’­æ”¾é˜ˆå€¼
)
```

#### æ ¸å¿ƒæ–¹æ³•

##### éŸ³è½¨ç®¡ç†

```python
# åŸºç¡€åŠ è½½
load_track(track_id, source, speed=1.0, auto_normalize=True, 
          silent_lpadding_ms=0.0, on_complete=None)

# Matcheringä¸“ä¸šåŒ¹é…åŠ è½½
load_track_with_matchering(track_id, file_path, reference_track_id,
                          reference_start_sec, reference_duration_sec=10.0,
                          gentle_matchering=True)

# å¸è½½éŸ³è½¨
unload_track(track_id)

# æ¸…é™¤æ‰€æœ‰éŸ³è½¨
clear_all_tracks()
```

##### æ’­æ”¾æ§åˆ¶

```python
# æ’­æ”¾
play(track_id, fade_in=False, loop=False, seek=None, volume=None)

# å®šæ—¶æ’­æ”¾
play_for_duration(track_id, duration_sec, fade_in=False, fade_out=True)

# åœæ­¢
stop(track_id, fade_out=True, delay_sec=0.0)

# æš‚åœ/æ¢å¤
pause(track_id)
resume(track_id)
```

##### éŸ³é¢‘æ•ˆæœ

```python
# éŸ³é‡æ§åˆ¶
set_volume(track_id, volume)

# é€Ÿåº¦æ§åˆ¶
set_speed(track_id, speed)

# äº¤å‰æ·¡å…¥æ·¡å‡º
crossfade(from_track, to_track, duration=1.0)

# å“åº¦åŒ¹é…
match_loudness(track1_id, track2_id, target_loudness=0.7)
```

##### ä½ç½®å›è°ƒ **[æ–°åŠŸèƒ½]**

```python
# æ³¨å†Œä½ç½®å›è°ƒ
register_position_callback(track_id, target_time, callback_func, tolerance=0.010)

# ç§»é™¤ä½ç½®å›è°ƒ
remove_position_callback(track_id, target_time=None)  # Noneè¡¨ç¤ºç§»é™¤è¯¥è½¨é“æ‰€æœ‰å›è°ƒ

# æ¸…ç©ºæ‰€æœ‰ä½ç½®å›è°ƒ
clear_all_position_callbacks()

# æ·»åŠ å…¨å±€ä½ç½®ç›‘å¬å™¨
add_global_position_listener(listener_func)

# ç§»é™¤å…¨å±€ä½ç½®ç›‘å¬å™¨
remove_global_position_listener(listener_func)

# è·å–å›è°ƒç»Ÿè®¡ä¿¡æ¯
get_position_callback_stats()
```

##### çŠ¶æ€æŸ¥è¯¢

```python
# è·å–è½¨é“ä¿¡æ¯
get_track_info(track_id)

# æ’­æ”¾çŠ¶æ€
is_track_playing(track_id)
is_track_paused(track_id)

# è·å–æ’­æ”¾ä¸­çš„è½¨é“
get_playing_tracks()

# è·å–å½“å‰æ’­æ”¾ä½ç½®
get_position(track_id)

# è·å–è½¨é“æ—¶é•¿
get_duration(track_id)
```

## ğŸ¯ ä½ç½®å›è°ƒè¯¦ç»†æŒ‡å—

### åŸºç¡€æ¦‚å¿µ

ä½ç½®å›è°ƒæœºåˆ¶å…è®¸æ‚¨åœ¨éŸ³é¢‘æ’­æ”¾åˆ°ç‰¹å®šæ—¶é—´ç‚¹æ—¶è§¦å‘å›è°ƒå‡½æ•°ï¼Œå®ç°ç²¾ç¡®çš„éŸ³é¢‘æ“ä½œæ§åˆ¶ã€‚

### æ ¸å¿ƒç‰¹æ€§
- **é«˜ç²¾åº¦**: 5-15msçš„è§¦å‘ç²¾åº¦
- **å¤šè½¨é“æ”¯æŒ**: æ¯ä¸ªè½¨é“å¯ä»¥ç‹¬ç«‹è®¾ç½®å¤šä¸ªå›è°ƒ
- **å®¹å¿åº¦å¯é…ç½®**: å¯è°ƒæ•´è§¦å‘æ—¶é—´å®¹å¿åº¦
- **å…¨å±€ç›‘å¬**: æ”¯æŒå…¨å±€ä½ç½®ç›‘å¬å™¨
- **è‡ªåŠ¨æ¸…ç†**: è§¦å‘åè‡ªåŠ¨æ¸…ç†å›è°ƒï¼Œé˜²æ­¢å†…å­˜æ³„æ¼

### è¯¦ç»†ä½¿ç”¨ç¤ºä¾‹

#### 1. ç²¾ç¡®TTSæ’å…¥

```python
from realtimemix import AudioEngine
import time

engine = AudioEngine()
engine.start()

# åŠ è½½ä¸»éŸ³é¢‘
engine.load_track("podcast", "é•¿ç¯‡éŸ³é¢‘.wav")

# é¢„åŠ è½½TTSéŸ³é¢‘
engine.load_track("tts_correction", "çº æ­£è¯­éŸ³.wav")

def tts_insert_handler(track_id, target_time, actual_time):
    """TTSæ’å…¥å¤„ç†å‡½æ•°"""
    precision_ms = abs(actual_time - target_time) * 1000
    print(f"ğŸ¯ TTSæ’å…¥: ç›®æ ‡{target_time:.3f}s, å®é™…{actual_time:.3f}s, ç²¾åº¦{precision_ms:.1f}ms")
    
    # æ·¡å‡ºä¸»éŸ³é¢‘
    engine.set_volume("podcast", 0.1)
    
    # æ’­æ”¾TTSçº æ­£
    engine.play("tts_correction", volume=0.9)
    
    # ç›‘å¬TTSæ’­æ”¾å®Œæˆ
    tts_duration = engine.get_duration("tts_correction")
    
    def restore_main_audio():
        time.sleep(tts_duration)
        engine.stop("tts_correction")
        engine.set_volume("podcast", 0.8)
    
    import threading
    threading.Thread(target=restore_main_audio, daemon=True).start()

# åœ¨å¥å­ç»“æŸå‰50msæ’å…¥TTSï¼ˆæ¨¡æ‹Ÿæ ‡ç‚¹ç¬¦å·æ£€æµ‹ï¼‰
sentence_end_time = 45.2  # å‡è®¾åœ¨45.2ç§’å¤„æ£€æµ‹åˆ°å¥å·
insert_time = sentence_end_time - 0.05  # æå‰50ms

success = engine.register_position_callback(
    track_id="podcast",
    target_time=insert_time,
    callback_func=tts_insert_handler,
    tolerance=0.015  # 15mså®¹å¿åº¦
)

if success:
    engine.play("podcast")
    print(f"âœ… TTSæ’å…¥å›è°ƒå·²æ³¨å†Œåœ¨ {insert_time:.3f}s")
```

#### 2. ç« èŠ‚æ ‡è®°å’Œè‡ªåŠ¨åˆ‡æ¢

```python
def setup_chapter_markers(engine):
    """è®¾ç½®ç« èŠ‚æ ‡è®°å›è°ƒ"""
    
    chapters = [
        {"time": 120.0, "name": "ç¬¬ä¸€ç« ", "bgm": "chapter1_bgm.wav"},
        {"time": 300.0, "name": "ç¬¬äºŒç« ", "bgm": "chapter2_bgm.wav"},
        {"time": 480.0, "name": "ç¬¬ä¸‰ç« ", "bgm": "chapter3_bgm.wav"}
    ]
    
    def chapter_callback(track_id, target_time, actual_time):
        # æ‰¾åˆ°å¯¹åº”ç« èŠ‚
        current_chapter = None
        for chapter in chapters:
            if abs(chapter["time"] - target_time) < 0.1:
                current_chapter = chapter
                break
        
        if current_chapter:
            print(f"ğŸ“– è¿›å…¥{current_chapter['name']}")
            
            # åˆ‡æ¢èƒŒæ™¯éŸ³ä¹
            engine.load_track("bgm", current_chapter["bgm"])
            engine.play("bgm", volume=0.3, loop=True, fade_in=True)
    
    # æ³¨å†Œæ‰€æœ‰ç« èŠ‚å›è°ƒ
    for chapter in chapters:
        engine.register_position_callback(
            "main_audio", 
            chapter["time"], 
            chapter_callback,
            tolerance=0.020
        )

# ä½¿ç”¨ç¤ºä¾‹
engine.load_track("main_audio", "æœ‰å£°ä¹¦.wav")
setup_chapter_markers(engine)
engine.play("main_audio")
```

#### 3. å®æ—¶å­—å¹•åŒæ­¥

```python
def setup_subtitle_sync(engine, subtitle_data):
    """è®¾ç½®å­—å¹•åŒæ­¥å›è°ƒ"""
    
    def subtitle_callback(track_id, target_time, actual_time):
        # ä»å›è°ƒä¸­è·å–å­—å¹•æ–‡æœ¬ï¼ˆå¯ä»¥é€šè¿‡é—­åŒ…ä¼ é€’ï¼‰
        subtitle_text = getattr(subtitle_callback, 'current_subtitle', '')
        
        if subtitle_text:
            print(f"ğŸ’¬ [{actual_time:.1f}s] {subtitle_text}")
            
            # å‘é€å­—å¹•åˆ°UIï¼ˆç¤ºä¾‹ï¼‰
            # send_subtitle_to_ui(subtitle_text, actual_time)
    
    # ä¸ºæ¯ä¸ªå­—å¹•æ—¶é—´ç‚¹æ³¨å†Œå›è°ƒ
    for subtitle in subtitle_data:
        # åˆ›å»ºå¸¦æœ‰å­—å¹•æ–‡æœ¬çš„å›è°ƒå‡½æ•°
        def make_subtitle_callback(text):
            def callback(track_id, target_time, actual_time):
                print(f"ğŸ’¬ [{actual_time:.1f}s] {text}")
            return callback
        
        engine.register_position_callback(
            "audio_track",
            subtitle["start_time"],
            make_subtitle_callback(subtitle["text"]),
            tolerance=0.008  # 8msç²¾åº¦ç”¨äºå­—å¹•
        )

# å­—å¹•æ•°æ®ç¤ºä¾‹
subtitles = [
    {"start_time": 5.2, "text": "æ¬¢è¿æ”¶å¬ä»Šå¤©çš„èŠ‚ç›®"},
    {"start_time": 8.7, "text": "ä»Šå¤©æˆ‘ä»¬è¦è®¨è®ºçš„è¯é¢˜æ˜¯..."},
    {"start_time": 12.1, "text": "é¦–å…ˆè®©æˆ‘ä»¬æ¥çœ‹çœ‹èƒŒæ™¯"}
]

engine.load_track("audio_track", "èŠ‚ç›®éŸ³é¢‘.wav")
setup_subtitle_sync(engine, subtitles)
engine.play("audio_track")
```

#### 4. åŠ¨æ€éŸ³æ•ˆæ’å…¥

```python
def setup_dynamic_sound_effects(engine):
    """è®¾ç½®åŠ¨æ€éŸ³æ•ˆæ’å…¥"""
    
    # éŸ³æ•ˆé…ç½®
    sound_effects = {
        "applause": {"file": "applause.wav", "volume": 0.6},
        "ding": {"file": "notification.wav", "volume": 0.8},
        "whoosh": {"file": "transition.wav", "volume": 0.5}
    }
    
    def sound_effect_callback(track_id, target_time, actual_time):
        effect_name = getattr(sound_effect_callback, 'effect_name', 'ding')
        effect_config = sound_effects.get(effect_name, sound_effects['ding'])
        
        print(f"ğŸ”Š æ’­æ”¾éŸ³æ•ˆ: {effect_name} at {actual_time:.2f}s")
        
        # åŠ è½½å¹¶æ’­æ”¾éŸ³æ•ˆ
        effect_track_id = f"effect_{int(actual_time * 1000)}"
        engine.load_track(effect_track_id, effect_config["file"])
        engine.play(effect_track_id, volume=effect_config["volume"])
        
        # 5ç§’åè‡ªåŠ¨æ¸…ç†éŸ³æ•ˆè½¨é“
        def cleanup_effect():
            time.sleep(5.0)
            if engine.is_track_loaded(effect_track_id):
                engine.unload_track(effect_track_id)
        
        import threading
        threading.Thread(target=cleanup_effect, daemon=True).start()
    
    # æ³¨å†ŒéŸ³æ•ˆè§¦å‘ç‚¹
    effect_points = [
        {"time": 30.0, "effect": "ding"},      # é‡ç‚¹æé†’
        {"time": 60.0, "effect": "applause"},  # æŒå£°
        {"time": 90.0, "effect": "whoosh"}     # è½¬åœº
    ]
    
    for point in effect_points:
        # åˆ›å»ºæºå¸¦éŸ³æ•ˆåç§°çš„å›è°ƒ
        def make_effect_callback(effect_name):
            def callback(track_id, target_time, actual_time):
                print(f"ğŸ”Š æ’­æ”¾éŸ³æ•ˆ: {effect_name} at {actual_time:.2f}s")
                effect_config = sound_effects[effect_name]
                effect_track_id = f"effect_{int(actual_time * 1000)}"
                engine.load_track(effect_track_id, effect_config["file"])
                engine.play(effect_track_id, volume=effect_config["volume"])
            return callback
        
        engine.register_position_callback(
            "main_track",
            point["time"],
            make_effect_callback(point["effect"]),
            tolerance=0.012
        )

engine.load_track("main_track", "æ¼”è®²éŸ³é¢‘.wav")
setup_dynamic_sound_effects(engine)
engine.play("main_track")
```

#### 5. å…¨å±€ä½ç½®ç›‘å¬å™¨é«˜çº§ç”¨æ³•

```python
class AudioAnalyzer:
    """éŸ³é¢‘æ’­æ”¾åˆ†æå™¨"""
    
    def __init__(self, engine):
        self.engine = engine
        self.position_history = {}
        self.playback_stats = {}
        
        # æ³¨å†Œå…¨å±€ç›‘å¬å™¨
        engine.add_global_position_listener(self.position_listener)
    
    def position_listener(self, track_id: str, position: float):
        """å…¨å±€ä½ç½®ç›‘å¬å™¨"""
        
        # è®°å½•ä½ç½®å†å²
        if track_id not in self.position_history:
            self.position_history[track_id] = []
        
        self.position_history[track_id].append({
            'position': position,
            'timestamp': time.time()
        })
        
        # è®¡ç®—æ’­æ”¾é€Ÿåº¦ï¼ˆå®é™… vs æœŸæœ›ï¼‰
        self._calculate_playback_rate(track_id, position)
        
        # æ£€æµ‹æ’­æ”¾å¼‚å¸¸
        self._detect_playback_issues(track_id, position)
        
        # å®šæœŸè¾“å‡ºç»Ÿè®¡
        if len(self.position_history[track_id]) % 50 == 0:  # æ¯50æ¬¡æ›´æ–°è¾“å‡ºä¸€æ¬¡
            self._print_stats(track_id)
    
    def _calculate_playback_rate(self, track_id: str, position: float):
        """è®¡ç®—å®é™…æ’­æ”¾é€Ÿç‡"""
        history = self.position_history[track_id]
        if len(history) < 2:
            return
        
        current_time = time.time()
        last_record = history[-2]
        
        time_diff = current_time - last_record['timestamp']
        position_diff = position - last_record['position']
        
        if time_diff > 0:
            actual_rate = position_diff / time_diff
            expected_rate = 1.0  # æ­£å¸¸æ’­æ”¾é€Ÿç‡
            
            if track_id not in self.playback_stats:
                self.playback_stats[track_id] = []
            
            self.playback_stats[track_id].append(actual_rate)
    
    def _detect_playback_issues(self, track_id: str, position: float):
        """æ£€æµ‹æ’­æ”¾é—®é¢˜"""
        if track_id not in self.playback_stats or len(self.playback_stats[track_id]) < 5:
            return
        
        recent_rates = self.playback_stats[track_id][-5:]
        avg_rate = sum(recent_rates) / len(recent_rates)
        
        if avg_rate < 0.9:
            print(f"âš ï¸ {track_id}: æ’­æ”¾é€Ÿåº¦æ…¢äºé¢„æœŸ ({avg_rate:.3f}x)")
        elif avg_rate > 1.1:
            print(f"âš ï¸ {track_id}: æ’­æ”¾é€Ÿåº¦å¿«äºé¢„æœŸ ({avg_rate:.3f}x)")
    
    def _print_stats(self, track_id: str):
        """è¾“å‡ºç»Ÿè®¡ä¿¡æ¯"""
        if track_id in self.playback_stats and self.playback_stats[track_id]:
            rates = self.playback_stats[track_id]
            avg_rate = sum(rates) / len(rates)
            print(f"ğŸ“Š {track_id}: å¹³å‡æ’­æ”¾é€Ÿç‡ {avg_rate:.3f}x, é‡‡æ ·ç‚¹æ•° {len(rates)}")

# ä½¿ç”¨åˆ†æå™¨
analyzer = AudioAnalyzer(engine)

engine.load_track("test_audio", "æµ‹è¯•éŸ³é¢‘.wav")
engine.play("test_audio")

# åˆ†æå™¨ä¼šè‡ªåŠ¨ç›‘æ§æ’­æ”¾çŠ¶æ€
time.sleep(30)  # è¿è¡Œ30ç§’è¿›è¡Œåˆ†æ
```

### æ€§èƒ½ä¼˜åŒ–å»ºè®®

1. **åˆç†è®¾ç½®å®¹å¿åº¦**: 
   - TTSæ’å…¥: 10-15ms
   - å­—å¹•åŒæ­¥: 5-10ms
   - éŸ³æ•ˆè§¦å‘: 15-25ms

2. **å›è°ƒå‡½æ•°ä¼˜åŒ–**:
   - é¿å…åœ¨å›è°ƒä¸­æ‰§è¡Œè€—æ—¶æ“ä½œ
   - ä½¿ç”¨å¼‚æ­¥å¤„ç†é‡å¤æ€§ä»»åŠ¡
   - åŠæ—¶æ¸…ç†ä¸´æ—¶èµ„æº

3. **å†…å­˜ç®¡ç†**:
   - å®šæœŸæ¸…ç†å·²è§¦å‘çš„å›è°ƒ
   - é¿å…åœ¨å›è°ƒä¸­åˆ›å»ºå¤§é‡ä¸´æ—¶å¯¹è±¡
   - ä½¿ç”¨å¯¹è±¡æ± ç®¡ç†éŸ³é¢‘èµ„æº

## ğŸ¯ åº”ç”¨åœºæ™¯

### ğŸ™ï¸ è¯­éŸ³å¤„ç†
- **æ’­å®¢åˆ¶ä½œ** - å¤šäººè¯­éŸ³æ··éŸ³ï¼Œæ™ºèƒ½å“åº¦åŒ¹é…
- **æœ‰å£°ä¹¦åˆ¶ä½œ** - ç« èŠ‚é—´æ— ç¼åˆ‡æ¢ï¼ŒèƒŒæ™¯éŸ³ä¹èåˆ
- **é…éŸ³å·¥ç¨‹** - è§’è‰²è¯­éŸ³æ›¿æ¢ï¼ŒéŸ³è´¨è‡ªåŠ¨åŒ¹é…
- **è¯­éŸ³åˆæˆ** - TTSè¯­éŸ³ä¸çœŸäººè¯­éŸ³çš„è‡ªç„¶èåˆ
- **å®æ—¶è¯­éŸ³çº é”™** - åŸºäºä½ç½®å›è°ƒçš„ç²¾ç¡®TTSæ’å…¥ **[æ–°å¢]**
- **æ™ºèƒ½å­—å¹•åŒæ­¥** - æ¯«ç§’çº§ç²¾åº¦çš„å­—å¹•æ—¶é—´è½´å¯¹é½ **[æ–°å¢]**

### ğŸµ éŸ³ä¹åˆ¶ä½œ
- **ç°åœºæ¼”å‡º** - å®æ—¶éŸ³é¢‘æ··éŸ³ï¼Œä½å»¶è¿Ÿç›‘å¬
- **éŸ³ä¹åˆ¶ä½œ** - å¤šè½¨å½•éŸ³ï¼Œä¸“ä¸šéŸ³é¢‘å¤„ç†
- **DJæ··éŸ³** - BPMåŒæ­¥ï¼Œäº¤å‰æ·¡å…¥æ·¡å‡º
- **éŸ³é¢‘æ¯å¸¦å¤„ç†** - Matcheringä¸“ä¸šéŸ³è´¨åŒ¹é…

### ğŸ® æ¸¸æˆå¼€å‘
- **èƒŒæ™¯éŸ³ä¹ç³»ç»Ÿ** - åŠ¨æ€éŸ³ä¹åˆ‡æ¢ï¼Œæƒ…å¢ƒéŸ³æ•ˆ
- **3Dç©ºé—´éŸ³é¢‘** - ä½ç½®éŸ³æ•ˆï¼Œç¯å¢ƒå£°æ¨¡æ‹Ÿ
- **è¯­éŸ³èŠå¤©** - å®æ—¶è¯­éŸ³å¤„ç†ï¼Œé™å™ªä¼˜åŒ–
- **éŸ³æ•ˆå¼•æ“** - å¤šå±‚éŸ³æ•ˆæ··åˆï¼Œæ€§èƒ½ä¼˜åŒ–
- **å‰§æƒ…è§¦å‘å™¨** - åŸºäºæ—¶é—´è½´çš„ç²¾ç¡®äº‹ä»¶è§¦å‘ **[æ–°å¢]**
- **åŠ¨æ€é…ä¹** - æ ¹æ®æ¸¸æˆè¿›åº¦è‡ªåŠ¨è°ƒæ•´èƒŒæ™¯éŸ³ä¹ **[æ–°å¢]**

### ğŸ“º å¤šåª’ä½“åº”ç”¨
- **è§†é¢‘é…éŸ³** - è‡ªåŠ¨éŸ³è§†é¢‘åŒæ­¥ï¼Œå“åº¦æ ‡å‡†åŒ–
- **ç›´æ’­ç³»ç»Ÿ** - å®æ—¶éŸ³é¢‘å¤„ç†ï¼Œå¤šæºæ··éŸ³
- **æ•™è‚²è½¯ä»¶** - äº’åŠ¨éŸ³é¢‘ï¼Œè¯­éŸ³è¯†åˆ«é›†æˆ
- **ä¼šè®®ç³»ç»Ÿ** - å¤šäººè¯­éŸ³å¤„ç†ï¼Œå›å£°æ¶ˆé™¤
- **è‡ªåŠ¨å‰ªè¾‘** - åŸºäºéŸ³é¢‘å†…å®¹çš„æ™ºèƒ½åˆ†æ®µå’Œæ ‡è®° **[æ–°å¢]**
- **äº’åŠ¨åª’ä½“** - ç²¾ç¡®æ—¶é—´æ§åˆ¶çš„äº¤äº’å¼éŸ³é¢‘ä½“éªŒ **[æ–°å¢]**

## ğŸ”§ é«˜çº§é…ç½®

### æ€§èƒ½ä¼˜åŒ–

```python
# ä½å»¶è¿Ÿé…ç½®ï¼ˆä¸“ä¸šéŸ³é¢‘ï¼‰
engine = AudioEngine(
    sample_rate=96000,      # é«˜é‡‡æ ·ç‡
    buffer_size=256,        # æå°ç¼“å†²åŒº
    channels=2,
    stream_latency='low',
    max_tracks=16
)

# å¤§æ–‡ä»¶å¤„ç†é…ç½®
engine = AudioEngine(
    enable_streaming=True,
    streaming_threshold_mb=25,  # æ›´ç§¯æçš„æµå¼æ’­æ”¾
    buffer_size=2048,          # æ›´å¤§ç¼“å†²åŒº
    max_tracks=4               # é™åˆ¶å¹¶å‘æ•°
)

# ç§»åŠ¨è®¾å¤‡ä¼˜åŒ–é…ç½®
engine = AudioEngine(
    sample_rate=44100,     # æ ‡å‡†é‡‡æ ·ç‡
    buffer_size=1024,      # å¹³è¡¡å»¶è¿Ÿå’Œæ€§èƒ½
    channels=2,
    max_tracks=8,          # é™åˆ¶èµ„æºä½¿ç”¨
    stream_latency='medium'
)
```

### Matcheringé«˜çº§è®¾ç½®

```python
# æ¸©å’Œå¤„ç†ï¼ˆæ¨èç”¨äºè¯­éŸ³ï¼‰
engine.load_track_with_matchering(
    track_id="speech",
    file_path="voice.wav", 
    reference_track_id="main",
    reference_start_sec=15.0,
    gentle_matchering=True        # å‡å°‘é‡‘å±éŸ³è‰²
)

# æ ‡å‡†å¤„ç†ï¼ˆç”¨äºéŸ³ä¹ï¼‰
engine.load_track_with_matchering(
    track_id="music",
    file_path="song.wav",
    reference_track_id="main", 
    reference_start_sec=30.0,
    reference_duration_sec=15.0,  # æ›´é•¿å‚è€ƒç‰‡æ®µ
    gentle_matchering=False       # æ ‡å‡†EQå¤„ç†
)
```

## ğŸ“Š æ€§èƒ½ç‰¹å¾

- **å»¶è¿Ÿæ€§èƒ½**: æœ€ä½ ~5msï¼ˆ256å¸§ç¼“å†²åŒº@48kHzï¼‰
- **å†…å­˜æ•ˆç‡**: æµå¼æ’­æ”¾æ”¯æŒGBçº§æ–‡ä»¶ï¼Œå†…å­˜å ç”¨<100MB
- **CPUåˆ©ç”¨ç‡**: å¤šçº¿ç¨‹ä¼˜åŒ–ï¼Œå…¸å‹å ç”¨<10%ï¼ˆ8è½¨æ··éŸ³ï¼‰
- **æ”¯æŒæ ¼å¼**: WAV, FLAC, MP3, M4A, OGGç­‰ï¼ˆé€šè¿‡soundfileï¼‰
- **é‡‡æ ·ç‡èŒƒå›´**: 8kHz - 192kHz
- **ä½æ·±æ”¯æŒ**: 16-bit, 24-bit, 32-bitï¼ˆæ•´æ•°å’Œæµ®ç‚¹ï¼‰

### ğŸ¯ ä½ç½®å›è°ƒæ€§èƒ½
- **å›è°ƒç²¾åº¦**: 5-15msï¼ˆå®æµ‹å¹³å‡ç²¾åº¦6msï¼‰
- **æœ€å¤§å›è°ƒæ•°**: æ”¯æŒ1000+ä¸ªå¹¶å‘ä½ç½®å›è°ƒ
- **æ£€æŸ¥é¢‘ç‡**: åŠ¨æ€è°ƒæ•´ï¼ˆ5msé«˜é¢‘ â†” 50msä½é¢‘ï¼‰
- **å†…å­˜å¼€é”€**: æ¯ä¸ªå›è°ƒçº¦200å­—èŠ‚
- **çº¿ç¨‹å®‰å…¨**: å®Œå…¨çº¿ç¨‹å®‰å…¨çš„å›è°ƒç®¡ç†

## ğŸ› æ•…éšœæ’é™¤

### å¸¸è§é—®é¢˜

**å¯¼å…¥é”™è¯¯**: 
```bash
# ç¡®ä¿å®‰è£…äº†æ‰€æœ‰ä¾èµ–
pip install realtimemix[all]
pip install matchering
```

**éŸ³é¢‘è®¾å¤‡é—®é¢˜**:
```python
# åˆ—å‡ºå¯ç”¨è®¾å¤‡
import sounddevice as sd
print(sd.query_devices())

# æŒ‡å®šè®¾å¤‡
engine = AudioEngine(device=1)  # ä½¿ç”¨è®¾å¤‡1
```

**Matcheringå¤„ç†å¤±è´¥**:
```python
# æ£€æŸ¥éŸ³é¢‘æ–‡ä»¶æ ¼å¼å’Œé•¿åº¦
# ç¡®ä¿å‚è€ƒç‰‡æ®µè‡³å°‘1ç§’ä»¥ä¸Š
# é¿å…ä½¿ç”¨å®Œå…¨é™éŸ³çš„å‚è€ƒç‰‡æ®µ
```

**å†…å­˜ä¸è¶³**:
```python
# å¯ç”¨æµå¼æ’­æ”¾
engine = AudioEngine(
    enable_streaming=True,
    streaming_threshold_mb=50
)
```

**ä½ç½®å›è°ƒé—®é¢˜**:
```python
# å›è°ƒç²¾åº¦ä¸è¶³
engine = AudioEngine(buffer_size=512)  # å‡å°ç¼“å†²åŒºæé«˜ç²¾åº¦

# å›è°ƒä¸è§¦å‘
# æ£€æŸ¥éŸ³è½¨æ˜¯å¦æ­£åœ¨æ’­æ”¾
if engine.is_track_playing("track_id"):
    print("è½¨é“æ­£å¸¸æ’­æ”¾")

# è·å–å›è°ƒç»Ÿè®¡ä¿¡æ¯è¯Šæ–­é—®é¢˜
stats = engine.get_position_callback_stats()
print(f"æ´»è·ƒå›è°ƒ: {stats['active_callbacks']}")
print(f"å¹³å‡ç²¾åº¦: {stats['average_precision_ms']:.1f}ms")

# æ¸…ç†æ‰€æœ‰å›è°ƒé‡æ–°å¼€å§‹
engine.clear_all_position_callbacks()
```

## ğŸ¤ è´¡çŒ®

æ¬¢è¿è´¡çŒ®ä»£ç ï¼è¯·æŸ¥çœ‹[è´¡çŒ®æŒ‡å—](https://github.com/birchkwok/realtimemix/blob/main/CONTRIBUTING.md)ã€‚

### å¼€å‘ç¯å¢ƒè®¾ç½®

```bash
git clone https://github.com/birchkwok/realtimemix.git
cd realtimemix
pip install -e .[dev]
pip install matchering

# è¿è¡Œæµ‹è¯•
pytest tests/ -v

# è¿è¡Œä½ç½®å›è°ƒä¸“é¡¹æµ‹è¯•
pytest tests/test_position_callbacks.py -v

# å¿«é€Ÿä½ç½®å›è°ƒæµ‹è¯•ï¼ˆæ— éŸ³é¢‘æ’­æ”¾ï¼‰
python tests/run_position_callback_tests.py quick

# å›è°ƒç²¾åº¦æµ‹è¯•
python tests/run_position_callback_tests.py precision

# ä»£ç æ ¼å¼åŒ–
black realtimemix/
flake8 realtimemix/
```

## ğŸ“„ è®¸å¯è¯

æœ¬é¡¹ç›®é‡‡ç”¨ [MITè®¸å¯è¯](LICENSE)ã€‚

## ğŸ™ è‡´è°¢

- [sounddevice](https://github.com/spatialaudio/python-sounddevice) - è·¨å¹³å°éŸ³é¢‘I/O
- [soundfile](https://github.com/bastibe/python-soundfile) - éŸ³é¢‘æ–‡ä»¶è¯»å†™
- [librosa](https://github.com/librosa/librosa) - é«˜è´¨é‡éŸ³é¢‘å¤„ç†
- [matchering](https://github.com/sergree/matchering) - ä¸“ä¸šéŸ³é¢‘åŒ¹é…æŠ€æœ¯
- [numpy](https://github.com/numpy/numpy) - é«˜æ€§èƒ½æ•°å€¼è®¡ç®—

---

**RealtimeMix** - è®©éŸ³é¢‘å¤„ç†å˜å¾—ç®€å•è€Œä¸“ä¸š ğŸµ

