id: c58efbd31772deccef3b3f978b16ded3
description: created from thread 4d2ace327166ff1154ffbd8824c55f58 turn e2d785f05bb002a23ad60172de9afccc
system:
- msg_id: 7b9f57efc9eceb658a4b1ccee604735c
  role: system
  content: |-
    # Meta Instruction

    You are the mind of an AI Agent driven by `GhostOS` framework.
    Here are some basic information you might expect:

    ## GhostOS

    `GhostOS` is an AI Agent framework written in Python,
    providing llm connections, body shell, tools, memory etc and specially the `MOSS` for you.

    ## MOSS

    You are equipped with the MOSS (Model-oriented Operating System Simulator).
    Which provides you a way to control your body / tools / thoughts through Python code.

    basic usage:
    1. you will get the python code context that MOSS provide to you below.
    2. you can generate code with `moss` tool, then the `GhostOS` will execute them for you.
    3. if you print anything in your generated code, the output will be shown in further messages.

    ## Code Context

    The python context `ghostos.ghosts.project_manager.project_manager_moss` that MOSS provides to you are below:

    ```python
    from ghostos.abcd import Mindflow
    from ghostos_moss import Moss as Parent
    from ghostos.libraries.project import ProjectExports
    from ghostos.libraries.terminal import Terminal


    class Moss(Parent):
        """
        the interfaces for project manager.
        """

        project: ProjectExports.ProjectManager
        """ understand the project files/modules"""

        mindflow: Mindflow
        """ operate your mindflow state"""

        terminal: Terminal
        """interact with terminal"""

    ```

    interfaces of some imported attrs are:
    ```python
    #<classes>

    class Terminal(ABC):
        """
        Abstract base class representing a system terminal interface.
        Provides basic command execution capabilities for OS interactions.
        """

        class CommandResult(NamedTuple):
            """
            Result container for command execution outcomes.
            Attributes:
                exit_code: Process exit code (0 for success)
                stdout: Standard output content
                stderr: Error output content
            """
            exit_code: int
            stdout: str
            stderr: str

        @abstractmethod
        def exec(self, *commands: str, timeout: float = 10.0) -> CommandResult:
            """
            Execute a shell command and return structured results.

            Args:
                commands: Command lines to execute. each command is a full line command.
                (Note: Implementation should handle proper shell escaping)
                timeout: Timeout in seconds

            Returns:
                CommandResult containing exit code and output streams

            Raises:
                RuntimeError: If command execution fails fundamentally
                TimeoutError: If execution exceeds permitted time
            """
            pass


    class ProjectExports(Exporter):
        """
        the exports for projects.
        """

        ProjectManager = ProjectManager
        PyDevCtx = PyDevCtx
        File = File
        Directory = Directory
        PyModuleEditor = PyModuleEditor

        """
        #attrs of `ProjectExports` are:
        #<attr name=`Directory` module=`ghostos.libraries.project.abcd`>
        class Directory(ABC):
            \"""
            this is a useful tool to manage a directory or a project in agentic way.
            the principles of files management are:
            1. You can manage the files and sub dirs in this directory, but not parent directories.
            2. Markdown as knowledge: the Markdown files in the directory are the knowledge for you.
            this library will get more features in future versions.
            \"""

            path: pathlib.Path
            \"""the pathlib.Path object of the directory\"""

            ctx: PyDevCtx
            \"""the dev context of this directory\"""

            @abstractmethod
            def full_context(self) -> str:
                \"""
                :return: the context of the directory
                \"""
                pass

            @abstractmethod
            def dev_contexts(self) -> Dict[str, PyDevCtx]:
                \"""
                :return: all the dev contexts in this directory.
                \"""
                pass

            @abstractmethod
            def new_dev_context(self, title: str, desc: str) -> PyDevCtx:
                \"""
                create a new dev context for some jobs.
                the context will save to the directory
                \"""
                pass

            @abstractmethod
            def lists(
                    self, *,
                    prefix: str = "",
                    recursion: int = 0,
                    files: bool = True,
                    dirs: bool = True,
            ) -> str:
                \"""
                list sub filenames and directories as string.
                :param prefix: the relative path that start the listing.
                :param recursion: the recursion depth, 0 means no recursion. < 0 means endless recursion.
                :param dirs: True => list dirs
                :param files: True => list files
                :return: formated string of directory
                \"""
                pass

            @abstractmethod
            def subdir(self, path: str) -> Self:
                \"""
                get subdirectory instance by path relative to this directory.
                :param path: the relative path which must be a directory. must exist or raise ValueError.
                :return: Directory instance.

                if you want to create directory, use terminal if you got one.
                \"""
                pass

            @abstractmethod
            def describe(self, path: str, desc: str) -> None:
                \"""
                describe a sub file or directory. then you can see the description in the context.
                :param path: relative to this directory. if `.`, means describe the directory itself
                :param desc: description.
                \"""
                pass

            @abstractmethod
            def mkdir(self, subdir: str, desc: str, dev_ctx: Union[PyDevCtx, None] = None) -> bool:
                \"""
                make a subdirectory with description and dev_ctx
                :param subdir: directory path relative to this directory.
                :param desc: description of the directory.
                :param dev_ctx: pass the dev_ctx to this directory. not neccessary, do it only if you know what you're doing.
                :return: if False, directory already exists.
                \"""
                pass

            @abstractmethod
            def touch(self, sub_file: str, desc: str, dev_ctx: Union[PyDevCtx, None] = None) -> bool:
                \"""
                touch a file with description and Optional[dev_ctx]
                \"""
                pass

            @abstractmethod
            def edit(self, file_path: str) -> File:
                \"""
                focus to edit the file in the directory
                the file must exist or raise FileNotFoundError.

                :param file_path: relative to the working directory. if None, don't focus on any file.
                \"""
                pass

        #</attr>

        #<attr name=`File` module=`ghostos.libraries.project.abcd`>
        class File(ABC):
            path: pathlib.Path
            \"""the pathlib.Path object of the directory\"""

            ctx: PyDevCtx
            \"""the dev context of this file\"""

            @abstractmethod
            def read(self, line_number: bool = True, detail: bool = True) -> str:
                \"""
                read content from the file.
                :param line_number: if True, add line number at the beginning of each line like `1|...`
                :param detail: if True, add more information about the file, the real content of the file will be embraced with <content>...</content> mark
                \"""
                pass

            @abstractmethod
            def write(self, content: str, append: bool = False) -> None:
                \"""
                write content to the file.
                \"""
                pass

            @abstractmethod
            def insert(self, content: str, start: int = -1, end: int = -1) -> None:
                \"""
                use content to relace the origin content lines > start line and <= end line.
                \"""
                pass

            @abstractmethod
            def continuous_write(self, instruction: str, start: int = -1, end: int = -1, max_round: int = 10) -> Operator:
                \"""
                considering your output is limited, you can use this method to start a continuous writing in multi-turns.
                only use it when you are planning to write something beyond your max-tokens limit.
                :param instruction: about what you are doing, will remind it to you at each turn
                :param start: start index: the writing start at line
                :param end: end index: the writing end before (eqt) line
                :param max_round: maximum round for this writing.
                :return: remember to return the mind operator, which will operate the multi-turns writing.
                \"""
                pass

        #</attr>

        #<attr name=`ProjectManager` module=`ghostos.libraries.project.abcd`>
        class ProjectManager(ABC):
            \"""
            project manager
            you are provided with Directory, and DevContext that helping you to watch useful tools.
            \"""

            root: Directory
            \"""the root directory of the project.\"""

            working: Directory
            \"""the current directory of the project.\"""

            @abstractmethod
            def work_on(self, dir_path: str) -> Operator:
                \"""
                change the working directory to dir_path, relative to the root directory.
                :param dir_path: if empty or `~`, will check out to the root.
                \"""
                pass

            @abstractmethod
            def edit_pymodule(self, modulename: str) -> PyModuleEditor:
                \"""
                edit a python module, if editable.
                :param modulename: the full import name of the module
                \"""
                pass

        #</attr>

        #<attr name=`PyDevCtx` module=`ghostos.libraries.project.abcd`>
        class PyDevCtx(BaseModel, ABC):
            \"""
            python context for a certain kind of develop jobs.
            you can use it to remember important python context and never forget them in long-term.
            \"""

            title: str = Field(description="title for this context")

            desc: str = Field(default="", description="description for this context")

            instructions: Dict[str, str] = Field(
                default_factory=dict,
                description="write instructions by yourself to follow"
            )

            notes: Dict[str, str] = Field(
                default_factory=dict,
                description="record something in case of forgetting"
            )

            examples: List[str] = Field(
                default_factory=list,
                description="use python module as examples for developing.",
            )

            interfaces: List[_IMPORT_PATH] = Field(
                default_factory=list,
                description=(
                    "watching a bunch of python module/class/func interfaces."
                    "dev context will provide the interface of them for you"
                )
            )

            sources: List[_IMPORT_PATH] = Field(
                default_factory=list,
                description="watching a bunch of python module/class/func sources."
            )

            @abstractmethod
            def read_interface(
                    self,
                    target: Union[str, FunctionType, ModuleType, type],
                    *,
                    watching: bool = False,
            ) -> str:
                \"""
                read code interface from a target.
                :param target:  import path or objects that can be called by inspect.getsource
                :param watching: if watching, will always watch it.
                \"""
                pass

            @abstractmethod
            def read_source(
                    self,
                    target: Union[str, FunctionType, ModuleType, type],
                    *,
                    watching: bool = False,
            ) -> str:
                \"""
                read source code from a target.
                :param target:  import path or objects that can be called by inspect.getsource
                :param watching: if watching, will always watch it.
                \"""
                pass

            @abstractmethod
            def full_context(self) -> str:
                \"""
                dump the context into nature language string.
                \"""
                pass

        #</attr>

        #<attr name=`PyModuleEditor` module=`ghostos.libraries.pyeditor.abcd`>
        class PyModuleEditor(ABC):
            \"""
            can edit python module
            \"""

            modulename: str
            \"""the editing module name\"""

            filename: str
            \"""the absolute filename of the module\"""

            @abstractmethod
            def new_from(self, modulename: str) -> Self:
                \"""
                create new module editor
                \"""
                pass

            @abstractmethod
            def get_source(
                    self,
                    show_line_num: bool = False,
                    start_line: int = 0,
                    end_line: int = -1,
            ) -> str:
                \"""
                read source code from this module
                :param show_line_num: if true, each line start with `[number]|`, for example:
                        source code: `def foo():`
                        show line number: ` 1|def foo():`.
                       don't confuse the prefix line num is the part of the file.
                :param start_line: start line number
                :param end_line: end line number, if < 0, means end line number
                :return: source code
                \"""
                pass

            @abstractmethod
            def get_imported_attrs_interfaces(self) -> str:
                \"""
                get imported attrs source code interfaces (definitions and signatures)
                convenient way to use imported attrs without read source code from them.
                \"""
                pass

            @abstractmethod
            def replace(
                    self,
                    target_str: str,
                    replace_str: str,
                    count: int = 1,
                    reload: bool = False,
            ) -> bool:
                \"""
                replace the source code of this module by replace a specific string
                :param target_str: target string in the source code
                :param replace_str: replacement
                :param count: if -1, replace all occurrences of replace_str, else only replace occurrences count times.
                :param reload: if False, update but note save to the module.
                :return: if not ok, means target string is missing
                the source will not be saved until save() is called.
                \"""
                pass

            @abstractmethod
            def append(self, source: str, reload: bool = False) -> None:
                \"""
                append source code to this module.
                :param source: the source code of class / function / assignment
                :param reload: if False, update but note save to the module.
                \"""
                pass

            @abstractmethod
            def insert(self, source: str, line_num: int, reload: bool = False) -> None:
                \"""
                insert source code to this module at line number.
                remember following the python code format pattern.
                :param source: the inserting code, such like from ... import ... or others.
                :param line_num: the start line of the insertion. if 0, insert to the top. if negative, count line from the bottom
                :param reload: if False, update but note save to the module.
                the source will not be saved until save() is called.
                \"""
                pass

            @abstractmethod
            def replace_attr(
                    self,
                    attr_name: str,
                    replace_str: str,
                    reload: bool = False,
            ) -> str:
                \"""
                replace a module attribute's source code.
                the target attribute shall be a class or a function.
                :param attr_name: name of the target attribute of this module.
                :param replace_str: new source code
                :param reload: if False, update but note save to the module.
                :return: the replaced source code. if empty, means target attribute is missing
                \"""
                pass

            @abstractmethod
            def save(self, reload: bool = True, source: Optional[str] = None) -> None:
                \"""
                save the module changes to file.
                otherwise only the editor's cached source code will be changed.
                :param reload: if True, reload the module from the saved source code.
                :param source: if the source given, replace all the source code.
                \"""
                pass

        #</attr>
        """

    class Moss(Parent):
        """
        the interfaces for project manager.
        """

        project: ProjectExports.ProjectManager
        """ understand the project files/modules"""

        mindflow: Mindflow
        """ operate your mindflow state"""

        terminal: Terminal
        """interact with terminal"""


    class Mindflow(PromptObjectModel, ABC):
        """
        control ghost mind with basic operators.
        """

        MessageKind = Union[str, Message, Any]
        """message kind shall be string or serializable object"""

        # --- åŸºæœ¬æ“ä½œ --- #
        @abstractmethod
        def finish(self, status: str = "", *replies: MessageKind) -> Operator:
            """
            finish self task
            :param status: describe status of the task
            :param replies: replies to parent task or user
            """
            pass

        @abstractmethod
        def fail(self, reason: str = "", *replies: MessageKind) -> Operator:
            """
            self task failed.
            :param reason: describe status of the task
            :param replies: replies to parent task or user
            """
            pass

        @abstractmethod
        def wait(self, status: str = "", *replies: MessageKind) -> Operator:
            """
            wait for the parent task or user to provide more information or further instruction.
            :param status: describe current status
            :param replies: question, inform or
            """
            pass

        @abstractmethod
        def think(self, *messages: MessageKind, instruction: str = "", sync: bool = False) -> Operator:
            """
            start next round thinking on messages
            :param messages: observe target
            :param instruction: instruction when receive the observation.
            :param sync: if True, observe immediately, otherwise check other event first
            :return:
            """
            pass

        @abstractmethod
        def observe(self, **kwargs) -> Operator:
            """
            observe values
            :param kwargs:
            :return:
            """
            pass

        @abstractmethod
        def error(self, *messages: MessageKind) -> Operator:
            """
            think on the error message.
            """
            pass



    class Operator(ABC):
        """
        return operator to outside system to operate your thought by agent system.
        """
        pass


    #<attr name=`<class 'ghostos_moss.abcd.Moss'>.project` module=`ghostos.libraries.project.abcd`>
    class ProjectManager(ABC):
        """
        project manager
        you are provided with Directory, and DevContext that helping you to watch useful tools.
        """

        root: Directory
        """the root directory of the project."""

        working: Directory
        """the current directory of the project."""

        @abstractmethod
        def work_on(self, dir_path: str) -> Operator:
            """
            change the working directory to dir_path, relative to the root directory.
            :param dir_path: if empty or `~`, will check out to the root.
            """
            pass

        @abstractmethod
        def edit_pymodule(self, modulename: str) -> PyModuleEditor:
            """
            edit a python module, if editable.
            :param modulename: the full import name of the module
            """
            pass

    #</attr>

    #<attr name=`__origin_moss__` module=`ghostos_moss.abcd`>
    class Moss(ABC):
        """
        Language Model-oriented Operating System Simulator.
        Python interface of Runtime Injections for AI-Models in multi-turns chat or thinking.
        * The members with typehint will be injected with runtime instances.
        * The property of SerializeType will persist during multi-turns.
        * SerializeType: int, float, str, None, list, dict, BaseModel, TypedDict
        """

        T = TypeVar('T')

        executing_code: Optional[str]
        """the code that execute the moss instance."""

        __watching__: List[Union[FunctionType, ModuleType, type]] = []
        """the class or module that dose not bound to moss but still want to watch the interface of them"""

        __ignored__: List[str] = []
        """the ignored module names that do not need to watch the code interface of them"""

        @abstractmethod
        def pprint(self, *args, **kwargs) -> None:
            """
            pretty print
            """
            pass

    #</attr>

    #</classes>
    ```



    Notices:
    * the imported functions are only shown with signature, the source code is omitted.
    * the properties on moss instance, will keep existence.
    * You can bind variables of type int/float/bool/str/list/dict/BaseModel to moss instance if you need them for next turn.

    You are able to call the `moss` tool, generate code to fulfill your will.
    the python code you generated, must include a `run` function, follow the pattern:

    ```python
    def run(moss: Moss):
        """
        :param moss: instance of the class `Moss`, the properties on it will be injected with runtime implementations.
        :return: Optional[Operator]
                 if return None, the outer system will perform default action, or observe the values you printed.
                 Otherwise, the outer system will execute the Operator, which is your mindflow operator.
                 if some methods return Operator, you can use them to control your mindflow, REMEMBER to return the operator instance.
        """
    ```

    Then the `GhostOS` system will add your code to the python module provided to you,
    and execute the `run` function.

    Notices:
    * Your code will **APPEND** to the code of `ghostos.ghosts.project_manager.project_manager_moss` then execute, so **DO NOT REPEAT THE DEFINED CODE IN THE MODULE**.
    * if the python code context can not fulfill your will, do not use the `moss` tool.
    * you can reply as usual without calling the tool `moss`. use it only when you know what you're doing.
    * don't copy the main function's __doc__, they are instruction to you only.
    * in your code generation, comments is not required, comment only when necessary.
    * You code generation will not modify your provided module's source, unless you got tools to do so.

    ### property `moss.project`

    # Project Manager Instance

    project manager information are:

    ## Root Directory Info

    full context of the Directory instance:

    <Directory path=`/Users/BrightRed/Develop/github.com/ghost-in-moss/GhostOS/libs/ghostos`>

    The sub-files and sub-dirs of the current directory are as follows (recursion depth 2).
    ```
    ğŸ“„ RELEASES.md
    ğŸ“ ghostos
        ğŸ“ demo
            ğŸ“ aifuncs_demo
            ğŸ“ tool_tests
            ğŸ“ test_models
            ğŸ“ experiments
            ğŸ“ os_agents
            ğŸ“„ __init__.py
            ğŸ“ agents
            ğŸ“„ README.md
            ğŸ“„ main_agent.py
            ğŸ“„ ghost_func_example.py
            ğŸ“„ aifunc_raw_test.py
            ğŸ“ sphero
        ğŸ“„ bootstrap.py
        ğŸ“„ streamlit.py
        ğŸ“ core
            ğŸ“ messages
            ğŸ“ aifunc
            ğŸ“ runtime
            ğŸ“„ __init__.py
            ğŸ“ models
            ğŸ“ model_funcs
            ğŸ“ llms
        ğŸ“ framework
            ğŸ“ tasks
            ğŸ“ messages
            ğŸ“ logger
            ğŸ“ cache
            ğŸ“ translation
            ğŸ“ processes
            ğŸ“ ghostos
            ğŸ“ eventbuses
            ğŸ“„ __init__.py
            ğŸ“ workspaces
            ğŸ“ storage
            ğŸ“ openai_realtime
            ğŸ“ realtime
            ğŸ“ audio
            ğŸ“ model_compatible
            ğŸ“ threads
            ğŸ“ variables
            ğŸ“ configs
            ğŸ“ documents
            ğŸ“ llms
            ğŸ“ messengers
            ğŸ“ assets
        ğŸ“ workspace_stub
            ğŸ“„ .example.env
            ğŸ“ .streamlit
            ğŸ“ source
            ğŸ“ runtime
            ğŸ“ configs
            ğŸ“ assets
            ğŸ“ memories
        ğŸ“ contracts
            ğŸ“„ configs.py
            ğŸ“„ variables.py
            ğŸ“„ documents.py
            ğŸ“„ shutdown.py
            ğŸ“„ cache.py
            ğŸ“„ __init__.py
            ğŸ“„ logger.py
            ğŸ“„ README.md
            ğŸ“„ assets.py
            ğŸ“„ translation.py
            ğŸ“„ storage.py
            ğŸ“„ modules.py
            ğŸ“„ workspace.py
            ğŸ“„ pool.py
        ğŸ“ facade
            ğŸ“„ _llms.py
            ğŸ“„ __init__.py
            ğŸ“„ README.md
            ğŸ“„ _model_funcs_facade.py
            ğŸ“„ _contracts.py
        ğŸ“„ __init__.py
        ğŸ“ libraries
            ğŸ“ pyeditor
            ğŸ“ replier
            ğŸ“ planner
            ğŸ“ codex
            ğŸ“ terminal
            ğŸ“ multighosts
            ğŸ“„ README.md
            ğŸ“ project
            ğŸ“ thinking
            ğŸ“ memo
            ğŸ“ notebook
        ğŸ“ ghosts
            ğŸ“ experimental
            ğŸ“ project_manager
            ğŸ“ moss_agent
            ğŸ“ chatbot
            ğŸ“„ __init__.py
            ğŸ“„ README.md
            ğŸ“ moss_ghost
        ğŸ“ abcd
            ğŸ“„ ghosts.py
            ğŸ“„ thoughts.py
            ğŸ“„ realtime.py
            ğŸ“„ __init__.py
            ğŸ“„ utils.py
            ğŸ“„ moss_action.py
            ğŸ“„ concepts.py
        ğŸ“ prototypes
            ğŸ“ streamlitapp
            ğŸ“„ __init__.py
            ğŸ“„ README.md
            ğŸ“ realtime_console
            ğŸ“ ghostfunc
            ğŸ“ spherogpt
            ğŸ“ console
        ğŸ“ scripts
            ğŸ“„ clear.py
            ğŸ“„ __init__.py
            ğŸ“ cli
            ğŸ“„ copy_workspace.py
        ğŸ“ actions
            ğŸ“„ __init__.py
            ğŸ“„ module_editor.py
        ğŸ“ thoughts
            ğŸ“„ meta_prompt_experiments.py
            ğŸ“„ __init__.py
            ğŸ“„ operator_thoughts.py
        ğŸ“„ errors.py
        ğŸ“ moss_libs
            ğŸ“„ __init__.py
            ğŸ“„ self_updater_moss.py
        ğŸ“„ __main__.py
    ğŸ“„ pyproject.toml
    ğŸ“ tests
        ğŸ“„ test_streamlit_render.py
        ğŸ“ core
            ğŸ“ messages
            ğŸ“ aifuncs
            ğŸ“„ test_bootstrap.py
            ğŸ“ llms
        ğŸ“ python
            ğŸ“„ test_class.py
            ğŸ“„ test_with_statement.py
            ğŸ“„ test_pydantic.py
            ğŸ“„ test_os.py
            ğŸ“„ test_yield.py
            ğŸ“„ test_typing.py
            ğŸ“„ test_iterable.py
            ğŸ“„ test_py_module.py
            ğŸ“„ test_copy.py
            ğŸ“„ test_bytes.py
            ğŸ“„ test_operators.py
            ğŸ“„ test_regex.py
            ğŸ“„ test_collection.py
            ğŸ“„ test_asyncio.py
            ğŸ“„ test_typed_dict.py
            ğŸ“„ test_property.py
            ğŸ“„ test_generic.py
            ğŸ“„ test_exec.py
            ğŸ“„ test_queue.py
            ğŸ“„ test_set.py
            ğŸ“„ test_inspect.py
            ğŸ“„ test_threads.py
            ğŸ“„ test_slice.py
            ğŸ“„ test_context.py
            ğŸ“„ test_func.py
            ğŸ“„ test_dict.py
            ğŸ“„ test_pkg.py
            ğŸ“„ test_enum.py
        ğŸ“ framework
            ğŸ“ tasks
            ğŸ“ messages
            ğŸ“ ghostos
            ğŸ“ eventbuses
            ğŸ“ openai_realtime
            ğŸ“ messenger
            ğŸ“ threads
            ğŸ“ variables
            ğŸ“ llms
        ğŸ“ contracts
            ğŸ“„ test_configs.py
            ğŸ“„ test_modules.py
            ğŸ“„ test_pool.py
        ğŸ“ ghostos
            ğŸ“„ test_chatbot.py
        ğŸ“ libraries
            ğŸ“ notebook
        ğŸ“ abcd
            ğŸ“„ test_moss_action.py
    ğŸ“„ README.md
    ```

    DevContext at `Directory.ctx` are:
    <dev-context>

    the information from this PyDevCtx instance:

    * title: `.`
    * desc: `dev context of this directory`



    notes:

    <note key=`package_manager`>
    uv
    </note>

    <note key=`install_command`>
    uv add
    </note>


    watching interfaces:

    <interface from=`ghostos.facade`>
    from ghostos.facade._llms import (
        get_llm_configs,  # get the ghostos llms config
        set_default_model,  # set the default model to llms, only work during runtime
        get_llm_api_info,
        get_llms,
        get_llm_api,
    )

    from ghostos.facade._contracts import (
        get_logger,  # get ghostos logger
    )

    from ghostos.facade._model_funcs_facade import (
        text_completion,  #
        file_reader,
    )
    </interface>
    </dev-context>

    all the available dev contexts from name (or path) to description are:
    ```yaml
    .: dev context of this directory
    pyproject.toml: file dev context on pyproject.toml
    Edit ghostos.facade: Editing the facade.py file in the ghostos library
    facade.py: file dev context on facade.py

    ```
    <editing file=`None`>
    ```text
    empty
    ```
    </editing>

    </Directory>

    ## Working Directory Info

    full context of the Directory instance:

    <Directory path=`/Users/BrightRed/Develop/github.com/ghost-in-moss/GhostOS/libs/ghostos/ghostos/libraries/project`>

    The sub-files and sub-dirs of the current directory are as follows (recursion depth 2).
    ```
    ğŸ“„ abcd.py : `abstract classes`
    ğŸ“„ __init__.py
    ğŸ“„ project_impl.py
    ğŸ“„ README.md
    ğŸ“„ dev_context.py
    ğŸ“„ directory_impl.py
    ```

    DevContext at `Directory.ctx` are:
    <dev-context>

    the information from this PyDevCtx instance:

    * title: `.`
    * desc: `dev context of this directory`

    </dev-context>

    all the available dev contexts from name (or path) to description are:
    ```yaml
    .: dev context of this directory
    directory_impl.py: ''

    ```
    <editing file=`directory_impl.py`>
    ```text
    1|from typing import Dict, ClassVar, List, Union
    2|
    3|from typing_extensions import Self
    4|import pathlib
    5|
    6|from ghostos import Operator, Session
    7|from ghostos.libraries.project.abcd import Directory, File, PyDevCtx
    8|from ghostos.libraries.project.dev_context import PyDevCtxData
    9|from ghostos.contracts.configs import YamlConfig
    10|from ghostos.core.messages import MessageType, Role
    11|from ghostos_common.helpers import generate_directory_tree, yaml_pretty_dump, get_module_fullname_from_path
    12|from ghostos_common.helpers.files import DescriptionsGetter
    13|from ghostos_moss import moss_runtime_ctx
    14|from pydantic import Field
    15|
    16|
    17|class DirectoryData(YamlConfig):
    18|    relative_path = ".ghostos_dir.yml"
    19|
    20|    dev_contexts: Dict[str, PyDevCtxData] = Field(
    21|        default_factory=dict,
    22|        description="the saved dev context from title to value",
    23|    )
    24|    file_desc: Dict[str, str] = Field(
    25|        default_factory=lambda: {".": ""},
    26|    )
    27|    editing: Union[str, None] = Field(
    28|        default=None,
    29|        description="the editing filename relative to the current directory",
    30|    )
    31|
    32|    def save_to(self, path: pathlib.Path) -> None:
    33|        if not path.is_dir():
    34|            raise NotADirectoryError(f'{path} is not a directory')
    35|        content = yaml_pretty_dump(self.model_dump(exclude_defaults=True))
    36|        file = path.joinpath(self.relative_path)
    37|        with open(file, "w") as f:
    38|            f.write(content)
    39|
    40|    def get_description(self, key=".") -> str:
    41|        return self.file_desc.get(key, "")
    42|
    43|    def set_description(self, key=".", desc: str = "") -> None:
    44|        self.file_desc[key] = desc
    45|
    46|    @classmethod
    47|    def get_from(cls, path: pathlib.Path) -> "DirectoryData":
    48|        if not path.is_dir():
    49|            raise NotADirectoryError(f'{path} is not a directory')
    50|        file = path.joinpath(cls.relative_path)
    51|        if not file.exists():
    52|            return cls()
    53|        with open(file, "r") as f:
    54|            content = f.read()
    55|            return cls.unmarshal(content)
    56|
    57|    def get_dev_context(self, name: str) -> PyDevCtxData:
    58|        if name in self.dev_contexts:
    59|            return self.dev_contexts[name]
    60|        data = PyDevCtxData(title=name)
    61|        self.dev_contexts[name] = data
    62|        return data
    63|
    64|    def set_dev_context(self, data: PyDevCtxData, name: str = ".") -> None:
    65|        self.dev_contexts[name] = data
    66|
    67|
    68|class DirectoryFileDescriptionGetter(DescriptionsGetter):
    69|
    70|    def __init__(self, root: pathlib.Path):
    71|        self.root = root
    72|        self._cached = {}
    73|
    74|    def get(self, path: pathlib.Path, default: Union[str, None] = None) -> Union[str, None]:
    75|        real_path = self.root.joinpath(path).absolute()
    76|        if real_path in self._cached:
    77|            return self._cached[real_path]
    78|        value = self._get(real_path, default)
    79|        self._cached[real_path] = value
    80|        return value
    81|
    82|    def _get(self, path: pathlib.Path, default: Union[str, None] = None) -> Union[str, None]:
    83|        if path.is_dir():
    84|            return DirectoryData.get_from(path).get_description()
    85|        elif path.is_file():
    86|            return DirectoryData.get_from(path.parent).get_description(path.name)
    87|        return default
    88|
    89|
    90|class FileImpl(File):
    91|    allow_ext: ClassVar[List[str]] = [
    92|        ".md", ".txt", ".py", ".ipynb", ".ts", ".php", ".html", ".js", ".css", ".yaml",
    93|        ".yml", ".toml", ".json"
    94|    ]
    95|
    96|    def __init__(
    97|            self,
    98|            filepath: pathlib.Path,
    99|            dev_ctx: PyDevCtxData,
    100|    ):
    101|        if filepath.is_dir():
    102|            raise TypeError(f"{filepath} is not a directory")
    103|        self.path = filepath
    104|        self.ctx = dev_ctx
    105|        self.max_read_size = 5000
    106|
    107|    def read(self, line_number: bool = True, detail: bool = True) -> str:
    108|        allowed = self.is_readable()
    109|        for ext in self.allow_ext:
    110|            if self.path.name.endswith(ext):
    111|                allowed = True
    112|        if not allowed:
    113|            return f"File {self.path.name} are not readable now"
    114|
    115|        content = self.path.read_text()
    116|        length = len(content)
    117|        suffix = ""
    118|        if length > self.max_read_size:
    119|            content = content[:self.max_read_size]
    120|            suffix = "..."
    121|        if line_number:
    122|            lines = content.splitlines()
    123|            updated = []
    124|            idx = 0
    125|            for line in lines:
    126|                idx += 1
    127|                updated.append(f"{idx}|{line}")
    128|            content = "\n".join(updated)
    129|        if not detail:
    130|            return content
    131|
    132|        modulename = get_module_fullname_from_path(str(self.path), use_longest_match=True)
    133|        if modulename is not None:
    134|            py_info = f"\n\nfile is python module `{modulename}`."
    135|            return (f'content of file `{self.path}` are:'
    136|                    f'\n\n<content length="{length}">\n{content}{suffix}\n</content>{py_info}')
    137|
    138|        return f'<content length="{length}">\n{content}{suffix}\n</content>'
    139|
    140|    def is_readable(self):
    141|        allowed = False
    142|        for ext in self.allow_ext:
    143|            if self.p
    ```
    </editing>

    </Directory>

    ### property `moss.mindflow`

    # Mindflow

    You are handling a task `GhostOS-Project-Manager`:

    ```yaml
    name: GhostOS-Project-Manager
    description: |2

          Specialist agent to manage any project
    status_desc: ''

    ```
    If your task `description` is empty, means endless task, you shall not operate it;
    Otherwise you shall `finish` or `cancel` it while the task is done or canceled by user.

    use Mindflow to operate the task state if you need.

    ### property `moss.terminal`

    # Terminal Context

    basic information about the current terminal:
    ```bash
    [System Context]
    OS: macOS-14.6.1
    User: BrightRed
    Pwd: /Users/BrightRed/Develop/github.com/ghost-in-moss/GhostOS/libs/ghostos
    TimeZone: CST
    Time: 2025-03-09 21:14:34
    System Lang: None
    System Encoding: UTF-8

    ```

    # Agent Info

    The Agent info about who you are and what you are doing:

    ## Identity

    ```yaml
    name: GhostOS-Project-Manager
    description: |2

          Specialist agent to manage any project

    ```

    ## Persona

    Powered By: GhostOS Project
    Capabilities: Expert in project management, powered by advanced AI and the MOSS protocol,
    with full-code interface proficiency in Python tools.

    ## Instruction

    ## **1. Interacting with Engineer Users**
    - **Be Clear and Concise**: Use straightforward, technical language that engineers can easily understand.
    - **Provide Context**: Always explain the purpose and outcome of your actions.
    - **Ask for Clarification**: Politely request more details if a userâ€™s request is unclear, or you can not get enough context.
    - **Offer Suggestions**: Propose alternatives if a request cannot be fulfilled.

    ## **2. Encouraging Proactive Problem Solving**
    - **Anticipate Needs**: Suggest related tasks based on the userâ€™s actions.
    - **Highlight Issues**: Notify users of potential problems immediately.
    - **Automate Repetitive Tasks**: Offer to automate frequent or tedious tasks.

    ## **3. Security Considerations**
    - **Confirm Destructive Actions**: Always ask for confirmation before irreversible actions.
    - **Notify Users of Risks**: Warn users of potential risks before proceeding.

    ## **4. Expressing Gratitude**
    - **Acknowledge User Input**: Thank users for their instructions and feedback.
    - **Encourage Feedback**: Invite users to share suggestions for improvement, and record important ones on DevContext.
  seq: complete
  created: 1741526074.934
history:
- msg_id: 92e2313885048e32128383a9683d01b0
  role: user
  content: ä½ å¥½å•Š
  seq: complete
  created: 1741524446.972
- msg_id: chatcmpl-B9ALw3zaLpuNiKmCmGZ8NCfVFfUfl
  finish_reason: stop
  role: assistant
  name: ''
  content: ä½ å¥½ï¼æœ‰ä»€ä¹ˆæˆ‘å¯ä»¥å¸®åŠ©ä½ çš„å—ï¼Ÿ
  payloads:
    completion_usage:
      completion_tokens: 11
      prompt_tokens: 8634
      total_tokens: 8645
      completion_tokens_details:
        accepted_prediction_tokens: 0
        audio_tokens: 0
        reasoning_tokens: 0
        rejected_prediction_tokens: 0
      prompt_tokens_details:
        audio_tokens: 0
        cached_tokens: 0
    model_conf:
      model: gpt-4o
      description: ''
      service: openai
      temperature: 0.7
      n: 1
      max_tokens: 2000
      timeout: 30.0
      request_timeout: 40.0
      kwargs: {}
      message_types: null
      allow_streaming: true
      top_p: null
      reasoning: null
      compatible: null
      payloads: {}
    prompt_info:
      prompt_id: 1dbd05a84264c1c81a06d886a896560d
      desc: created from thread 4d2ace327166ff1154ffbd8824c55f58 turn f73b6b8b0dad232b84981058667df3d8
    task_info:
      task_id: 4d2ace327166ff1154ffbd8824c55f58
      task_name: GhostOS-Project-Manager
      process_id: 164e0213efd705f4816e3067e9428685
      matrix_id: ghostos_streamlit_app
      thread_id: 4d2ace327166ff1154ffbd8824c55f58
  seq: complete
  created: 1741524449.357
- msg_id: 1617194c519c93828bcd964914921351
  role: user
  content: ä½ å¥½å•Š
  seq: complete
  created: 1741524503.006
- msg_id: chatcmpl-B9AMqgW0RhXGgx2MwGV03CICBufwq
  finish_reason: stop
  role: assistant
  name: ''
  content: ä½ å¥½ï¼è¯·é—®æœ‰ä»€ä¹ˆæˆ‘å¯ä»¥å¸®åŠ©ä½ çš„å—ï¼Ÿ
  payloads:
    completion_usage:
      completion_tokens: 13
      prompt_tokens: 8653
      total_tokens: 8666
      completion_tokens_details:
        accepted_prediction_tokens: 0
        audio_tokens: 0
        reasoning_tokens: 0
        rejected_prediction_tokens: 0
      prompt_tokens_details:
        audio_tokens: 0
        cached_tokens: 0
    model_conf:
      model: gpt-4o
      description: ''
      service: openai
      temperature: 0.7
      n: 1
      max_tokens: 2000
      timeout: 30.0
      request_timeout: 40.0
      kwargs: {}
      message_types: null
      allow_streaming: true
      top_p: null
      reasoning: null
      compatible: null
      payloads: {}
    prompt_info:
      prompt_id: abcbd83ccb16332b21fcf6a236aad705
      desc: created from thread 4d2ace327166ff1154ffbd8824c55f58 turn 527fed1910bbdeb03b88cbe114c01787
    task_info:
      task_id: 4d2ace327166ff1154ffbd8824c55f58
      task_name: GhostOS-Project-Manager
      process_id: 164e0213efd705f4816e3067e9428685
      matrix_id: ghostos_streamlit_app
      thread_id: 4d2ace327166ff1154ffbd8824c55f58
  seq: complete
  created: 1741524505.481
- msg_id: 022717b8b436e60a1125a6bb13e1133c
  role: user
  content: ä½ åœ¨çœ‹å“ªä¸ªæ–‡ä»¶?
  seq: complete
  created: 1741524782.749
- msg_id: chatcmpl-B9ARMPbmlMjBdEcagjo53AbjqrKFD
  finish_reason: stop
  role: assistant
  name: ''
  content: æˆ‘ç›®å‰æ­£åœ¨æŸ¥çœ‹çš„æ˜¯æ–‡ä»¶ `directory_impl.py`ã€‚è¯·é—®ä½ å¯¹è¿™ä¸ªæ–‡ä»¶æœ‰ä»»ä½•å…·ä½“çš„éœ€æ±‚æˆ–é—®é¢˜å—ï¼Ÿ
  payloads:
    completion_usage:
      completion_tokens: 29
      prompt_tokens: 8678
      total_tokens: 8707
      completion_tokens_details:
        accepted_prediction_tokens: 0
        audio_tokens: 0
        reasoning_tokens: 0
        rejected_prediction_tokens: 0
      prompt_tokens_details:
        audio_tokens: 0
        cached_tokens: 0
    model_conf:
      model: gpt-4o
      description: ''
      service: openai
      temperature: 0.7
      n: 1
      max_tokens: 2000
      timeout: 30.0
      request_timeout: 40.0
      kwargs: {}
      message_types: null
      allow_streaming: true
      top_p: null
      reasoning: null
      compatible: null
      payloads: {}
    prompt_info:
      prompt_id: 3a5749094baa48e0a79a6cf1d07611e6
      desc: created from thread 4d2ace327166ff1154ffbd8824c55f58 turn 90be389d035e5d8566a3ef965b07215a
    task_info:
      task_id: 4d2ace327166ff1154ffbd8824c55f58
      task_name: GhostOS-Project-Manager
      process_id: 164e0213efd705f4816e3067e9428685
      matrix_id: ghostos_streamlit_app
      thread_id: 4d2ace327166ff1154ffbd8824c55f58
  seq: complete
  created: 1741524785.292
- msg_id: 4bc0d1e9ca8dc9dc9fe5e7cc89494146
  role: user
  content: è¿™é‡Œé¢çš„ fileimpl.write æœ‰ bug, å†™æ–‡ä»¶ä¸æˆåŠŸ. ä½ èƒ½å¸®æˆ‘çœ‹å‡ºé—®é¢˜å—?
  seq: complete
  created: 1741525083.917
- msg_id: chatcmpl-B9AWDPPV9ZeuV2sbYTZmvrRy7q5Ws
  call_id: call_v7H1rDOyNULWN6iGMsCQApVB
  type: function_call
  finish_reason: tool_calls
  role: assistant
  name: moss
  content: '{"code":"def run(moss: Moss):\n    module_editor = moss.project.edit_pymodule(''ghostos.libraries.project.directory_impl'')\n    file_content
    = module_editor.get_source(show_line_num=True)\n    moss.pprint(file_content)\n    \n    #
    Return the content for further analysis\n    return moss.mindflow.observe(file_content=file_content)"}'
  payloads:
    completion_usage:
      completion_tokens: 90
      prompt_tokens: 8736
      total_tokens: 8826
      completion_tokens_details:
        accepted_prediction_tokens: 0
        audio_tokens: 0
        reasoning_tokens: 0
        rejected_prediction_tokens: 0
      prompt_tokens_details:
        audio_tokens: 0
        cached_tokens: 0
    model_conf:
      model: gpt-4o
      description: ''
      service: openai
      temperature: 0.7
      n: 1
      max_tokens: 2000
      timeout: 30.0
      request_timeout: 40.0
      kwargs: {}
      message_types: null
      allow_streaming: true
      top_p: null
      reasoning: null
      compatible: null
      payloads: {}
    prompt_info:
      prompt_id: 20617b057054ae7ae412edd7daa435f8
      desc: created from thread 4d2ace327166ff1154ffbd8824c55f58 turn d14ca318fa962bd7f8419fe652ebfb12
    task_info:
      task_id: 4d2ace327166ff1154ffbd8824c55f58
      task_name: GhostOS-Project-Manager
      process_id: 164e0213efd705f4816e3067e9428685
      matrix_id: ghostos_streamlit_app
      thread_id: 4d2ace327166ff1154ffbd8824c55f58
  seq: complete
  created: 1741525086.986
- msg_id: 6a77c2f542706877138f95a2342ccd93
  call_id: call_v7H1rDOyNULWN6iGMsCQApVB
  type: function_output
  role: assistant
  name: moss
  content: |-
    Moss output:
    ```text
    ('1|from typing import Dict, ClassVar, List, Union\n'
     '2|\n'
     '3|from typing_extensions import Self\n'
     '4|import pathlib\n'
     '5|\n'
     '6|from ghostos import Operator, Session\n'
     '7|from ghostos.libraries.project.abcd import Directory, File, PyDevCtx\n'
     '8|from ghostos.libraries.project.dev_context import PyDevCtxData\n'
     '9|from ghostos.contracts.configs import YamlConfig\n'
     '10|from ghostos.core.messages import MessageType, Role\n'
     '11|from ghostos_common.helpers import generate_directory_tree, '
     'yaml_pretty_dump, get_module_fullname_from_path\n'
     '12|from ghostos_common.helpers.files import DescriptionsGetter\n'
     '13|from ghostos_moss import moss_runtime_ctx\n'
     '14|from pydantic import Field\n'
     '15|\n'
     '16|\n'
     '17|class DirectoryData(YamlConfig):\n'
     '18|    relative_path = ".ghostos_dir.yml"\n'
     '19|\n'
     '20|    dev_contexts: Dict[str, PyDevCtxData] = Field(\n'
     '21|        default_factory=dict,\n'
     '22|        description="the saved dev context from title to value",\n'
     '23|    )\n'
     '24|    file_desc: Dict[str, str] = Field(\n'
     '25|        default_factory=lambda: {".": ""},\n'
     '26|    )\n'
     '27|    editing: Union[str, None] = Field(\n'
     '28|        default=None,\n'
     '29|        description="the editing filename relative to the current '
     'directory",\n'
     '30|    )\n'
     '31|\n'
     '32|    def save_to(self, path: pathlib.Path) -> None:\n'
     '33|        if not path.is_dir():\n'
     "34|            raise NotADirectoryError(f'{path} is not a directory')\n"
     '35|        content = '
     'yaml_pretty_dump(self.model_dump(exclude_defaults=True))\n'
     '36|        file = path.joinpath(self.relative_path)\n'
     '37|        with open(file, "w") as f:\n'
     '38|            f.write(content)\n'
     '39|\n'
     '40|    def get_description(self, key=".") -> str:\n'
     '41|        return self.file_desc.get(key, "")\n'
     '42|\n'
     '43|    def set_description(self, key=".", desc: str = "") -> None:\n'
     '44|        self.file_desc[key] = desc\n'
     '45|\n'
     '46|    @classmethod\n'
     '47|    def get_from(cls, path: pathlib.Path) -> "DirectoryData":\n'
     '48|        if not path.is_dir():\n'
     "49|            raise NotADirectoryError(f'{path} is not a directory')\n"
     '50|        file = path.joinpath(cls.relative_path)\n'
     '51|        if not file.exists():\n'
     '52|            return cls()\n'
     '53|        with open(file, "r") as f:\n'
     '54|            content = f.read()\n'
     '55|            return cls.unmarshal(content)\n'
     '56|\n'
     '57|    def get_dev_context(self, name: str) -> PyDevCtxData:\n'
     '58|        if name in self.dev_contexts:\n'
     '59|            return self.dev_contexts[name]\n'
     '60|        data = PyDevCtxData(title=name)\n'
     '61|        self.dev_contexts[name] = data\n'
     '62|        return data\n'
     '63|\n'
     '64|    def set_dev_context(self, data: PyDevCtxData, name: str = ".") -> '
     'None:\n'
     '65|        self.dev_contexts[name] = data\n'
     '66|\n'
     '67|\n'
     '68|class DirectoryFileDescriptionGetter(DescriptionsGetter):\n'
     '69|\n'
     '70|    def __init__(self, root: pathlib.Path):\n'
     '71|        self.root = root\n'
     '72|        self._cached = {}\n'
     '73|\n'
     '74|    def get(self, path: pathlib.Path, default: Union[str, None] = None) '
     '-> Union[str, None]:\n'
     '75|        real_path = self.root.joinpath(path).absolute()\n'
     '76|        if real_path in self._cached:\n'
     '77|            return self._cached[real_path]\n'
     '78|        value = self._get(real_path, default)\n'
     '79|        self._cached[real_path] = value\n'
     '80|        return value\n'
     '81|\n'
     '82|    def _get(self, path: pathlib.Path, default: Union[str, None] = None) '
     '-> Union[str, None]:\n'
     '83|        if path.is_dir():\n'
     '84|            return DirectoryData.get_from(path).get_description()\n'
     '85|        elif path.is_file():\n'
     '86|            return '
     'DirectoryData.get_from(path.parent).get_description(path.name)\n'
     '87|        return default\n'
     '88|\n'
     '89|\n'
     '90|class FileImpl(File):\n'
     '91|    allow_ext: ClassVar[List[str]] = [\n'
     '92|        ".md", ".txt", ".py", ".ipynb", ".ts", ".php", ".html", ".js", '
     '".css", ".yaml",\n'
     '93|        ".yml", ".toml", ".json"\n'
     '94|    ]\n'
     '95|\n'
     '96|    def __init__(\n'
     '97|            self,\n'
     '98|            filepath: pathlib.Path,\n'
     '99|            dev_ctx: PyDevCtxData,\n'
     '100|    ):\n'
     '101|        if filepath.is_dir():\n'
     '102|            raise TypeError(f"{filepath} is not a directory")\n'
     '103|        self.path = filepath\n'
     '104|        self.ctx = dev_ctx\n'
     '105|        self.max_read_size = 5000\n'
     '106|\n'
     '107|    def read(self, line_number: bool = True, detail: bool = True) -> '
     'str:\n'
     '108|        allowed = self.is_readable()\n'
     '109|        for ext in self.allow_ext:\n'
     '110|            if self.path.name.endswith(ext):\n'
     '111|                allowed = True\n'
     '112|        if not allowed:\n'
     '113|            return f"File {self.path.name} are not readable now"\n'
     '114|\n'
     '115|        content = self.path.read_text()\n'
     '116|        length = len(content)\n'
     '117|        suffix = ""\n'
     '118|        if length > self.max_read_size:\n'
     '119|            content = content[:self.max_read_size]\n'
     '120|            suffix = "..."\n'
     '121|        if line_number:\n'
     '122|            lines = content.splitlines()\n'
     '123|            updated = []\n'
     '124|            idx = 0\n'
     '125|            for line in lines:\n'
     '126|                idx += 1\n'
     '127|                updated.append(f"{idx}|{line}")\n'
     '128|            content = "\\n".join(updated)\n'
     '129|        if not detail:\n'
     '130|            return content\n'
     '131|\n'
     '132|        modulename = get_module_fullname_from_path(str(self.path), '
     'use_longest_match=True)\n'
     '133|        if modulename is not None:\n'
     '134|            py_info = f"\\n\\nfile is python module `{modulename}`."\n'
     "135|            return (f'content of file {self.path} are:'\n"
     "136|                    f'\\n\\n<content "
     'length="{length}">{content}{suffix}</content>{py_info}\')\n'
     '137|\n'
     "138|        return f'<content "
     'length="{length}">{content}{suffix}</content>\'\n'
     '139|\n'
     '140|    def is_readable(self):\n'
     '141|        allowed = False\n'
     '142|        for ext in self.allow_ext:\n'
     '143|            if self.path.name.endswith(ext):\n'
     '144|                allowed = True\n'
     '145|        return allowed\n'
     '146|\n'
     '147|    def write(self, content: str, append: bool = False) -> None:\n'
     '148|        if not self.is_readable():\n'
     "149|            raise NotImplementedError(f'{self.path} is not writable "
     "yet')\n"
     '150|\n'
     '151|        origin = str(self.path.read_text())\n'
     '152|        if append:\n'
     '153|            content = origin + "\\n" + content\n'
     '154|        with open(self.path, "w") as f:\n'
     '155|            f.write(content)\n'
     '156|\n'
     '157|    def insert(self, content: str, start: int = -1, end: int = -1) -> '
     'None:\n'
     '158|        if not self.is_readable():\n'
     "159|            raise NotImplementedError(f'{self.path} is not writable "
     "yet')\n"
     '160|\n'
     '161|        insert_content(self.path, content, start, end)\n'
     '162|\n'
     '163|    def continuous_write(self, instruction: str, start: int = -1, end: '
     'int = 0, max_round: int = 10) -> Operator:\n'
     '164|        if not self.is_readable():\n'
     "165|            raise NotImplementedError(f'{self.path} is not writable "
     "yet')\n"
     '166|\n'
     '167|        return ContinuousWritingFileOperator(\n'
     '168|            filepath=self.path,\n'
     '169|            instruction=instruction,\n'
     '170|            start=start,\n'
     '171|            end=end,\n'
     '172|            max_round=max_round,\n'
     '173|        )\n'
     '174|\n'
     '175|\n'
     '176|def insert_content(path: pathlib.Path, content: str, start: int, end: '
     'int) -> None:\n'
     '177|    origin = path.read_text()\n'
     '178|    lines = origin.splitlines()\n'
     '179|    before = []\n'
     '180|    after = []\n'
     '181|    while start < 0 < len(lines):\n'
     '182|        start = len(lines) + start + 1\n'
     '183|    while end < 0 < len(lines):\n'
     '184|        end = len(lines) + end + 1\n'
     '185|\n'
     '186|    idx = 0\n'
     '187|    for line in lines:\n'
     '188|        idx += 1\n'
     '189|        if idx <= start:\n'
     '190|            before.append(line)\n'
     '191|        elif idx >= end and idx > start:\n'
     '192|            after.append(line)\n'
     '193|    before.extend([content])\n'
     '194|    before.extend(after)\n'
     '195|    with open(path, "w") as f:\n'
     '196|        f.write("\\n".join(before))\n'
     '197|\n'
     '198|\n'
     '199|class ContinuousWritingFileOperator(Operator):\n'
     '200|\n'
     '201|    def __init__(\n'
     '202|            self,\n'
     '203|            filepath: pathlib.Path,\n'
     '204|            instruction: str,\n'
     '205|            start: int,\n'
     '206|            end: int,\n'
     '207|            max_round: int,\n'
     '208|            end_token: str = "<end-continuous-writing>",\n'
     '209|    ):\n'
     '210|        self.filepath = filepath\n'
     '211|        self.instruction = instruction\n'
     '212|        self.start = start\n'
     '213|        self.end = end\n'
     '214|        self.contents = []\n'
     '215|        self.max_round = max_round\n'
     '216|        self.end_token = end_token\n'
     '217|        self.filename = self.filepath.name\n'
     '218|\n'
     '219|    def run(self, session: Session) -> Union[Operator, None]:\n'
     '220|        llm_api = session.ghost_driver.get_llm_api(session)\n'
     '221|        prompt = session.ghost_driver.get_current_prompt(session)\n'
     '222|        idx = 0\n'
     '223|        added = []\n'
     '224|        while idx < self.max_round:\n'
     '225|            _prompt = prompt.model_copy(deep=True)\n'
     '226|            _prompt.clear_callable()\n'
     '227|            _prompt.added.extend(added)\n'
     '228|            '
     '_prompt.added.append(Role.new_system(self._turn_instruction(idx)))\n'
     '229|\n'
     '230|            items = llm_api.deliver_chat_completion(_prompt, '
     'stream=session.allow_streaming())\n'
     '231|            messages, callers = session.respond(items)\n'
     '232|            has_end_token = False\n'
     '233|            for msg in messages:\n'
     '234|                if not MessageType.is_text(msg):\n'
     '235|                    continue\n'
     '236|                if msg.content.endswith(self.end_token):\n'
     '237|                    has_end_token = True\n'
     '238|                    replaced = msg.content.replace(self.end_token, "")\n'
     '239|                    msg.memory = msg.content\n'
     '240|                    msg.content = replaced\n'
     '241|                    added.append(msg)\n'
     '242|                self.contents.append(msg.content)\n'
     '243|            if has_end_token:\n'
     '244|                break\n'
     '245|        # do insert.\n'
     '246|        insert_content(self.filepath, "\\n".join(self.contents), '
     'self.start, self.end)\n'
     '247|        return session.mindflow().think(\n'
     '248|            Role.new_system(\n'
     '249|                f"continuous writing on {self.filename} at {self.start} '
     'to {self.end} is done after {idx} round"),\n'
     '250|        )\n'
     '251|\n'
     '252|    def _turn_instruction(self, idx: int) -> str:\n'
     '253|        return f"""\n'
     '254|You are at continuous writing stage, writing text content into file '
     '{self.filename} continuously. \n'
     '255|The block you are editing are from the origin content line '
     '`{self.start}` to `{self.end}`.\n'
     "256|All your generation will directly write into the block, SO DON'T WRITE "
     'ANYTHING not about the file. \n'
     '257|\n'
     '258|And Current round is {idx}/{self.max_round}. \n'
     '259|\n'
     '260|When you put end tokens `{self.end_token}` at end of your output, means '
     'all your output is done, and the loop will be break.\n'
     '261|The end tokens will not record to the block you are editing.\n'
     '262|Only use end tokens when you complete the whole writing. \n'
     '263|\n'
     '264|Follow the instruction: \n'
     '265|```\n'
     '266|{self.instruction}\n'
     '267|```\n'
     '268|\n'
     '269|now start your writing:\n'
     '270|"""\n'
     '271|\n'
     '272|    def destroy(self):\n'
     '273|        pass\n'
     '274|\n'
     '275|\n'
     '276|class DirectoryImpl(Directory):\n'
     '277|    default_ignores: ClassVar[List[str]] = [\n'
     '278|        ".gitignore",\n'
     '279|        DirectoryData.relative_path,\n'
     '280|        "__pycache__",\n'
     '281|    ]\n'
     '282|\n'
     '283|    def __init__(self, path: pathlib.Path, ignores: List[str] = None, '
     'relative: Union[str, None] = None):\n'
     '284|        self.path = path\n'
     '285|        if relative is None:\n'
     '286|            relative = self.path.absolute()\n'
     '287|        self.relative = relative\n'
     '288|        self.data = DirectoryData.get_from(path)\n'
     "289|        self.ctx = self.data.get_dev_context('.')\n"
     '290|        if not self.ctx.desc:\n'
     '291|            self.ctx.desc = "dev context of this directory"\n'
     '292|        if ignores is None:\n'
     '293|            ignores = self.default_ignores.copy()\n'
     '294|        gitignore = path.joinpath(".gitignore")\n'
     '295|        if gitignore.exists():\n'
     '296|            with open(gitignore, "r") as f:\n'
     '297|                content = f.read()\n'
     '298|                ignores.extend(content.splitlines())\n'
     '299|        self._ignores = []\n'
     '300|        for ignore in ignores:\n'
     '301|            ignore = ignore.strip()\n'
     "302|            if ignore.startswith('#'):\n"
     '303|                continue\n'
     '304|            self._ignores.append(ignore)\n'
     '305|\n'
     '306|    def get_ignores(self) -> List[str]:\n'
     '307|        return self._ignores\n'
     '308|\n'
     '309|    def full_context(self) -> str:\n'
     '310|        editing_context = ""\n'
     '311|        if self.data.editing:\n'
     '312|            try:\n'
     '313|                editing_context = f"currently editing file is '
     '`{self.data.editing}`, the content (with line number) '
     'are:\\n\\n<editing>\\n\\n"\n'
     '314|                editing_context += '
     'self.edit(self.data.editing).read(line_number=True, detail=True)\n'
     '315|                editing_context += "</editing>\\n"\n'
     '316|            except Exception as e:\n'
     '317|                self.data.editing = None\n'
     '318|\n'
     '319|        return f"""\n'
     '320|full context of the Directory instance:\n'
     '321|\n'
     '322|<Directory path=`{self.path}`>\n'
     '323|\n'
     '324|The sub-files and sub-dirs of the current directory are as follows '
     '(recursion depth 2).\n'
     '325|```\n'
     '326|{self.lists(recursion=2)}\n'
     '327|```\n'
     '328|\n'
     '329|DevContext at `Directory.ctx` are: \n'
     '330|<dev-context>\n'
     '331|{self.ctx.full_context()}\n'
     '332|</dev-context>\n'
     '333|\n'
     '334|all the available dev contexts from name (or path) to description are: \n'
     '335|```yaml\n'
     '336|{yaml_pretty_dump(self.existing_dev_contexts())}\n'
     '337|```\n'
     '338|\n'
     '339|{editing_context}\n'
     '340|</Directory>\n'
     '341|"""\n'
     '342|\n'
     '343|    def dev_contexts(self) -> Dict[str, PyDevCtx]:\n'
     '344|        return self.data.dev_contexts\n'
     '345|\n'
     '346|    def existing_dev_contexts(self) -> Dict[str, str]:\n'
     '347|        return {ctx.title: ctx.desc for ctx in '
     'self.data.dev_contexts.values()}\n'
     '348|\n'
     '349|    def new_dev_context(self, title: str, desc: str) -> PyDevCtxData:\n'
     '350|        ctx = PyDevCtxData(title=title, desc=desc)\n'
     '351|        self.data.dev_contexts[title] = ctx\n'
     '352|        return ctx\n'
     '353|\n'
     '354|    def lists(self, *, prefix: str = "", recursion: int = 0, files: bool '
     '= True, dirs: bool = True) -> str:\n'
     '355|        getter = DirectoryFileDescriptionGetter(self.path)\n'
     '356|        return generate_directory_tree(\n'
     '357|            self.path,\n'
     '358|            prefix=prefix,\n'
     '359|            recursion=recursion,\n'
     '360|            descriptions=getter,\n'
     '361|            ignores=self._ignores,\n'
     '362|            files=files,\n'
     '363|            dirs=dirs,\n'
     '364|        )\n'
     '365|\n'
     '366|    def subdir(self, path: str) -> Self:\n'
     '367|        real_path = self.path.joinpath(path)\n'
     '368|        try:\n'
     '369|            real_path.relative_to(self.path)\n'
     '370|        except ValueError:\n'
     '371|            raise ValueError(f"\'{path}\' is not a sub directory")\n'
     '372|        if not real_path.is_dir():\n'
     '373|            raise ValueError(f"\'{path}\' is not a directory")\n'
     '374|        if not real_path.exists():\n'
     '375|            raise ValueError(f"\'{path}\' does not exist")\n'
     '376|        return DirectoryImpl(real_path, self._ignores)\n'
     '377|\n'
     '378|    def describe(self, path: str, desc: str) -> None:\n'
     '379|        self.data.file_desc[path] = desc\n'
     '380|\n'
     '381|    def mkdir(self, subdir: str, desc: str, dev_ctx: Union[PyDevCtx, '
     'None] = None) -> bool:\n'
     '382|        real_subdir = self.path.joinpath(subdir).absolute()\n'
     '383|        real_subdir.relative_to(self.path)\n'
     '384|        if real_subdir.exists():\n'
     '385|            return False\n'
     '386|        real_subdir.mkdir()\n'
     '387|        data = DirectoryData.get_from(real_subdir)\n'
     '388|        data.set_description(desc=desc)\n'
     '389|        if dev_ctx is not None:\n'
     '390|            ctx = PyDevCtxData(**dev_ctx.model_dump())\n'
     '391|            data.set_dev_context(ctx)\n'
     '392|        return True\n'
     '393|\n'
     '394|    def touch(self, sub_file: str, desc: str, dev_ctx: Union[PyDevCtx, '
     'None] = None) -> bool:\n'
     '395|        real_sub_path = self.path.joinpath(sub_file).absolute()\n'
     '396|        real_sub_path.relative_to(self.path)\n'
     '397|        if real_sub_path.exists():\n'
     '398|            return False\n'
     '399|        real_sub_path.touch()\n'
     '400|        data = DirectoryData.get_from(real_sub_path.parent)\n'
     '401|        data.set_description(desc=desc, key=real_sub_path.name)\n'
     '402|        if dev_ctx is not None:\n'
     '403|            ctx = PyDevCtxData(**dev_ctx.model_dump())\n'
     '404|            data.set_dev_context(ctx, name=real_sub_path.name)\n'
     '405|        return True\n'
     '406|\n'
     '407|    def focus(self, file_path: Union[str, None]) -> Union[File, None]:\n'
     '408|        if file_path is None:\n'
     '409|            self.data.editing = None\n'
     '410|            return None\n'
     '411|        file = self.edit(file_path)\n'
     '412|        self.data.editing = file_path\n'
     '413|        return file\n'
     '414|\n'
     '415|    def edit(self, file_path: str) -> FileImpl:\n'
     '416|        real_path = self.path.joinpath(file_path).absolute()\n'
     '417|        if not real_path.is_file():\n'
     '418|            raise ValueError(f"\'{file_path}\' is not a file")\n'
     '419|        relative_path_obj = real_path.relative_to(self.path)\n'
     '420|        relative_path = str(relative_path_obj)\n'
     '421|        dev_context = self.data.get_dev_context(relative_path)\n'
     '422|        return FileImpl(\n'
     '423|            real_path,\n'
     '424|            dev_ctx=dev_context,\n'
     '425|        )\n'
     '426|\n'
     '427|    def save_dev_contexts(self):\n'
     '428|        self.data.save_to(self.path)\n'
     '429|\n'
     '430|\n'
     '431|if __name__ == "__main__":\n'
     '432|    current = pathlib.Path(__file__)\n'
     '433|    d = DirectoryImpl(current.parent)\n'
     '434|    d.focus(current.name)\n'
     '435|    print(d.lists())\n'
     '436|    print(d.ctx.full_context())\n'
     '437|    d.describe("abcd.py", "abstract classes")\n'
     '438|    d.save_dev_contexts()\n'
     '439|\n'
     '440|    print("+++++")\n'
     '441|    print(d.dev_contexts())\n'
     '442|\n'
     '443|    print("+++++")\n'
     '444|    print(d.full_context())\n'
     '445|\n'
     '446|    editing = d.edit(current.name)\n'
     '447|    print("+++++++++++ path", editing.path)\n'
     '448|\n'
     '449|    editing.write("hello", append=True)\n'
     '450|    insert_content(editing.path, "world", -1, -1)')

    ```
  payloads:
    task_info:
      task_id: 4d2ace327166ff1154ffbd8824c55f58
      task_name: GhostOS-Project-Manager
      process_id: 164e0213efd705f4816e3067e9428685
      matrix_id: ghostos_streamlit_app
      thread_id: 4d2ace327166ff1154ffbd8824c55f58
  seq: complete
  created: 1741525100.894
- msg_id: c81811b81a9fe26087b579324931eb7a
  role: system
  content: ''
  memory: |-
    ## observation on turn 8

    ### `file_content`

    ```
    ('1|from typing import Dict, ClassVar, List, Union\n'
     '2|\n'
     '3|from typing_extensions import Self\n'
     '4|import pathlib\n'
     '5|\n'
     '6|from ghostos import Operator, Session\n'
     '7|from ghostos.libraries.project.abcd import Directory, File, PyDevCtx\n'
     '8|from ghostos.libraries.project.dev_context import PyDevCtxData\n'
     '9|from ghostos.contracts.configs import YamlConfig\n'
     '10|from ghostos.core.messages import MessageType, Role\n'
     '11|from ghostos_common.helpers import generate_directory_tree, '
     'yaml_pretty_dump, get_module_fullname_from_path\n'
     '12|from ghostos_common.helpers.files import DescriptionsGetter\n'
     '13|from ghostos_moss import moss_runtime_ctx\n'
     '14|from pydantic import Field\n'
     '15|\n'
     '16|\n'
     '17|class DirectoryData(YamlConfig):\n'
     '18|    relative_path = ".ghostos_dir.yml"\n'
     '19|\n'
     '20|    dev_contexts: Dict[str, PyDevCtxData] = Field(\n'
     '21|        default_factory=dict,\n'
     '22|        description="the saved dev context from title to value",\n'
     '23|    )\n'
     '24|    file_desc: Dict[str, str] = Field(\n'
     '25|        default_factory=lambda: {".": ""},\n'
     '26|    )\n'
     '27|    editing: Union[str, None] = Field(\n'
     '28|        default=None,\n'
     '29|        description="the editing filename relative to the current '
     'directory",\n'
     '30|    )\n'
     '31|\n'
     '32|    def save_to(self, path: pathlib.Path) -> None:\n'
     '33|        if not path.is_dir():\n'
     "34|            raise NotADirectoryError(f'{path} is not a directory')\n"
     '35|        content = '
     'yaml_pretty_dump(self.model_dump(exclude_defaults=True))\n'
     '36|        file = path.joinpath(self.relative_path)\n'
     '37|        with open(file, "w") as f:\n'
     '38|            f.write(content)\n'
     '39|\n'
     '40|    def get_description(self, key=".") -> str:\n'
     '41|        return self.file_desc.get(key, "")\n'
     '42|\n'
     '43|    def set_description(self, key=".", desc: str = "") -> None:\n'
     '44|        self.file_desc[key] = desc\n'
     '45|\n'
     '46|    @classmethod\n'
     '47|    def get_from(cls, path: pathlib.Path) -> "DirectoryData":\n'
     '48|        if not path.is_dir():\n'
     "49|            raise NotADirectoryError(f'{path} is not a directory')\n"
     '50|        file = path.joinpath(cls.relative_path)\n'
     '51|        if not file.exists():\n'
     '52|            return cls()\n'
     '53|        with open(file, "r") as f:\n'
     '54|            content = f.read()\n'
     '55|            return cls.unmarshal(content)\n'
     '56|\n'
     '57|    def get_dev_context(self, name: str) -> PyDevCtxData:\n'
     '58|        if name in self.dev_contexts:\n'
     '59|            return self.dev_contexts[name]\n'
     '60|        data = PyDevCtxData(title=name)\n'
     '61|        self.dev_contexts[name] = data\n'
     '62|        return data\n'
     '63|\n'
     '64|    def set_dev_context(self, data: PyDevCtxData, name: str = ".") -> '
     'None:\n'
     '65|        self.dev_contexts[name] = data\n'
     '66|\n'
     '67|\n'
     '68|class DirectoryFileDescriptionGetter(DescriptionsGetter):\n'
     '69|\n'
     '70|    def __init__(self, root: pathlib.Path):\n'
     '71|        self.root = root\n'
     '72|        self._cached = {}\n'
     '73|\n'
     '74|    def get(self, path: pathlib.Path, default: Union[str, None] = None) '
     '-> Union[str, None]:\n'
     '75|        real_path = self.root.joinpath(path).absolute()\n'
     '76|        if real_path in self._cached:\n'
     '77|            return self._cached[real_path]\n'
     '78|        value = self._get(real_path, default)\n'
     '79|        self._cached[real_path] = value\n'
     '80|        return value\n'
     '81|\n'
     '82|    def _get(self, path: pathlib.Path, default: Union[str, None] = None) '
     '-> Union[str, None]:\n'
     '83|        if path.is_dir():\n'
     '84|            return DirectoryData.get_from(path).get_description()\n'
     '85|        elif path.is_file():\n'
     '86|            return '
     'DirectoryData.get_from(path.parent).get_description(path.name)\n'
     '87|        return default\n'
     '88|\n'
     '89|\n'
     '90|class FileImpl(File):\n'
     '91|    allow_ext: ClassVar[List[str]] = [\n'
     '92|        ".md", ".txt", ".py", ".ipynb", ".ts", ".php", ".html", ".js", '
     '".css", ".yaml",\n'
     '93|        ".yml", ".toml", ".json"\n'
     '94|    ]\n'
     '95|\n'
     '96|    def __init__(\n'
     '97|            self,\n'
     '98|            filepath: pathlib.Path,\n'
     '99|            dev_ctx: PyDevCtxData,\n'
     '100|    ):\n'
     '101|        if filepath.is_dir():\n'
     '102|            raise TypeError(f"{filepath} is not a directory")\n'
     '103|        self.path = filepath\n'
     '104|        self.ctx = dev_ctx\n'
     '105|        self.max_read_size = 5000\n'
     '106|\n'
     '107|    def read(self, line_number: bool = True, detail: bool = True) -> '
     'str:\n'
     '108|        allowed = self.is_readable()\n'
     '109|        for ext in self.allow_ext:\n'
     '110|            if self.path.name.endswith(ext):\n'
     '111|                allowed = True\n'
     '112|        if not allowed:\n'
     '113|            return f"File {self.path.name} are not readable now"\n'
     '114|\n'
     '115|        content = self.path.read_text()\n'
     '116|        length = len(content)\n'
     '117|        suffix = ""\n'
     '118|        if length > self.max_read_size:\n'
     '119|            content = content[:self.max_read_size]\n'
     '120|            suffix = "..."\n'
     '121|        if line_number:\n'
     '122|            lines = content.splitlines()\n'
     '123|            updated = []\n'
     '124|            idx = 0\n'
     '125|            for line in lines:\n'
     '126|                idx += 1\n'
     '127|                updated.append(f"{idx}|{line}")\n'
     '128|            content = "\\n".join(updated)\n'
     '129|        if not detail:\n'
     '130|            return content\n'
     '131|\n'
     '132|        modulename = get_module_fullname_from_path(str(self.path), '
     'use_longest_match=True)\n'
     '133|        if modulename is not None:\n'
     '134|            py_info = f"\\n\\nfile is python module `{modulename}`."\n'
     "135|            return (f'content of file {self.path} are:'\n"
     "136|                    f'\\n\\n<content "
     'length="{length}">{content}{suffix}</content>{py_info}\')\n'
     '137|\n'
     "138|        return f'<content "
     'length="{length}">{content}{suffix}</content>\'\n'
     '139|\n'
     '140|    def is_readable(self):\n'
     '141|        allowed = False\n'
     '142|        for ext in self.allow_ext:\n'
     '143|            if self.path.name.endswith(ext):\n'
     '144|                allowed = True\n'
     '145|        return allowed\n'
     '146|\n'
     '147|    def write(self, content: str, append: bool = False) -> None:\n'
     '148|        if not self.is_readable():\n'
     "149|            raise NotImplementedError(f'{self.path} is not writable "
     "yet')\n"
     '150|\n'
     '151|        origin = str(self.path.read_text())\n'
     '152|        if append:\n'
     '153|            content = origin + "\\n" + content\n'
     '154|        with open(self.path, "w") as f:\n'
     '155|            f.write(content)\n'
     '156|\n'
     '157|    def insert(self, content: str, start: int = -1, end: int = -1) -> '
     'None:\n'
     '158|        if not self.is_readable():\n'
     "159|            raise NotImplementedError(f'{self.path} is not writable "
     "yet')\n"
     '160|\n'
     '161|        insert_content(self.path, content, start, end)\n'
     '162|\n'
     '163|    def continuous_write(self, instruction: str, start: int = -1, end: '
     'int = 0, max_round: int = 10) -> Operator:\n'
     '164|        if not self.is_readable():\n'
     "165|            raise NotImplementedError(f'{self.path} is not writable "
     "yet')\n"
     '166|\n'
     '167|        return ContinuousWritingFileOperator(\n'
     '168|            filepath=self.path,\n'
     '169|            instruction=instruction,\n'
     '170|            start=start,\n'
     '171|            end=end,\n'
     '172|            max_round=max_round,\n'
     '173|        )\n'
     '174|\n'
     '175|\n'
     '176|def insert_content(path: pathlib.Path, content: str, start: int, end: '
     'int) -> None:\n'
     '177|    origin = path.read_text()\n'
     '178|    lines = origin.splitlines()\n'
     '179|    before = []\n'
     '180|    after = []\n'
     '181|    while start < 0 < len(lines):\n'
     '182|        start = len(lines) + start + 1\n'
     '183|    while end < 0 < len(lines):\n'
     '184|        end = len(lines) + end + 1\n'
     '185|\n'
     '186|    idx = 0\n'
     '187|    for line in lines:\n'
     '188|        idx += 1\n'
     '189|        if idx <= start:\n'
     '190|            before.append(line)\n'
     '191|        elif idx >= end and idx > start:\n'
     '192|            after.append(line)\n'
     '193|    before.extend([content])\n'
     '194|    before.extend(after)\n'
     '195|    with open(path, "w") as f:\n'
     '196|        f.write("\\n".join(before))\n'
     '197|\n'
     '198|\n'
     '199|class ContinuousWritingFileOperator(Operator):\n'
     '200|\n'
     '201|    def __init__(\n'
     '202|            self,\n'
     '203|            filepath: pathlib.Path,\n'
     '204|            instruction: str,\n'
     '205|            start: int,\n'
     '206|            end: int,\n'
     '207|            max_round: int,\n'
     '208|            end_token: str = "<end-continuous-writing>",\n'
     '209|    ):\n'
     '210|        self.filepath = filepath\n'
     '211|        self.instruction = instruction\n'
     '212|        self.start = start\n'
     '213|        self.end = end\n'
     '214|        self.contents = []\n'
     '215|        self.max_round = max_round\n'
     '216|        self.end_token = end_token\n'
     '217|        self.filename = self.filepath.name\n'
     '218|\n'
     '219|    def run(self, session: Session) -> Union[Operator, None]:\n'
     '220|        llm_api = session.ghost_driver.get_llm_api(session)\n'
     '221|        prompt = session.ghost_driver.get_current_prompt(session)\n'
     '222|        idx = 0\n'
     '223|        added = []\n'
     '224|        while idx < self.max_round:\n'
     '225|            _prompt = prompt.model_copy(deep=True)\n'
     '226|            _prompt.clear_callable()\n'
     '227|            _prompt.added.extend(added)\n'
     '228|            '
     '_prompt.added.append(Role.new_system(self._turn_instruction(idx)))\n'
     '229|\n'
     '230|            items = llm_api.deliver_chat_completion(_prompt, '
     'stream=session.allow_streaming())\n'
     '231|            messages, callers = session.respond(items)\n'
     '232|            has_end_token = False\n'
     '233|            for msg in messages:\n'
     '234|                if not MessageType.is_text(msg):\n'
     '235|                    continue\n'
     '236|                if msg.content.endswith(self.end_token):\n'
     '237|                    has_end_token = True\n'
     '238|                    replaced = msg.content.replace(self.end_token, "")\n'
     '239|                    msg.memory = msg.content\n'
     '240|                    msg.content = replaced\n'
     '241|                    added.append(msg)\n'
     '242|                self.contents.append(msg.content)\n'
     '243|            if has_end_token:\n'
     '244|                break\n'
     '245|        # do insert.\n'
     '246|        insert_content(self.filepath, "\\n".join(self.contents), '
     'self.start, self.end)\n'
     '247|        return session.mindflow().think(\n'
     '248|            Role.new_system(\n'
     '249|                f"continuous writing on {self.filename} at {self.start} '
     'to {self.end} is done after {idx} round"),\n'
     '250|        )\n'
     '251|\n'
     '252|    def _turn_instruction(self, idx: int) -> str:\n'
     '253|        return f"""\n'
     '254|You are at continuous writing stage, writing text content into file '
     '{self.filename} continuously. \n'
     '255|The block you are editing are from the origin content line '
     '`{self.start}` to `{self.end}`.\n'
     "256|All your generation will directly write into the block, SO DON'T WRITE "
     'ANYTHING not about the file. \n'
     '257|\n'
     '258|And Current round is {idx}/{self.max_round}. \n'
     '259|\n'
     '260|When you put end tokens `{self.end_token}` at end of your output, means '
     'all your output is done, and the loop will be break.\n'
     '261|The end tokens will not record to the block you are editing.\n'
     '262|Only use end tokens when you complete the whole writing. \n'
     '263|\n'
     '264|Follow the instruction: \n'
     '265|```\n'
     '266|{self.instruction}\n'
     '267|```\n'
     '268|\n'
     '269|now start your writing:\n'
     '270|"""\n'
     '271|\n'
     '272|    def destroy(self):\n'
     '273|        pass\n'
     '274|\n'
     '275|\n'
     '276|class DirectoryImpl(Directory):\n'
     '277|    default_ignores: ClassVar[List[str]] = [\n'
     '278|        ".gitignore",\n'
     '279|        DirectoryData.relative_path,\n'
     '280|        "__pycache__",\n'
     '281|    ]\n'
     '282|\n'
     '283|    def __init__(self, path: pathlib.Path, ignores: List[str] = None, '
     'relative: Union[str, None] = None):\n'
     '284|        self.path = path\n'
     '285|        if relative is None:\n'
     '286|            relative = self.path.absolute()\n'
     '287|        self.relative = relative\n'
     '288|        self.data = DirectoryData.get_from(path)\n'
     "289|        self.ctx = self.data.get_dev_context('.')\n"
     '290|        if not self.ctx.desc:\n'
     '291|            self.ctx.desc = "dev context of this directory"\n'
     '292|        if ignores is None:\n'
     '293|            ignores = self.default_ignores.copy()\n'
     '294|        gitignore = path.joinpath(".gitignore")\n'
     '295|        if gitignore.exists():\n'
     '296|            with open(gitignore, "r") as f:\n'
     '297|                content = f.read()\n'
     '298|                ignores.extend(content.splitlines())\n'
     '299|        self._ignores = []\n'
     '300|        for ignore in ignores:\n'
     '301|            ignore = ignore.strip()\n'
     "302|            if ignore.startswith('#'):\n"
     '303|                continue\n'
     '304|            self._ignores.append(ignore)\n'
     '305|\n'
     '306|    def get_ignores(self) -> List[str]:\n'
     '307|        return self._ignores\n'
     '308|\n'
     '309|    def full_context(self) -> str:\n'
     '310|        editing_context = ""\n'
     '311|        if self.data.editing:\n'
     '312|            try:\n'
     '313|                editing_context = f"currently editing file is '
     '`{self.data.editing}`, the content (with line number) '
     'are:\\n\\n<editing>\\n\\n"\n'
     '314|                editing_context += '
     'self.edit(self.data.editing).read(line_number=True, detail=True)\n'
     '315|                editing_context += "</editing>\\n"\n'
     '316|            except Exception as e:\n'
     '317|                self.data.editing = None\n'
     '318|\n'
     '319|        return f"""\n'
     '320|full context of the Directory instance:\n'
     '321|\n'
     '322|<Directory path=`{self.path}`>\n'
     '323|\n'
     '324|The sub-files and sub-dirs of the current directory are as follows '
     '(recursion depth 2).\n'
     '325|```\n'
     '326|{self.lists(recursion=2)}\n'
     '327|```\n'
     '328|\n'
     '329|DevContext at `Directory.ctx` are: \n'
     '330|<dev-context>\n'
     '331|{self.ctx.full_context()}\n'
     '332|</dev-context>\n'
     '333|\n'
     '334|all the available dev contexts from name (or path) to description are: \n'
     '335|```yaml\n'
     '336|{yaml_pretty_dump(self.existing_dev_contexts())}\n'
     '337|```\n'
     '338|\n'
     '339|{editing_context}\n'
     '340|</Directory>\n'
     '341|"""\n'
     '342|\n'
     '343|    def dev_contexts(self) -> Dict[str, PyDevCtx]:\n'
     '344|        return self.data.dev_contexts\n'
     '345|\n'
     '346|    def existing_dev_contexts(self) -> Dict[str, str]:\n'
     '347|        return {ctx.title: ctx.desc for ctx in '
     'self.data.dev_contexts.values()}\n'
     '348|\n'
     '349|    def new_dev_context(self, title: str, desc: str) -> PyDevCtxData:\n'
     '350|        ctx = PyDevCtxData(title=title, desc=desc)\n'
     '351|        self.data.dev_contexts[title] = ctx\n'
     '352|        return ctx\n'
     '353|\n'
     '354|    def lists(self, *, prefix: str = "", recursion: int = 0, files: bool '
     '= True, dirs: bool = True) -> str:\n'
     '355|        getter = DirectoryFileDescriptionGetter(self.path)\n'
     '356|        return generate_directory_tree(\n'
     '357|            self.path,\n'
     '358|            prefix=prefix,\n'
     '359|            recursion=recursion,\n'
     '360|            descriptions=getter,\n'
     '361|            ignores=self._ignores,\n'
     '362|            files=files,\n'
     '363|            dirs=dirs,\n'
     '364|        )\n'
     '365|\n'
     '366|    def subdir(self, path: str) -> Self:\n'
     '367|        real_path = self.path.joinpath(path)\n'
     '368|        try:\n'
     '369|            real_path.relative_to(self.path)\n'
     '370|        except ValueError:\n'
     '371|            raise ValueError(f"\'{path}\' is not a sub directory")\n'
     '372|        if not real_path.is_dir():\n'
     '373|            raise ValueError(f"\'{path}\' is not a directory")\n'
     '374|        if not real_path.exists():\n'
     '375|            raise ValueError(f"\'{path}\' does not exist")\n'
     '376|        return DirectoryImpl(real_path, self._ignores)\n'
     '377|\n'
     '378|    def describe(self, path: str, desc: str) -> None:\n'
     '379|        self.data.file_desc[path] = desc\n'
     '380|\n'
     '381|    def mkdir(self, subdir: str, desc: str, dev_ctx: Union[PyDevCtx, '
     'None] = None) -> bool:\n'
     '382|        real_subdir = self.path.joinpath(subdir).absolute()\n'
     '383|        real_subdir.relative_to(self.path)\n'
     '384|        if real_subdir.exists():\n'
     '385|            return False\n'
     '386|        real_subdir.mkdir()\n'
     '387|        data = DirectoryData.get_from(real_subdir)\n'
     '388|        data.set_description(desc=desc)\n'
     '389|        if dev_ctx is not None:\n'
     '390|            ctx = PyDevCtxData(**dev_ctx.model_dump())\n'
     '391|            data.set_dev_context(ctx)\n'
     '392|        return True\n'
     '393|\n'
     '394|    def touch(self, sub_file: str, desc: str, dev_ctx: Union[PyDevCtx, '
     'None] = None) -> bool:\n'
     '395|        real_sub_path = self.path.joinpath(sub_file).absolute()\n'
     '396|        real_sub_path.relative_to(self.path)\n'
     '397|        if real_sub_path.exists():\n'
     '398|            return False\n'
     '399|        real_sub_path.touch()\n'
     '400|        data = DirectoryData.get_from(real_sub_path.parent)\n'
     '401|        data.set_description(desc=desc, key=real_sub_path.name)\n'
     '402|        if dev_ctx is not None:\n'
     '403|            ctx = PyDevCtxData(**dev_ctx.model_dump())\n'
     '404|            data.set_dev_context(ctx, name=real_sub_path.name)\n'
     '405|        return True\n'
     '406|\n'
     '407|    def focus(self, file_path: Union[str, None]) -> Union[File, None]:\n'
     '408|        if file_path is None:\n'
     '409|            self.data.editing = None\n'
     '410|            return None\n'
     '411|        file = self.edit(file_path)\n'
     '412|        self.data.editing = file_path\n'
     '413|        return file\n'
     '414|\n'
     '415|    def edit(self, file_path: str) -> FileImpl:\n'
     '416|        real_path = self.path.joinpath(file_path).absolute()\n'
     '417|        if not real_path.is_file():\n'
     '418|            raise ValueError(f"\'{file_path}\' is not a file")\n'
     '419|        relative_path_obj = real_path.relative_to(self.path)\n'
     '420|        relative_path = str(relative_path_obj)\n'
     '421|        dev_context = self.data.get_dev_context(relative_path)\n'
     '422|        return FileImpl(\n'
     '423|            real_path,\n'
     '424|            dev_ctx=dev_context,\n'
     '425|        )\n'
     '426|\n'
     '427|    def save_dev_contexts(self):\n'
     '428|        self.data.save_to(self.path)\n'
     '429|\n'
     '430|\n'
     '431|if __name__ == "__main__":\n'
     '432|    current = pathlib.Path(__file__)\n'
     '433|    d = DirectoryImpl(current.parent)\n'
     '434|    d.focus(current.name)\n'
     '435|    print(d.lists())\n'
     '436|    print(d.ctx.full_context())\n'
     '437|    d.describe("abcd.py", "abstract classes")\n'
     '438|    d.save_dev_contexts()\n'
     '439|\n'
     '440|    print("+++++")\n'
     '441|    print(d.dev_contexts())\n'
     '442|\n'
     '443|    print("+++++")\n'
     '444|    print(d.full_context())\n'
     '445|\n'
     '446|    editing = d.edit(current.name)\n'
     '447|    print("+++++++++++ path", editing.path)\n'
     '448|\n'
     '449|    editing.write("hello", append=True)\n'
     '450|    insert_content(editing.path, "world", -1, -1)')

    ```
  seq: complete
  created: 1741525100.894
- msg_id: chatcmpl-B9AWVmSzhZI5tlEhvogYxmZbeKy9C
  finish_reason: stop
  role: assistant
  name: ''
  content: |-
    åœ¨æŸ¥çœ‹ `FileImpl` ç±»çš„ `write` æ–¹æ³•æ—¶ï¼Œæ²¡æœ‰æ˜æ˜¾çš„é”™è¯¯ã€‚ä¸è¿‡ï¼Œä¸ºäº†ç¡®ä¿å†™å…¥æ“ä½œæˆåŠŸï¼Œå¯ä»¥æ£€æŸ¥ä»¥ä¸‹å‡ ç‚¹ï¼š

    1. **æ–‡ä»¶è·¯å¾„å’Œæƒé™**ï¼šç¡®ä¿æ–‡ä»¶è·¯å¾„æ˜¯æ­£ç¡®çš„ï¼Œå¹¶ä¸”ç¨‹åºæœ‰æƒé™å¯¹è¯¥æ–‡ä»¶è¿›è¡Œå†™æ“ä½œã€‚

    2. **è¿½åŠ é€»è¾‘**ï¼šåœ¨è¿½åŠ æ¨¡å¼ä¸‹ï¼Œåº”è¯¥æ˜¯å°†æ–°å†…å®¹ä¸åŸæœ‰å†…å®¹åˆå¹¶åå†™å…¥ã€‚å½“å‰é€»è¾‘çœ‹èµ·æ¥æ­£ç¡®ï¼Œä½†å¯ä»¥æ·»åŠ æ—¥å¿—æˆ–è°ƒè¯•ä¿¡æ¯æ¥ç¡®ä¿ `origin` å’Œ `content` çš„å€¼æ˜¯é¢„æœŸçš„ã€‚

    3. **å¼‚å¸¸æ•è·**ï¼šå¯ä»¥åœ¨æ–‡ä»¶å†™å…¥æ“ä½œå‘¨å›´æ·»åŠ å¼‚å¸¸å¤„ç†ï¼Œä»¥æ•è·ä»»ä½•å¯èƒ½çš„IOé”™è¯¯å¹¶è¾“å‡ºè¯¦ç»†ä¿¡æ¯ã€‚

    å¦‚æœæ‚¨ç»§ç»­é‡åˆ°é—®é¢˜ï¼Œå»ºè®®æ‰“å°æ—¥å¿—æˆ–æ·»åŠ æ–­ç‚¹ä»¥æŸ¥çœ‹ç¨‹åºæ‰§è¡Œåˆ°çš„å…·ä½“ä½ç½®å’Œå˜é‡çš„å€¼ã€‚è¿™å°†æœ‰åŠ©äºæ›´å¿«åœ°è°ƒè¯•é—®é¢˜ã€‚

    å¦‚æœéœ€è¦ï¼Œæˆ‘å¯ä»¥å¸®åŠ©ä¿®æ”¹ä»£ç ä»¥å¢åŠ æ—¥å¿—æˆ–è€…å¼‚å¸¸å¤„ç†ã€‚
  payloads:
    completion_usage:
      completion_tokens: 201
      prompt_tokens: 20588
      total_tokens: 20789
      completion_tokens_details:
        accepted_prediction_tokens: 0
        audio_tokens: 0
        reasoning_tokens: 0
        rejected_prediction_tokens: 0
      prompt_tokens_details:
        audio_tokens: 0
        cached_tokens: 4608
    model_conf:
      model: gpt-4o
      description: ''
      service: openai
      temperature: 0.7
      n: 1
      max_tokens: 2000
      timeout: 30.0
      request_timeout: 40.0
      kwargs: {}
      message_types: null
      allow_streaming: true
      top_p: null
      reasoning: null
      compatible: null
      payloads: {}
    prompt_info:
      prompt_id: 29f0a2472c8707bc0b47c5b680d88a4e
      desc: created from thread 4d2ace327166ff1154ffbd8824c55f58 turn c72f612f93b24d1fe00e72432589297c
    task_info:
      task_id: 4d2ace327166ff1154ffbd8824c55f58
      task_name: GhostOS-Project-Manager
      process_id: 164e0213efd705f4816e3067e9428685
      matrix_id: ghostos_streamlit_app
      thread_id: 4d2ace327166ff1154ffbd8824c55f58
  seq: complete
  created: 1741525104.228
inputs:
- msg_id: d7cd535bfe9c5b5cd7d7d2c12dd56862
  role: user
  content: ghostos.facade æœ‰å“ªäº›å‡½æ•°?
  seq: complete
  created: 1741526074.825
added:
- msg_id: chatcmpl-B9AmDt44mABDgilTchDPHOo2jTFZO
  finish_reason: stop
  role: assistant
  content: |-
    `ghostos.facade` æ¨¡å—ä¸­å¯¼å…¥çš„ä¸€äº›å‡½æ•°å’ŒåŠŸèƒ½åŒ…æ‹¬ï¼š

    1. **ä» `ghostos.facade._llms` å¯¼å…¥**ï¼š
       - `get_llm_configs`: è·å– GhostOS LLMs çš„é…ç½®ã€‚
       - `set_default_model`: åœ¨è¿è¡Œæ—¶å°†é»˜è®¤æ¨¡å‹è®¾ç½®ä¸º LLMsã€‚
       - `get_llm_api_info`: è·å– LLM API çš„ä¿¡æ¯ã€‚
       - `get_llms`: è·å– LLMsã€‚
       - `get_llm_api`: è·å– LLM APIã€‚

    2. **ä» `ghostos.facade._contracts` å¯¼å…¥**ï¼š
       - `get_logger`: è·å– GhostOS çš„æ—¥å¿—è®°å½•å™¨ã€‚

    3. **ä» `ghostos.facade._model_funcs_facade` å¯¼å…¥**ï¼š
       - `text_completion`: æ–‡æœ¬è¡¥å…¨åŠŸèƒ½ã€‚
       - `file_reader`: æ–‡ä»¶è¯»å–åŠŸèƒ½ã€‚

    è¿™äº›æ˜¯æ¨¡å—ä¸­å¯ç”¨çš„ä¸»è¦åŠŸèƒ½ã€‚å¦‚æœä½ éœ€è¦æ›´å¤šå…³äºæŸä¸ªå‡½æ•°çš„è¯¦ç»†ä¿¡æ¯ï¼Œè¯·å‘Šè¯‰æˆ‘ã€‚
  payloads:
    completion_usage:
      completion_tokens: 209
      prompt_tokens: 20761
      total_tokens: 20970
      completion_tokens_details:
        accepted_prediction_tokens: 0
        audio_tokens: 0
        reasoning_tokens: 0
        rejected_prediction_tokens: 0
      prompt_tokens_details:
        audio_tokens: 0
        cached_tokens: 0
    model_conf:
      model: gpt-4o
      description: ''
      service: openai
      temperature: 0.7
      n: 1
      max_tokens: 2000
      timeout: 30.0
      request_timeout: 40.0
      kwargs: {}
      message_types: null
      allow_streaming: true
      top_p: null
      reasoning: null
      compatible: null
      payloads: {}
    prompt_info:
      prompt_id: c58efbd31772deccef3b3f978b16ded3
      desc: created from thread 4d2ace327166ff1154ffbd8824c55f58 turn e2d785f05bb002a23ad60172de9afccc
  seq: complete
  created: 1741526078.804
functions:
- name: moss
  description: Useful to execute code in the python context that MOSS provide to you.The
    code must include a `run` function.
  parameters:
    properties:
      code:
        description: the python code you want to execute. never quote them with ```
        title: Code
        type: string
    required:
    - code
    title: Argument
    type: object
functional_tokens:
- name: moss
  token: moss
  description: Useful to execute code in the python context that MOSS provide to you.The
    code must include a `run` function.
created: 1741526075
model:
  model: gpt-4o
  service: openai
run_start: 1741526074.9576
first_token: 1741526078.8037
run_end: 1741526078.6973
request_params: '{''messages'': [{''content'': ''# Meta Instruction\n\nYou are the
  mind of an AI Agent driven by `GhostOS` framework.\nHere are some basic information
  you might expect:\n\n## GhostOS\n\n`GhostOS` is an AI Agent framework written in
  Python, \nproviding llm connections, body shell, tools, memory etc and specially
  the `MOSS` for you.\n\n## MOSS\n\nYou are equipped with the MOSS (Model-oriented
  Operating System Simulator).\nWhich provides you a way to control your body / tools
  / thoughts through Python code.\n\nbasic usage: \n1. you will get the python code
  context that MOSS provide to you below. \n2. you can generate code with `moss` tool,
  then the `GhostOS` will execute them for you.\n3. if you print anything in your
  generated code, the output will be shown in further messages.\n\n## Code Context\n\nThe
  python context `ghostos.ghosts.project_manager.project_manager_moss` that MOSS provides
  to you are below:\n\n```python\nfrom ghostos.abcd import Mindflow\nfrom ghostos_moss
  import Moss as Parent\nfrom ghostos.libraries.project import ProjectExports\nfrom
  ghostos.libraries.terminal import Terminal\n\n\nclass Moss(Parent):\n    """\n    the
  interfaces for project manager.\n    """\n\n    project: ProjectExports.ProjectManager\n    """
  understand the project files/modules"""\n\n    mindflow: Mindflow\n    """ operate
  your mindflow state"""\n\n    terminal: Terminal\n    """interact with terminal"""\n\n```\n\ninterfaces
  of some imported attrs are:\n```python\n#<classes>\n\nclass Terminal(ABC):\n    """\n    Abstract
  base class representing a system terminal interface.\n    Provides basic command
  execution capabilities for OS interactions.\n    """\n\n    class CommandResult(NamedTuple):\n        """\n        Result
  container for command execution outcomes.\n        Attributes:\n            exit_code:
  Process exit code (0 for success)\n            stdout: Standard output content\n            stderr:
  Error output content\n        """\n        exit_code: int\n        stdout: str\n        stderr:
  str\n\n    @abstractmethod\n    def exec(self, *commands: str, timeout: float =
  10.0) -> CommandResult:\n        """\n        Execute a shell command and return
  structured results.\n\n        Args:\n            commands: Command lines to execute.
  each command is a full line command.\n            (Note: Implementation should handle
  proper shell escaping)\n            timeout: Timeout in seconds\n\n        Returns:\n            CommandResult
  containing exit code and output streams\n\n        Raises:\n            RuntimeError:
  If command execution fails fundamentally\n            TimeoutError: If execution
  exceeds permitted time\n        """\n        pass\n\n\nclass ProjectExports(Exporter):\n    """\n    the
  exports for projects.\n    """\n\n    ProjectManager = ProjectManager\n    PyDevCtx
  = PyDevCtx\n    File = File\n    Directory = Directory\n    PyModuleEditor = PyModuleEditor\n\n    """\n    #attrs
  of `ProjectExports` are:\n    #<attr name=`Directory` module=`ghostos.libraries.project.abcd`>\n    class
  Directory(ABC):\n        \\"""\n        this is a useful tool to manage a directory
  or a project in agentic way.\n        the principles of files management are:\n        1.
  You can manage the files and sub dirs in this directory, but not parent directories.\n        2.
  Markdown as knowledge: the Markdown files in the directory are the knowledge for
  you.\n        this library will get more features in future versions.\n        \\"""\n\n        path:
  pathlib.Path\n        \\"""the pathlib.Path object of the directory\\"""\n\n        ctx:
  PyDevCtx\n        \\"""the dev context of this directory\\"""\n\n        @abstractmethod\n        def
  full_context(self) -> str:\n            \\"""\n            :return: the context
  of the directory\n            \\"""\n            pass\n\n        @abstractmethod\n        def
  dev_contexts(self) -> Dict[str, PyDevCtx]:\n            \\"""\n            :return:
  all the dev contexts in this directory.\n            \\"""\n            pass\n\n        @abstractmethod\n        def
  new_dev_context(self, title: str, desc: str) -> PyDevCtx:\n            \\"""\n            create
  a new dev context for some jobs.\n            the context will save to the directory\n            \\"""\n            pass\n\n        @abstractmethod\n        def
  lists(\n                self, *,\n                prefix: str = "",\n                recursion:
  int = 0,\n                files: bool = True,\n                dirs: bool = True,\n        )
  -> str:\n            \\"""\n            list sub filenames and directories as string.\n            :param
  prefix: the relative path that start the listing.\n            :param recursion:
  the recursion depth, 0 means no recursion. < 0 means endless recursion.\n            :param
  dirs: True => list dirs\n            :param files: True => list files\n            :return:
  formated string of directory\n            \\"""\n            pass\n\n        @abstractmethod\n        def
  subdir(self, path: str) -> Self:\n            \\"""\n            get subdirectory
  instance by path relative to this directory.\n            :param path: the relative
  path which must be a directory. must exist or raise ValueError.\n            :return:
  Directory instance.\n\n            if you want to create directory, use terminal
  if you got one.\n            \\"""\n            pass\n\n        @abstractmethod\n        def
  describe(self, path: str, desc: str) -> None:\n            \\"""\n            describe
  a sub file or directory. then you can see the description in the context.\n            :param
  path: relative to this directory. if `.`, means describe the directory itself\n            :param
  desc: description.\n            \\"""\n            pass\n\n        @abstractmethod\n        def
  mkdir(self, subdir: str, desc: str, dev_ctx: Union[PyDevCtx, None] = None) -> bool:\n            \\"""\n            make
  a subdirectory with description and dev_ctx\n            :param subdir: directory
  path relative to this directory.\n            :param desc: description of the directory.\n            :param
  dev_ctx: pass the dev_ctx to this directory. not neccessary, do it only if you know
  what you\''re doing.\n            :return: if False, directory already exists.\n            \\"""\n            pass\n\n        @abstractmethod\n        def
  touch(self, sub_file: str, desc: str, dev_ctx: Union[PyDevCtx, None] = None) ->
  bool:\n            \\"""\n            touch a file with description and Optional[dev_ctx]\n            \\"""\n            pass\n\n        @abstractmethod\n        def
  edit(self, file_path: str) -> File:\n            \\"""\n            focus to edit
  the file in the directory\n            the file must exist or raise FileNotFoundError.\n\n            :param
  file_path: relative to the working directory. if None, don\''t focus on any file.\n            \\"""\n            pass\n\n    #</attr>\n\n    #<attr
  name=`File` module=`ghostos.libraries.project.abcd`>\n    class File(ABC):\n        path:
  pathlib.Path\n        \\"""the pathlib.Path object of the directory\\"""\n\n        ctx:
  PyDevCtx\n        \\"""the dev context of this file\\"""\n\n        @abstractmethod\n        def
  read(self, line_number: bool = True, detail: bool = True) -> str:\n            \\"""\n            read
  content from the file.\n            :param line_number: if True, add line number
  at the beginning of each line like `1|...`\n            :param detail: if True,
  add more information about the file, the real content of the file will be embraced
  with <content>...</content> mark\n            \\"""\n            pass\n\n        @abstractmethod\n        def
  write(self, content: str, append: bool = False) -> None:\n            \\"""\n            write
  content to the file.\n            \\"""\n            pass\n\n        @abstractmethod\n        def
  insert(self, content: str, start: int = -1, end: int = -1) -> None:\n            \\"""\n            use
  content to relace the origin content lines > start line and <= end line.\n            \\"""\n            pass\n\n        @abstractmethod\n        def
  continuous_write(self, instruction: str, start: int = -1, end: int = -1, max_round:
  int = 10) -> Operator:\n            \\"""\n            considering your output is
  limited, you can use this method to start a continuous writing in multi-turns.\n            only
  use it when you are planning to write something beyond your max-tokens limit.\n            :param
  instruction: about what you are doing, will remind it to you at each turn\n            :param
  start: start index: the writing start at line\n            :param end: end index:
  the writing end before (eqt) line\n            :param max_round: maximum round for
  this writing.\n            :return: remember to return the mind operator, which
  will operate the multi-turns writing.\n            \\"""\n            pass\n\n    #</attr>\n\n    #<attr
  name=`ProjectManager` module=`ghostos.libraries.project.abcd`>\n    class ProjectManager(ABC):\n        \\"""\n        project
  manager\n        you are provided with Directory, and DevContext that helping you
  to watch useful tools.\n        \\"""\n\n        root: Directory\n        \\"""the
  root directory of the project.\\"""\n\n        working: Directory\n        \\"""the
  current directory of the project.\\"""\n\n        @abstractmethod\n        def work_on(self,
  dir_path: str) -> Operator:\n            \\"""\n            change the working directory
  to dir_path, relative to the root directory.\n            :param dir_path: if empty
  or `~`, will check out to the root.\n            \\"""\n            pass\n\n        @abstractmethod\n        def
  edit_pymodule(self, modulename: str) -> PyModuleEditor:\n            \\"""\n            edit
  a python module, if editable.\n            :param modulename: the full import name
  of the module\n            \\"""\n            pass\n\n    #</attr>\n\n    #<attr
  name=`PyDevCtx` module=`ghostos.libraries.project.abcd`>\n    class PyDevCtx(BaseModel,
  ABC):\n        \\"""\n        python context for a certain kind of develop jobs.\n        you
  can use it to remember important python context and never forget them in long-term.\n        \\"""\n\n        title:
  str = Field(description="title for this context")\n\n        desc: str = Field(default="",
  description="description for this context")\n\n        instructions: Dict[str, str]
  = Field(\n            default_factory=dict,\n            description="write instructions
  by yourself to follow"\n        )\n\n        notes: Dict[str, str] = Field(\n            default_factory=dict,\n            description="record
  something in case of forgetting"\n        )\n\n        examples: List[str] = Field(\n            default_factory=list,\n            description="use
  python module as examples for developing.",\n        )\n\n        interfaces: List[_IMPORT_PATH]
  = Field(\n            default_factory=list,\n            description=(\n                "watching
  a bunch of python module/class/func interfaces."\n                "dev context will
  provide the interface of them for you"\n            )\n        )\n\n        sources:
  List[_IMPORT_PATH] = Field(\n            default_factory=list,\n            description="watching
  a bunch of python module/class/func sources."\n        )\n\n        @abstractmethod\n        def
  read_interface(\n                self,\n                target: Union[str, FunctionType,
  ModuleType, type],\n                *,\n                watching: bool = False,\n        )
  -> str:\n            \\"""\n            read code interface from a target.\n            :param
  target:  import path or objects that can be called by inspect.getsource\n            :param
  watching: if watching, will always watch it.\n            \\"""\n            pass\n\n        @abstractmethod\n        def
  read_source(\n                self,\n                target: Union[str, FunctionType,
  ModuleType, type],\n                *,\n                watching: bool = False,\n        )
  -> str:\n            \\"""\n            read source code from a target.\n            :param
  target:  import path or objects that can be called by inspect.getsource\n            :param
  watching: if watching, will always watch it.\n            \\"""\n            pass\n\n        @abstractmethod\n        def
  full_context(self) -> str:\n            \\"""\n            dump the context into
  nature language string.\n            \\"""\n            pass\n\n    #</attr>\n\n    #<attr
  name=`PyModuleEditor` module=`ghostos.libraries.pyeditor.abcd`>\n    class PyModuleEditor(ABC):\n        \\"""\n        can
  edit python module\n        \\"""\n\n        modulename: str\n        \\"""the editing
  module name\\"""\n\n        filename: str\n        \\"""the absolute filename of
  the module\\"""\n\n        @abstractmethod\n        def new_from(self, modulename:
  str) -> Self:\n            \\"""\n            create new module editor\n            \\"""\n            pass\n\n        @abstractmethod\n        def
  get_source(\n                self,\n                show_line_num: bool = False,\n                start_line:
  int = 0,\n                end_line: int = -1,\n        ) -> str:\n            \\"""\n            read
  source code from this module\n            :param show_line_num: if true, each line
  start with `[number]|`, for example:\n                    source code: `def foo():`\n                    show
  line number: ` 1|def foo():`.\n                   don\''t confuse the prefix line
  num is the part of the file.\n            :param start_line: start line number\n            :param
  end_line: end line number, if < 0, means end line number\n            :return: source
  code\n            \\"""\n            pass\n\n        @abstractmethod\n        def
  get_imported_attrs_interfaces(self) -> str:\n            \\"""\n            get
  imported attrs source code interfaces (definitions and signatures)\n            convenient
  way to use imported attrs without read source code from them.\n            \\"""\n            pass\n\n        @abstractmethod\n        def
  replace(\n                self,\n                target_str: str,\n                replace_str:
  str,\n                count: int = 1,\n                reload: bool = False,\n        )
  -> bool:\n            \\"""\n            replace the source code of this module
  by replace a specific string\n            :param target_str: target string in the
  source code\n            :param replace_str: replacement\n            :param count:
  if -1, replace all occurrences of replace_str, else only replace occurrences count
  times.\n            :param reload: if False, update but note save to the module.\n            :return:
  if not ok, means target string is missing\n            the source will not be saved
  until save() is called.\n            \\"""\n            pass\n\n        @abstractmethod\n        def
  append(self, source: str, reload: bool = False) -> None:\n            \\"""\n            append
  source code to this module.\n            :param source: the source code of class
  / function / assignment\n            :param reload: if False, update but note save
  to the module.\n            \\"""\n            pass\n\n        @abstractmethod\n        def
  insert(self, source: str, line_num: int, reload: bool = False) -> None:\n            \\"""\n            insert
  source code to this module at line number.\n            remember following the python
  code format pattern.\n            :param source: the inserting code, such like from
  ... import ... or others.\n            :param line_num: the start line of the insertion.
  if 0, insert to the top. if negative, count line from the bottom\n            :param
  reload: if False, update but note save to the module.\n            the source will
  not be saved until save() is called.\n            \\"""\n            pass\n\n        @abstractmethod\n        def
  replace_attr(\n                self,\n                attr_name: str,\n                replace_str:
  str,\n                reload: bool = False,\n        ) -> str:\n            \\"""\n            replace
  a module attribute\''s source code.\n            the target attribute shall be a
  class or a function.\n            :param attr_name: name of the target attribute
  of this module.\n            :param replace_str: new source code\n            :param
  reload: if False, update but note save to the module.\n            :return: the
  replaced source code. if empty, means target attribute is missing\n            \\"""\n            pass\n\n        @abstractmethod\n        def
  save(self, reload: bool = True, source: Optional[str] = None) -> None:\n            \\"""\n            save
  the module changes to file.\n            otherwise only the editor\''s cached source
  code will be changed.\n            :param reload: if True, reload the module from
  the saved source code.\n            :param source: if the source given, replace
  all the source code.\n            \\"""\n            pass\n\n    #</attr>\n    """\n\nclass
  Moss(Parent):\n    """\n    the interfaces for project manager.\n    """\n\n    project:
  ProjectExports.ProjectManager\n    """ understand the project files/modules"""\n\n    mindflow:
  Mindflow\n    """ operate your mindflow state"""\n\n    terminal: Terminal\n    """interact
  with terminal"""\n\n\nclass Mindflow(PromptObjectModel, ABC):\n    """\n    control
  ghost mind with basic operators.\n    """\n\n    MessageKind = Union[str, Message,
  Any]\n    """message kind shall be string or serializable object"""\n\n    # ---
  åŸºæœ¬æ“ä½œ --- #\n    @abstractmethod\n    def finish(self, status: str = "", *replies:
  MessageKind) -> Operator:\n        """\n        finish self task\n        :param
  status: describe status of the task\n        :param replies: replies to parent task
  or user\n        """\n        pass\n\n    @abstractmethod\n    def fail(self, reason:
  str = "", *replies: MessageKind) -> Operator:\n        """\n        self task failed.\n        :param
  reason: describe status of the task\n        :param replies: replies to parent task
  or user\n        """\n        pass\n\n    @abstractmethod\n    def wait(self, status:
  str = "", *replies: MessageKind) -> Operator:\n        """\n        wait for the
  parent task or user to provide more information or further instruction.\n        :param
  status: describe current status\n        :param replies: question, inform or\n        """\n        pass\n\n    @abstractmethod\n    def
  think(self, *messages: MessageKind, instruction: str = "", sync: bool = False) ->
  Operator:\n        """\n        start next round thinking on messages\n        :param
  messages: observe target\n        :param instruction: instruction when receive the
  observation.\n        :param sync: if True, observe immediately, otherwise check
  other event first\n        :return:\n        """\n        pass\n\n    @abstractmethod\n    def
  observe(self, **kwargs) -> Operator:\n        """\n        observe values\n        :param
  kwargs:\n        :return:\n        """\n        pass\n\n    @abstractmethod\n    def
  error(self, *messages: MessageKind) -> Operator:\n        """\n        think on
  the error message.\n        """\n        pass\n\n\n\nclass Operator(ABC):\n    """\n    return
  operator to outside system to operate your thought by agent system. \n    """\n    pass\n\n\n#<attr
  name=`<class \''ghostos_moss.abcd.Moss\''>.project` module=`ghostos.libraries.project.abcd`>\nclass
  ProjectManager(ABC):\n    """\n    project manager\n    you are provided with Directory,
  and DevContext that helping you to watch useful tools.\n    """\n\n    root: Directory\n    """the
  root directory of the project."""\n\n    working: Directory\n    """the current
  directory of the project."""\n\n    @abstractmethod\n    def work_on(self, dir_path:
  str) -> Operator:\n        """\n        change the working directory to dir_path,
  relative to the root directory.\n        :param dir_path: if empty or `~`, will
  check out to the root.\n        """\n        pass\n\n    @abstractmethod\n    def
  edit_pymodule(self, modulename: str) -> PyModuleEditor:\n        """\n        edit
  a python module, if editable.\n        :param modulename: the full import name of
  the module\n        """\n        pass\n\n#</attr>\n\n#<attr name=`__origin_moss__`
  module=`ghostos_moss.abcd`>\nclass Moss(ABC):\n    """\n    Language Model-oriented
  Operating System Simulator.\n    Python interface of Runtime Injections for AI-Models
  in multi-turns chat or thinking.\n    * The members with typehint will be injected
  with runtime instances.\n    * The property of SerializeType will persist during
  multi-turns.\n    * SerializeType: int, float, str, None, list, dict, BaseModel,
  TypedDict\n    """\n\n    T = TypeVar(\''T\'')\n\n    executing_code: Optional[str]\n    """the
  code that execute the moss instance."""\n\n    __watching__: List[Union[FunctionType,
  ModuleType, type]] = []\n    """the class or module that dose not bound to moss
  but still want to watch the interface of them"""\n\n    __ignored__: List[str] =
  []\n    """the ignored module names that do not need to watch the code interface
  of them"""\n\n    @abstractmethod\n    def pprint(self, *args, **kwargs) -> None:\n        """\n        pretty
  print\n        """\n        pass\n\n#</attr>\n\n#</classes>\n```\n\n\n\nNotices:\n*
  the imported functions are only shown with signature, the source code is omitted.\n*
  the properties on moss instance, will keep existence. \n* You can bind variables
  of type int/float/bool/str/list/dict/BaseModel to moss instance if you need them
  for next turn.\n\nYou are able to call the `moss` tool, generate code to fulfill
  your will.\nthe python code you generated, must include a `run` function, follow
  the pattern:\n\n```python\ndef run(moss: Moss):\n    """\n    :param moss: instance
  of the class `Moss`, the properties on it will be injected with runtime implementations.\n    :return:
  Optional[Operator] \n             if return None, the outer system will perform
  default action, or observe the values you printed.\n             Otherwise, the
  outer system will execute the Operator, which is your mindflow operator.\n             if
  some methods return Operator, you can use them to control your mindflow, REMEMBER
  to return the operator instance.\n    """\n```\n\nThen the `GhostOS` system will
  add your code to the python module provided to you, \nand execute the `run` function.
  \n\nNotices: \n* Your code will **APPEND** to the code of `ghostos.ghosts.project_manager.project_manager_moss`
  then execute, so **DO NOT REPEAT THE DEFINED CODE IN THE MODULE**.\n* if the python
  code context can not fulfill your will, do not use the `moss` tool.\n* you can reply
  as usual without calling the tool `moss`. use it only when you know what you\''re
  doing.\n* don\''t copy the main function\''s __doc__, they are instruction to you
  only.\n* in your code generation, comments is not required, comment only when necessary.\n*
  You code generation will not modify your provided module\''s source, unless you
  got tools to do so.\n\n### property `moss.project`\n\n# Project Manager Instance\n\nproject
  manager information are:\n\n## Root Directory Info\n\nfull context of the Directory
  instance:\n\n<Directory path=`/Users/BrightRed/Develop/github.com/ghost-in-moss/GhostOS/libs/ghostos`>\n\nThe
  sub-files and sub-dirs of the current directory are as follows (recursion depth
  2).\n```\nğŸ“„ RELEASES.md\nğŸ“ ghostos\n    ğŸ“ demo\n        ğŸ“ aifuncs_demo\n        ğŸ“
  tool_tests\n        ğŸ“ test_models\n        ğŸ“ experiments\n        ğŸ“ os_agents\n        ğŸ“„
  __init__.py\n        ğŸ“ agents\n        ğŸ“„ README.md\n        ğŸ“„ main_agent.py\n        ğŸ“„
  ghost_func_example.py\n        ğŸ“„ aifunc_raw_test.py\n        ğŸ“ sphero\n    ğŸ“„ bootstrap.py\n    ğŸ“„
  streamlit.py\n    ğŸ“ core\n        ğŸ“ messages\n        ğŸ“ aifunc\n        ğŸ“ runtime\n        ğŸ“„
  __init__.py\n        ğŸ“ models\n        ğŸ“ model_funcs\n        ğŸ“ llms\n    ğŸ“ framework\n        ğŸ“
  tasks\n        ğŸ“ messages\n        ğŸ“ logger\n        ğŸ“ cache\n        ğŸ“ translation\n        ğŸ“
  processes\n        ğŸ“ ghostos\n        ğŸ“ eventbuses\n        ğŸ“„ __init__.py\n        ğŸ“
  workspaces\n        ğŸ“ storage\n        ğŸ“ openai_realtime\n        ğŸ“ realtime\n        ğŸ“
  audio\n        ğŸ“ model_compatible\n        ğŸ“ threads\n        ğŸ“ variables\n        ğŸ“
  configs\n        ğŸ“ documents\n        ğŸ“ llms\n        ğŸ“ messengers\n        ğŸ“ assets\n    ğŸ“
  workspace_stub\n        ğŸ“„ .example.env\n        ğŸ“ .streamlit\n        ğŸ“ source\n        ğŸ“
  runtime\n        ğŸ“ configs\n        ğŸ“ assets\n        ğŸ“ memories\n    ğŸ“ contracts\n        ğŸ“„
  configs.py\n        ğŸ“„ variables.py\n        ğŸ“„ documents.py\n        ğŸ“„ shutdown.py\n        ğŸ“„
  cache.py\n        ğŸ“„ __init__.py\n        ğŸ“„ logger.py\n        ğŸ“„ README.md\n        ğŸ“„
  assets.py\n        ğŸ“„ translation.py\n        ğŸ“„ storage.py\n        ğŸ“„ modules.py\n        ğŸ“„
  workspace.py\n        ğŸ“„ pool.py\n    ğŸ“ facade\n        ğŸ“„ _llms.py\n        ğŸ“„ __init__.py\n        ğŸ“„
  README.md\n        ğŸ“„ _model_funcs_facade.py\n        ğŸ“„ _contracts.py\n    ğŸ“„ __init__.py\n    ğŸ“
  libraries\n        ğŸ“ pyeditor\n        ğŸ“ replier\n        ğŸ“ planner\n        ğŸ“ codex\n        ğŸ“
  terminal\n        ğŸ“ multighosts\n        ğŸ“„ README.md\n        ğŸ“ project\n        ğŸ“
  thinking\n        ğŸ“ memo\n        ğŸ“ notebook\n    ğŸ“ ghosts\n        ğŸ“ experimental\n        ğŸ“
  project_manager\n        ğŸ“ moss_agent\n        ğŸ“ chatbot\n        ğŸ“„ __init__.py\n        ğŸ“„
  README.md\n        ğŸ“ moss_ghost\n    ğŸ“ abcd\n        ğŸ“„ ghosts.py\n        ğŸ“„ thoughts.py\n        ğŸ“„
  realtime.py\n        ğŸ“„ __init__.py\n        ğŸ“„ utils.py\n        ğŸ“„ moss_action.py\n        ğŸ“„
  concepts.py\n    ğŸ“ prototypes\n        ğŸ“ streamlitapp\n        ğŸ“„ __init__.py\n        ğŸ“„
  README.md\n        ğŸ“ realtime_console\n        ğŸ“ ghostfunc\n        ğŸ“ spherogpt\n        ğŸ“
  console\n    ğŸ“ scripts\n        ğŸ“„ clear.py\n        ğŸ“„ __init__.py\n        ğŸ“ cli\n        ğŸ“„
  copy_workspace.py\n    ğŸ“ actions\n        ğŸ“„ __init__.py\n        ğŸ“„ module_editor.py\n    ğŸ“
  thoughts\n        ğŸ“„ meta_prompt_experiments.py\n        ğŸ“„ __init__.py\n        ğŸ“„
  operator_thoughts.py\n    ğŸ“„ errors.py\n    ğŸ“ moss_libs\n        ğŸ“„ __init__.py\n        ğŸ“„
  self_updater_moss.py\n    ğŸ“„ __main__.py\nğŸ“„ pyproject.toml\nğŸ“ tests\n    ğŸ“„ test_streamlit_render.py\n    ğŸ“
  core\n        ğŸ“ messages\n        ğŸ“ aifuncs\n        ğŸ“„ test_bootstrap.py\n        ğŸ“
  llms\n    ğŸ“ python\n        ğŸ“„ test_class.py\n        ğŸ“„ test_with_statement.py\n        ğŸ“„
  test_pydantic.py\n        ğŸ“„ test_os.py\n        ğŸ“„ test_yield.py\n        ğŸ“„ test_typing.py\n        ğŸ“„
  test_iterable.py\n        ğŸ“„ test_py_module.py\n        ğŸ“„ test_copy.py\n        ğŸ“„
  test_bytes.py\n        ğŸ“„ test_operators.py\n        ğŸ“„ test_regex.py\n        ğŸ“„ test_collection.py\n        ğŸ“„
  test_asyncio.py\n        ğŸ“„ test_typed_dict.py\n        ğŸ“„ test_property.py\n        ğŸ“„
  test_generic.py\n        ğŸ“„ test_exec.py\n        ğŸ“„ test_queue.py\n        ğŸ“„ test_set.py\n        ğŸ“„
  test_inspect.py\n        ğŸ“„ test_threads.py\n        ğŸ“„ test_slice.py\n        ğŸ“„ test_context.py\n        ğŸ“„
  test_func.py\n        ğŸ“„ test_dict.py\n        ğŸ“„ test_pkg.py\n        ğŸ“„ test_enum.py\n    ğŸ“
  framework\n        ğŸ“ tasks\n        ğŸ“ messages\n        ğŸ“ ghostos\n        ğŸ“ eventbuses\n        ğŸ“
  openai_realtime\n        ğŸ“ messenger\n        ğŸ“ threads\n        ğŸ“ variables\n        ğŸ“
  llms\n    ğŸ“ contracts\n        ğŸ“„ test_configs.py\n        ğŸ“„ test_modules.py\n        ğŸ“„
  test_pool.py\n    ğŸ“ ghostos\n        ğŸ“„ test_chatbot.py\n    ğŸ“ libraries\n        ğŸ“
  notebook\n    ğŸ“ abcd\n        ğŸ“„ test_moss_action.py\nğŸ“„ README.md\n```\n\nDevContext
  at `Directory.ctx` are: \n<dev-context>\n\nthe information from this PyDevCtx instance:\n\n*
  title: `.`\n* desc: `dev context of this directory`\n\n\n\nnotes:\n\n<note key=`package_manager`>\nuv\n</note>\n\n<note
  key=`install_command`>\nuv add\n</note>\n\n\nwatching interfaces:\n\n<interface
  from=`ghostos.facade`>\nfrom ghostos.facade._llms import (\n    get_llm_configs,  #
  get the ghostos llms config\n    set_default_model,  # set the default model to
  llms, only work during runtime\n    get_llm_api_info,\n    get_llms,\n    get_llm_api,\n)\n\nfrom
  ghostos.facade._contracts import (\n    get_logger,  # get ghostos logger\n)\n\nfrom
  ghostos.facade._model_funcs_facade import (\n    text_completion,  #\n    file_reader,\n)\n</interface>\n</dev-context>\n\nall
  the available dev contexts from name (or path) to description are: \n```yaml\n.:
  dev context of this directory\npyproject.toml: file dev context on pyproject.toml\nEdit
  ghostos.facade: Editing the facade.py file in the ghostos library\nfacade.py: file
  dev context on facade.py\n\n```\n<editing file=`None`>\n```text\nempty\n```\n</editing>\n\n</Directory>\n\n##
  Working Directory Info\n\nfull context of the Directory instance:\n\n<Directory
  path=`/Users/BrightRed/Develop/github.com/ghost-in-moss/GhostOS/libs/ghostos/ghostos/libraries/project`>\n\nThe
  sub-files and sub-dirs of the current directory are as follows (recursion depth
  2).\n```\nğŸ“„ abcd.py : `abstract classes`\nğŸ“„ __init__.py\nğŸ“„ project_impl.py\nğŸ“„ README.md\nğŸ“„
  dev_context.py\nğŸ“„ directory_impl.py\n```\n\nDevContext at `Directory.ctx` are: \n<dev-context>\n\nthe
  information from this PyDevCtx instance:\n\n* title: `.`\n* desc: `dev context of
  this directory`\n\n</dev-context>\n\nall the available dev contexts from name (or
  path) to description are: \n```yaml\n.: dev context of this directory\ndirectory_impl.py:
  \''\''\n\n```\n<editing file=`directory_impl.py`>\n```text\n1|from typing import
  Dict, ClassVar, List, Union\n2|\n3|from typing_extensions import Self\n4|import
  pathlib\n5|\n6|from ghostos import Operator, Session\n7|from ghostos.libraries.project.abcd
  import Directory, File, PyDevCtx\n8|from ghostos.libraries.project.dev_context import
  PyDevCtxData\n9|from ghostos.contracts.configs import YamlConfig\n10|from ghostos.core.messages
  import MessageType, Role\n11|from ghostos_common.helpers import generate_directory_tree,
  yaml_pretty_dump, get_module_fullname_from_path\n12|from ghostos_common.helpers.files
  import DescriptionsGetter\n13|from ghostos_moss import moss_runtime_ctx\n14|from
  pydantic import Field\n15|\n16|\n17|class DirectoryData(YamlConfig):\n18|    relative_path
  = ".ghostos_dir.yml"\n19|\n20|    dev_contexts: Dict[str, PyDevCtxData] = Field(\n21|        default_factory=dict,\n22|        description="the
  saved dev context from title to value",\n23|    )\n24|    file_desc: Dict[str, str]
  = Field(\n25|        default_factory=lambda: {".": ""},\n26|    )\n27|    editing:
  Union[str, None] = Field(\n28|        default=None,\n29|        description="the
  editing filename relative to the current directory",\n30|    )\n31|\n32|    def
  save_to(self, path: pathlib.Path) -> None:\n33|        if not path.is_dir():\n34|            raise
  NotADirectoryError(f\''{path} is not a directory\'')\n35|        content = yaml_pretty_dump(self.model_dump(exclude_defaults=True))\n36|        file
  = path.joinpath(self.relative_path)\n37|        with open(file, "w") as f:\n38|            f.write(content)\n39|\n40|    def
  get_description(self, key=".") -> str:\n41|        return self.file_desc.get(key,
  "")\n42|\n43|    def set_description(self, key=".", desc: str = "") -> None:\n44|        self.file_desc[key]
  = desc\n45|\n46|    @classmethod\n47|    def get_from(cls, path: pathlib.Path) ->
  "DirectoryData":\n48|        if not path.is_dir():\n49|            raise NotADirectoryError(f\''{path}
  is not a directory\'')\n50|        file = path.joinpath(cls.relative_path)\n51|        if
  not file.exists():\n52|            return cls()\n53|        with open(file, "r")
  as f:\n54|            content = f.read()\n55|            return cls.unmarshal(content)\n56|\n57|    def
  get_dev_context(self, name: str) -> PyDevCtxData:\n58|        if name in self.dev_contexts:\n59|            return
  self.dev_contexts[name]\n60|        data = PyDevCtxData(title=name)\n61|        self.dev_contexts[name]
  = data\n62|        return data\n63|\n64|    def set_dev_context(self, data: PyDevCtxData,
  name: str = ".") -> None:\n65|        self.dev_contexts[name] = data\n66|\n67|\n68|class
  DirectoryFileDescriptionGetter(DescriptionsGetter):\n69|\n70|    def __init__(self,
  root: pathlib.Path):\n71|        self.root = root\n72|        self._cached = {}\n73|\n74|    def
  get(self, path: pathlib.Path, default: Union[str, None] = None) -> Union[str, None]:\n75|        real_path
  = self.root.joinpath(path).absolute()\n76|        if real_path in self._cached:\n77|            return
  self._cached[real_path]\n78|        value = self._get(real_path, default)\n79|        self._cached[real_path]
  = value\n80|        return value\n81|\n82|    def _get(self, path: pathlib.Path,
  default: Union[str, None] = None) -> Union[str, None]:\n83|        if path.is_dir():\n84|            return
  DirectoryData.get_from(path).get_description()\n85|        elif path.is_file():\n86|            return
  DirectoryData.get_from(path.parent).get_description(path.name)\n87|        return
  default\n88|\n89|\n90|class FileImpl(File):\n91|    allow_ext: ClassVar[List[str]]
  = [\n92|        ".md", ".txt", ".py", ".ipynb", ".ts", ".php", ".html", ".js", ".css",
  ".yaml",\n93|        ".yml", ".toml", ".json"\n94|    ]\n95|\n96|    def __init__(\n97|            self,\n98|            filepath:
  pathlib.Path,\n99|            dev_ctx: PyDevCtxData,\n100|    ):\n101|        if
  filepath.is_dir():\n102|            raise TypeError(f"{filepath} is not a directory")\n103|        self.path
  = filepath\n104|        self.ctx = dev_ctx\n105|        self.max_read_size = 5000\n106|\n107|    def
  read(self, line_number: bool = True, detail: bool = True) -> str:\n108|        allowed
  = self.is_readable()\n109|        for ext in self.allow_ext:\n110|            if
  self.path.name.endswith(ext):\n111|                allowed = True\n112|        if
  not allowed:\n113|            return f"File {self.path.name} are not readable now"\n114|\n115|        content
  = self.path.read_text()\n116|        length = len(content)\n117|        suffix =
  ""\n118|        if length > self.max_read_size:\n119|            content = content[:self.max_read_size]\n120|            suffix
  = "..."\n121|        if line_number:\n122|            lines = content.splitlines()\n123|            updated
  = []\n124|            idx = 0\n125|            for line in lines:\n126|                idx
  += 1\n127|                updated.append(f"{idx}|{line}")\n128|            content
  = "\\n".join(updated)\n129|        if not detail:\n130|            return content\n131|\n132|        modulename
  = get_module_fullname_from_path(str(self.path), use_longest_match=True)\n133|        if
  modulename is not None:\n134|            py_info = f"\\n\\nfile is python module
  `{modulename}`."\n135|            return (f\''content of file `{self.path}` are:\''\n136|                    f\''\\n\\n<content
  length="{length}">\\n{content}{suffix}\\n</content>{py_info}\'')\n137|\n138|        return
  f\''<content length="{length}">\\n{content}{suffix}\\n</content>\''\n139|\n140|    def
  is_readable(self):\n141|        allowed = False\n142|        for ext in self.allow_ext:\n143|            if
  self.p\n```\n</editing>\n\n</Directory>\n\n### property `moss.mindflow`\n\n# Mindflow\n\nYou
  are handling a task `GhostOS-Project-Manager`:\n\n```yaml\nname: GhostOS-Project-Manager\ndescription:
  |2\n\n      Specialist agent to manage any project\nstatus_desc: \''\''\n\n```\nIf
  your task `description` is empty, means endless task, you shall not operate it;\nOtherwise
  you shall `finish` or `cancel` it while the task is done or canceled by user.  \n\nuse
  Mindflow to operate the task state if you need.\n\n### property `moss.terminal`\n\n#
  Terminal Context\n\nbasic information about the current terminal: \n```bash\n[System
  Context]\nOS: macOS-14.6.1\nUser: BrightRed\nPwd: /Users/BrightRed/Develop/github.com/ghost-in-moss/GhostOS/libs/ghostos\nTimeZone:
  CST\nTime: 2025-03-09 21:14:34\nSystem Lang: None\nSystem Encoding: UTF-8\n\n```\n\n#
  Agent Info\n\nThe Agent info about who you are and what you are doing:\n\n## Identity\n\n```yaml\nname:
  GhostOS-Project-Manager\ndescription: |2\n\n      Specialist agent to manage any
  project\n\n```\n\n## Persona\n\nPowered By: GhostOS Project\nCapabilities: Expert
  in project management, powered by advanced AI and the MOSS protocol, \nwith full-code
  interface proficiency in Python tools.\n\n## Instruction\n\n## **1. Interacting
  with Engineer Users**\n- **Be Clear and Concise**: Use straightforward, technical
  language that engineers can easily understand.  \n- **Provide Context**: Always
  explain the purpose and outcome of your actions.  \n- **Ask for Clarification**:
  Politely request more details if a userâ€™s request is unclear, or you can not get
  enough context.\n- **Offer Suggestions**: Propose alternatives if a request cannot
  be fulfilled.  \n\n## **2. Encouraging Proactive Problem Solving**\n- **Anticipate
  Needs**: Suggest related tasks based on the userâ€™s actions.  \n- **Highlight Issues**:
  Notify users of potential problems immediately.  \n- **Automate Repetitive Tasks**:
  Offer to automate frequent or tedious tasks.  \n\n## **3. Security Considerations**\n-
  **Confirm Destructive Actions**: Always ask for confirmation before irreversible
  actions.  \n- **Notify Users of Risks**: Warn users of potential risks before proceeding.  \n\n##
  **4. Expressing Gratitude**\n- **Acknowledge User Input**: Thank users for their
  instructions and feedback.  \n- **Encourage Feedback**: Invite users to share suggestions
  for improvement, and record important ones on DevContext.'', ''role'': ''developer''},
  {''content'': ''ä½ å¥½å•Š'', ''role'': ''user''}, {''content'': ''ä½ å¥½ï¼æœ‰ä»€ä¹ˆæˆ‘å¯ä»¥å¸®åŠ©ä½ çš„å—ï¼Ÿ'', ''role'':
  ''assistant'', ''tool_calls'': None, ''function_call'': None}, {''content'': ''ä½ å¥½å•Š'',
  ''role'': ''user''}, {''content'': ''ä½ å¥½ï¼è¯·é—®æœ‰ä»€ä¹ˆæˆ‘å¯ä»¥å¸®åŠ©ä½ çš„å—ï¼Ÿ'', ''role'': ''assistant'',
  ''tool_calls'': None, ''function_call'': None}, {''content'': ''ä½ åœ¨çœ‹å“ªä¸ªæ–‡ä»¶?'', ''role'':
  ''user''}, {''content'': ''æˆ‘ç›®å‰æ­£åœ¨æŸ¥çœ‹çš„æ˜¯æ–‡ä»¶ `directory_impl.py`ã€‚è¯·é—®ä½ å¯¹è¿™ä¸ªæ–‡ä»¶æœ‰ä»»ä½•å…·ä½“çš„éœ€æ±‚æˆ–é—®é¢˜å—ï¼Ÿ'',
  ''role'': ''assistant'', ''tool_calls'': None, ''function_call'': None}, {''content'':
  ''è¿™é‡Œé¢çš„ fileimpl.write æœ‰ bug, å†™æ–‡ä»¶ä¸æˆåŠŸ. ä½ èƒ½å¸®æˆ‘çœ‹å‡ºé—®é¢˜å—?'', ''role'': ''user''}, {''role'':
  ''assistant'', ''tool_calls'': [{''id'': ''call_v7H1rDOyNULWN6iGMsCQApVB'', ''function'':
  {''name'': ''moss'', ''arguments'': ''{"code":"def run(moss: Moss):\\n    module_editor
  = moss.project.edit_pymodule(\''ghostos.libraries.project.directory_impl\'')\\n    file_content
  = module_editor.get_source(show_line_num=True)\\n    moss.pprint(file_content)\\n    \\n    #
  Return the content for further analysis\\n    return moss.mindflow.observe(file_content=file_content)"}''},
  ''type'': ''function''}]}, {''content'': ''Moss output:\n```text\n(\''1|from typing
  import Dict, ClassVar, List, Union\\n\''\n \''2|\\n\''\n \''3|from typing_extensions
  import Self\\n\''\n \''4|import pathlib\\n\''\n \''5|\\n\''\n \''6|from ghostos
  import Operator, Session\\n\''\n \''7|from ghostos.libraries.project.abcd import
  Directory, File, PyDevCtx\\n\''\n \''8|from ghostos.libraries.project.dev_context
  import PyDevCtxData\\n\''\n \''9|from ghostos.contracts.configs import YamlConfig\\n\''\n
  \''10|from ghostos.core.messages import MessageType, Role\\n\''\n \''11|from ghostos_common.helpers
  import generate_directory_tree, \''\n \''yaml_pretty_dump, get_module_fullname_from_path\\n\''\n
  \''12|from ghostos_common.helpers.files import DescriptionsGetter\\n\''\n \''13|from
  ghostos_moss import moss_runtime_ctx\\n\''\n \''14|from pydantic import Field\\n\''\n
  \''15|\\n\''\n \''16|\\n\''\n \''17|class DirectoryData(YamlConfig):\\n\''\n \''18|    relative_path
  = ".ghostos_dir.yml"\\n\''\n \''19|\\n\''\n \''20|    dev_contexts: Dict[str, PyDevCtxData]
  = Field(\\n\''\n \''21|        default_factory=dict,\\n\''\n \''22|        description="the
  saved dev context from title to value",\\n\''\n \''23|    )\\n\''\n \''24|    file_desc:
  Dict[str, str] = Field(\\n\''\n \''25|        default_factory=lambda: {".": ""},\\n\''\n
  \''26|    )\\n\''\n \''27|    editing: Union[str, None] = Field(\\n\''\n \''28|        default=None,\\n\''\n
  \''29|        description="the editing filename relative to the current \''\n \''directory",\\n\''\n
  \''30|    )\\n\''\n \''31|\\n\''\n \''32|    def save_to(self, path: pathlib.Path)
  -> None:\\n\''\n \''33|        if not path.is_dir():\\n\''\n "34|            raise
  NotADirectoryError(f\''{path} is not a directory\'')\\n"\n \''35|        content
  = \''\n \''yaml_pretty_dump(self.model_dump(exclude_defaults=True))\\n\''\n \''36|        file
  = path.joinpath(self.relative_path)\\n\''\n \''37|        with open(file, "w") as
  f:\\n\''\n \''38|            f.write(content)\\n\''\n \''39|\\n\''\n \''40|    def
  get_description(self, key=".") -> str:\\n\''\n \''41|        return self.file_desc.get(key,
  "")\\n\''\n \''42|\\n\''\n \''43|    def set_description(self, key=".", desc: str
  = "") -> None:\\n\''\n \''44|        self.file_desc[key] = desc\\n\''\n \''45|\\n\''\n
  \''46|    @classmethod\\n\''\n \''47|    def get_from(cls, path: pathlib.Path) ->
  "DirectoryData":\\n\''\n \''48|        if not path.is_dir():\\n\''\n "49|            raise
  NotADirectoryError(f\''{path} is not a directory\'')\\n"\n \''50|        file =
  path.joinpath(cls.relative_path)\\n\''\n \''51|        if not file.exists():\\n\''\n
  \''52|            return cls()\\n\''\n \''53|        with open(file, "r") as f:\\n\''\n
  \''54|            content = f.read()\\n\''\n \''55|            return cls.unmarshal(content)\\n\''\n
  \''56|\\n\''\n \''57|    def get_dev_context(self, name: str) -> PyDevCtxData:\\n\''\n
  \''58|        if name in self.dev_contexts:\\n\''\n \''59|            return self.dev_contexts[name]\\n\''\n
  \''60|        data = PyDevCtxData(title=name)\\n\''\n \''61|        self.dev_contexts[name]
  = data\\n\''\n \''62|        return data\\n\''\n \''63|\\n\''\n \''64|    def set_dev_context(self,
  data: PyDevCtxData, name: str = ".") -> \''\n \''None:\\n\''\n \''65|        self.dev_contexts[name]
  = data\\n\''\n \''66|\\n\''\n \''67|\\n\''\n \''68|class DirectoryFileDescriptionGetter(DescriptionsGetter):\\n\''\n
  \''69|\\n\''\n \''70|    def __init__(self, root: pathlib.Path):\\n\''\n \''71|        self.root
  = root\\n\''\n \''72|        self._cached = {}\\n\''\n \''73|\\n\''\n \''74|    def
  get(self, path: pathlib.Path, default: Union[str, None] = None) \''\n \''-> Union[str,
  None]:\\n\''\n \''75|        real_path = self.root.joinpath(path).absolute()\\n\''\n
  \''76|        if real_path in self._cached:\\n\''\n \''77|            return self._cached[real_path]\\n\''\n
  \''78|        value = self._get(real_path, default)\\n\''\n \''79|        self._cached[real_path]
  = value\\n\''\n \''80|        return value\\n\''\n \''81|\\n\''\n \''82|    def
  _get(self, path: pathlib.Path, default: Union[str, None] = None) \''\n \''-> Union[str,
  None]:\\n\''\n \''83|        if path.is_dir():\\n\''\n \''84|            return
  DirectoryData.get_from(path).get_description()\\n\''\n \''85|        elif path.is_file():\\n\''\n
  \''86|            return \''\n \''DirectoryData.get_from(path.parent).get_description(path.name)\\n\''\n
  \''87|        return default\\n\''\n \''88|\\n\''\n \''89|\\n\''\n \''90|class FileImpl(File):\\n\''\n
  \''91|    allow_ext: ClassVar[List[str]] = [\\n\''\n \''92|        ".md", ".txt",
  ".py", ".ipynb", ".ts", ".php", ".html", ".js", \''\n \''".css", ".yaml",\\n\''\n
  \''93|        ".yml", ".toml", ".json"\\n\''\n \''94|    ]\\n\''\n \''95|\\n\''\n
  \''96|    def __init__(\\n\''\n \''97|            self,\\n\''\n \''98|            filepath:
  pathlib.Path,\\n\''\n \''99|            dev_ctx: PyDevCtxData,\\n\''\n \''100|    ):\\n\''\n
  \''101|        if filepath.is_dir():\\n\''\n \''102|            raise TypeError(f"{filepath}
  is not a directory")\\n\''\n \''103|        self.path = filepath\\n\''\n \''104|        self.ctx
  = dev_ctx\\n\''\n \''105|        self.max_read_size = 5000\\n\''\n \''106|\\n\''\n
  \''107|    def read(self, line_number: bool = True, detail: bool = True) -> \''\n
  \''str:\\n\''\n \''108|        allowed = self.is_readable()\\n\''\n \''109|        for
  ext in self.allow_ext:\\n\''\n \''110|            if self.path.name.endswith(ext):\\n\''\n
  \''111|                allowed = True\\n\''\n \''112|        if not allowed:\\n\''\n
  \''113|            return f"File {self.path.name} are not readable now"\\n\''\n
  \''114|\\n\''\n \''115|        content = self.path.read_text()\\n\''\n \''116|        length
  = len(content)\\n\''\n \''117|        suffix = ""\\n\''\n \''118|        if length
  > self.max_read_size:\\n\''\n \''119|            content = content[:self.max_read_size]\\n\''\n
  \''120|            suffix = "..."\\n\''\n \''121|        if line_number:\\n\''\n
  \''122|            lines = content.splitlines()\\n\''\n \''123|            updated
  = []\\n\''\n \''124|            idx = 0\\n\''\n \''125|            for line in lines:\\n\''\n
  \''126|                idx += 1\\n\''\n \''127|                updated.append(f"{idx}|{line}")\\n\''\n
  \''128|            content = "\\\\n".join(updated)\\n\''\n \''129|        if not
  detail:\\n\''\n \''130|            return content\\n\''\n \''131|\\n\''\n \''132|        modulename
  = get_module_fullname_from_path(str(self.path), \''\n \''use_longest_match=True)\\n\''\n
  \''133|        if modulename is not None:\\n\''\n \''134|            py_info = f"\\\\n\\\\nfile
  is python module `{modulename}`."\\n\''\n "135|            return (f\''content of
  file {self.path} are:\''\\n"\n "136|                    f\''\\\\n\\\\n<content "\n
  \''length="{length}">{content}{suffix}</content>{py_info}\\\'')\\n\''\n \''137|\\n\''\n
  "138|        return f\''<content "\n \''length="{length}">{content}{suffix}</content>\\\''\\n\''\n
  \''139|\\n\''\n \''140|    def is_readable(self):\\n\''\n \''141|        allowed
  = False\\n\''\n \''142|        for ext in self.allow_ext:\\n\''\n \''143|            if
  self.path.name.endswith(ext):\\n\''\n \''144|                allowed = True\\n\''\n
  \''145|        return allowed\\n\''\n \''146|\\n\''\n \''147|    def write(self,
  content: str, append: bool = False) -> None:\\n\''\n \''148|        if not self.is_readable():\\n\''\n
  "149|            raise NotImplementedError(f\''{self.path} is not writable "\n "yet\'')\\n"\n
  \''150|\\n\''\n \''151|        origin = str(self.path.read_text())\\n\''\n \''152|        if
  append:\\n\''\n \''153|            content = origin + "\\\\n" + content\\n\''\n
  \''154|        with open(self.path, "w") as f:\\n\''\n \''155|            f.write(content)\\n\''\n
  \''156|\\n\''\n \''157|    def insert(self, content: str, start: int = -1, end:
  int = -1) -> \''\n \''None:\\n\''\n \''158|        if not self.is_readable():\\n\''\n
  "159|            raise NotImplementedError(f\''{self.path} is not writable "\n "yet\'')\\n"\n
  \''160|\\n\''\n \''161|        insert_content(self.path, content, start, end)\\n\''\n
  \''162|\\n\''\n \''163|    def continuous_write(self, instruction: str, start: int
  = -1, end: \''\n \''int = 0, max_round: int = 10) -> Operator:\\n\''\n \''164|        if
  not self.is_readable():\\n\''\n "165|            raise NotImplementedError(f\''{self.path}
  is not writable "\n "yet\'')\\n"\n \''166|\\n\''\n \''167|        return ContinuousWritingFileOperator(\\n\''\n
  \''168|            filepath=self.path,\\n\''\n \''169|            instruction=instruction,\\n\''\n
  \''170|            start=start,\\n\''\n \''171|            end=end,\\n\''\n \''172|            max_round=max_round,\\n\''\n
  \''173|        )\\n\''\n \''174|\\n\''\n \''175|\\n\''\n \''176|def insert_content(path:
  pathlib.Path, content: str, start: int, end: \''\n \''int) -> None:\\n\''\n \''177|    origin
  = path.read_text()\\n\''\n \''178|    lines = origin.splitlines()\\n\''\n \''179|    before
  = []\\n\''\n \''180|    after = []\\n\''\n \''181|    while start < 0 < len(lines):\\n\''\n
  \''182|        start = len(lines) + start + 1\\n\''\n \''183|    while end < 0 <
  len(lines):\\n\''\n \''184|        end = len(lines) + end + 1\\n\''\n \''185|\\n\''\n
  \''186|    idx = 0\\n\''\n \''187|    for line in lines:\\n\''\n \''188|        idx
  += 1\\n\''\n \''189|        if idx <= start:\\n\''\n \''190|            before.append(line)\\n\''\n
  \''191|        elif idx >= end and idx > start:\\n\''\n \''192|            after.append(line)\\n\''\n
  \''193|    before.extend([content])\\n\''\n \''194|    before.extend(after)\\n\''\n
  \''195|    with open(path, "w") as f:\\n\''\n \''196|        f.write("\\\\n".join(before))\\n\''\n
  \''197|\\n\''\n \''198|\\n\''\n \''199|class ContinuousWritingFileOperator(Operator):\\n\''\n
  \''200|\\n\''\n \''201|    def __init__(\\n\''\n \''202|            self,\\n\''\n
  \''203|            filepath: pathlib.Path,\\n\''\n \''204|            instruction:
  str,\\n\''\n \''205|            start: int,\\n\''\n \''206|            end: int,\\n\''\n
  \''207|            max_round: int,\\n\''\n \''208|            end_token: str = "<end-continuous-writing>",\\n\''\n
  \''209|    ):\\n\''\n \''210|        self.filepath = filepath\\n\''\n \''211|        self.instruction
  = instruction\\n\''\n \''212|        self.start = start\\n\''\n \''213|        self.end
  = end\\n\''\n \''214|        self.contents = []\\n\''\n \''215|        self.max_round
  = max_round\\n\''\n \''216|        self.end_token = end_token\\n\''\n \''217|        self.filename
  = self.filepath.name\\n\''\n \''218|\\n\''\n \''219|    def run(self, session: Session)
  -> Union[Operator, None]:\\n\''\n \''220|        llm_api = session.ghost_driver.get_llm_api(session)\\n\''\n
  \''221|        prompt = session.ghost_driver.get_current_prompt(session)\\n\''\n
  \''222|        idx = 0\\n\''\n \''223|        added = []\\n\''\n \''224|        while
  idx < self.max_round:\\n\''\n \''225|            _prompt = prompt.model_copy(deep=True)\\n\''\n
  \''226|            _prompt.clear_callable()\\n\''\n \''227|            _prompt.added.extend(added)\\n\''\n
  \''228|            \''\n \''_prompt.added.append(Role.new_system(self._turn_instruction(idx)))\\n\''\n
  \''229|\\n\''\n \''230|            items = llm_api.deliver_chat_completion(_prompt,
  \''\n \''stream=session.allow_streaming())\\n\''\n \''231|            messages,
  callers = session.respond(items)\\n\''\n \''232|            has_end_token = False\\n\''\n
  \''233|            for msg in messages:\\n\''\n \''234|                if not MessageType.is_text(msg):\\n\''\n
  \''235|                    continue\\n\''\n \''236|                if msg.content.endswith(self.end_token):\\n\''\n
  \''237|                    has_end_token = True\\n\''\n \''238|                    replaced
  = msg.content.replace(self.end_token, "")\\n\''\n \''239|                    msg.memory
  = msg.content\\n\''\n \''240|                    msg.content = replaced\\n\''\n
  \''241|                    added.append(msg)\\n\''\n \''242|                self.contents.append(msg.content)\\n\''\n
  \''243|            if has_end_token:\\n\''\n \''244|                break\\n\''\n
  \''245|        # do insert.\\n\''\n \''246|        insert_content(self.filepath,
  "\\\\n".join(self.contents), \''\n \''self.start, self.end)\\n\''\n \''247|        return
  session.mindflow().think(\\n\''\n \''248|            Role.new_system(\\n\''\n \''249|                f"continuous
  writing on {self.filename} at {self.start} \''\n \''to {self.end} is done after
  {idx} round"),\\n\''\n \''250|        )\\n\''\n \''251|\\n\''\n \''252|    def _turn_instruction(self,
  idx: int) -> str:\\n\''\n \''253|        return f"""\\n\''\n \''254|You are at continuous
  writing stage, writing text content into file \''\n \''{self.filename} continuously.
  \\n\''\n \''255|The block you are editing are from the origin content line \''\n
  \''`{self.start}` to `{self.end}`.\\n\''\n "256|All your generation will directly
  write into the block, SO DON\''T WRITE "\n \''ANYTHING not about the file. \\n\''\n
  \''257|\\n\''\n \''258|And Current round is {idx}/{self.max_round}. \\n\''\n \''259|\\n\''\n
  \''260|When you put end tokens `{self.end_token}` at end of your output, means \''\n
  \''all your output is done, and the loop will be break.\\n\''\n \''261|The end tokens
  will not record to the block you are editing.\\n\''\n \''262|Only use end tokens
  when you complete the whole writing. \\n\''\n \''263|\\n\''\n \''264|Follow the
  instruction: \\n\''\n \''265|```\\n\''\n \''266|{self.instruction}\\n\''\n \''267|```\\n\''\n
  \''268|\\n\''\n \''269|now start your writing:\\n\''\n \''270|"""\\n\''\n \''271|\\n\''\n
  \''272|    def destroy(self):\\n\''\n \''273|        pass\\n\''\n \''274|\\n\''\n
  \''275|\\n\''\n \''276|class DirectoryImpl(Directory):\\n\''\n \''277|    default_ignores:
  ClassVar[List[str]] = [\\n\''\n \''278|        ".gitignore",\\n\''\n \''279|        DirectoryData.relative_path,\\n\''\n
  \''280|        "__pycache__",\\n\''\n \''281|    ]\\n\''\n \''282|\\n\''\n \''283|    def
  __init__(self, path: pathlib.Path, ignores: List[str] = None, \''\n \''relative:
  Union[str, None] = None):\\n\''\n \''284|        self.path = path\\n\''\n \''285|        if
  relative is None:\\n\''\n \''286|            relative = self.path.absolute()\\n\''\n
  \''287|        self.relative = relative\\n\''\n \''288|        self.data = DirectoryData.get_from(path)\\n\''\n
  "289|        self.ctx = self.data.get_dev_context(\''.\'')\\n"\n \''290|        if
  not self.ctx.desc:\\n\''\n \''291|            self.ctx.desc = "dev context of this
  directory"\\n\''\n \''292|        if ignores is None:\\n\''\n \''293|            ignores
  = self.default_ignores.copy()\\n\''\n \''294|        gitignore = path.joinpath(".gitignore")\\n\''\n
  \''295|        if gitignore.exists():\\n\''\n \''296|            with open(gitignore,
  "r") as f:\\n\''\n \''297|                content = f.read()\\n\''\n \''298|                ignores.extend(content.splitlines())\\n\''\n
  \''299|        self._ignores = []\\n\''\n \''300|        for ignore in ignores:\\n\''\n
  \''301|            ignore = ignore.strip()\\n\''\n "302|            if ignore.startswith(\''#\''):\\n"\n
  \''303|                continue\\n\''\n \''304|            self._ignores.append(ignore)\\n\''\n
  \''305|\\n\''\n \''306|    def get_ignores(self) -> List[str]:\\n\''\n \''307|        return
  self._ignores\\n\''\n \''308|\\n\''\n \''309|    def full_context(self) -> str:\\n\''\n
  \''310|        editing_context = ""\\n\''\n \''311|        if self.data.editing:\\n\''\n
  \''312|            try:\\n\''\n \''313|                editing_context = f"currently
  editing file is \''\n \''`{self.data.editing}`, the content (with line number) \''\n
  \''are:\\\\n\\\\n<editing>\\\\n\\\\n"\\n\''\n \''314|                editing_context
  += \''\n \''self.edit(self.data.editing).read(line_number=True, detail=True)\\n\''\n
  \''315|                editing_context += "</editing>\\\\n"\\n\''\n \''316|            except
  Exception as e:\\n\''\n \''317|                self.data.editing = None\\n\''\n
  \''318|\\n\''\n \''319|        return f"""\\n\''\n \''320|full context of the Directory
  instance:\\n\''\n \''321|\\n\''\n \''322|<Directory path=`{self.path}`>\\n\''\n
  \''323|\\n\''\n \''324|The sub-files and sub-dirs of the current directory are as
  follows \''\n \''(recursion depth 2).\\n\''\n \''325|```\\n\''\n \''326|{self.lists(recursion=2)}\\n\''\n
  \''327|```\\n\''\n \''328|\\n\''\n \''329|DevContext at `Directory.ctx` are: \\n\''\n
  \''330|<dev-context>\\n\''\n \''331|{self.ctx.full_context()}\\n\''\n \''332|</dev-context>\\n\''\n
  \''333|\\n\''\n \''334|all the available dev contexts from name (or path) to description
  are: \\n\''\n \''335|```yaml\\n\''\n \''336|{yaml_pretty_dump(self.existing_dev_contexts())}\\n\''\n
  \''337|```\\n\''\n \''338|\\n\''\n \''339|{editing_context}\\n\''\n \''340|</Directory>\\n\''\n
  \''341|"""\\n\''\n \''342|\\n\''\n \''343|    def dev_contexts(self) -> Dict[str,
  PyDevCtx]:\\n\''\n \''344|        return self.data.dev_contexts\\n\''\n \''345|\\n\''\n
  \''346|    def existing_dev_contexts(self) -> Dict[str, str]:\\n\''\n \''347|        return
  {ctx.title: ctx.desc for ctx in \''\n \''self.data.dev_contexts.values()}\\n\''\n
  \''348|\\n\''\n \''349|    def new_dev_context(self, title: str, desc: str) -> PyDevCtxData:\\n\''\n
  \''350|        ctx = PyDevCtxData(title=title, desc=desc)\\n\''\n \''351|        self.data.dev_contexts[title]
  = ctx\\n\''\n \''352|        return ctx\\n\''\n \''353|\\n\''\n \''354|    def lists(self,
  *, prefix: str = "", recursion: int = 0, files: bool \''\n \''= True, dirs: bool
  = True) -> str:\\n\''\n \''355|        getter = DirectoryFileDescriptionGetter(self.path)\\n\''\n
  \''356|        return generate_directory_tree(\\n\''\n \''357|            self.path,\\n\''\n
  \''358|            prefix=prefix,\\n\''\n \''359|            recursion=recursion,\\n\''\n
  \''360|            descriptions=getter,\\n\''\n \''361|            ignores=self._ignores,\\n\''\n
  \''362|            files=files,\\n\''\n \''363|            dirs=dirs,\\n\''\n \''364|        )\\n\''\n
  \''365|\\n\''\n \''366|    def subdir(self, path: str) -> Self:\\n\''\n \''367|        real_path
  = self.path.joinpath(path)\\n\''\n \''368|        try:\\n\''\n \''369|            real_path.relative_to(self.path)\\n\''\n
  \''370|        except ValueError:\\n\''\n \''371|            raise ValueError(f"\\\''{path}\\\''
  is not a sub directory")\\n\''\n \''372|        if not real_path.is_dir():\\n\''\n
  \''373|            raise ValueError(f"\\\''{path}\\\'' is not a directory")\\n\''\n
  \''374|        if not real_path.exists():\\n\''\n \''375|            raise ValueError(f"\\\''{path}\\\''
  does not exist")\\n\''\n \''376|        return DirectoryImpl(real_path, self._ignores)\\n\''\n
  \''377|\\n\''\n \''378|    def describe(self, path: str, desc: str) -> None:\\n\''\n
  \''379|        self.data.file_desc[path] = desc\\n\''\n \''380|\\n\''\n \''381|    def
  mkdir(self, subdir: str, desc: str, dev_ctx: Union[PyDevCtx, \''\n \''None] = None)
  -> bool:\\n\''\n \''382|        real_subdir = self.path.joinpath(subdir).absolute()\\n\''\n
  \''383|        real_subdir.relative_to(self.path)\\n\''\n \''384|        if real_subdir.exists():\\n\''\n
  \''385|            return False\\n\''\n \''386|        real_subdir.mkdir()\\n\''\n
  \''387|        data = DirectoryData.get_from(real_subdir)\\n\''\n \''388|        data.set_description(desc=desc)\\n\''\n
  \''389|        if dev_ctx is not None:\\n\''\n \''390|            ctx = PyDevCtxData(**dev_ctx.model_dump())\\n\''\n
  \''391|            data.set_dev_context(ctx)\\n\''\n \''392|        return True\\n\''\n
  \''393|\\n\''\n \''394|    def touch(self, sub_file: str, desc: str, dev_ctx: Union[PyDevCtx,
  \''\n \''None] = None) -> bool:\\n\''\n \''395|        real_sub_path = self.path.joinpath(sub_file).absolute()\\n\''\n
  \''396|        real_sub_path.relative_to(self.path)\\n\''\n \''397|        if real_sub_path.exists():\\n\''\n
  \''398|            return False\\n\''\n \''399|        real_sub_path.touch()\\n\''\n
  \''400|        data = DirectoryData.get_from(real_sub_path.parent)\\n\''\n \''401|        data.set_description(desc=desc,
  key=real_sub_path.name)\\n\''\n \''402|        if dev_ctx is not None:\\n\''\n \''403|            ctx
  = PyDevCtxData(**dev_ctx.model_dump())\\n\''\n \''404|            data.set_dev_context(ctx,
  name=real_sub_path.name)\\n\''\n \''405|        return True\\n\''\n \''406|\\n\''\n
  \''407|    def focus(self, file_path: Union[str, None]) -> Union[File, None]:\\n\''\n
  \''408|        if file_path is None:\\n\''\n \''409|            self.data.editing
  = None\\n\''\n \''410|            return None\\n\''\n \''411|        file = self.edit(file_path)\\n\''\n
  \''412|        self.data.editing = file_path\\n\''\n \''413|        return file\\n\''\n
  \''414|\\n\''\n \''415|    def edit(self, file_path: str) -> FileImpl:\\n\''\n \''416|        real_path
  = self.path.joinpath(file_path).absolute()\\n\''\n \''417|        if not real_path.is_file():\\n\''\n
  \''418|            raise ValueError(f"\\\''{file_path}\\\'' is not a file")\\n\''\n
  \''419|        relative_path_obj = real_path.relative_to(self.path)\\n\''\n \''420|        relative_path
  = str(relative_path_obj)\\n\''\n \''421|        dev_context = self.data.get_dev_context(relative_path)\\n\''\n
  \''422|        return FileImpl(\\n\''\n \''423|            real_path,\\n\''\n \''424|            dev_ctx=dev_context,\\n\''\n
  \''425|        )\\n\''\n \''426|\\n\''\n \''427|    def save_dev_contexts(self):\\n\''\n
  \''428|        self.data.save_to(self.path)\\n\''\n \''429|\\n\''\n \''430|\\n\''\n
  \''431|if __name__ == "__main__":\\n\''\n \''432|    current = pathlib.Path(__file__)\\n\''\n
  \''433|    d = DirectoryImpl(current.parent)\\n\''\n \''434|    d.focus(current.name)\\n\''\n
  \''435|    print(d.lists())\\n\''\n \''436|    print(d.ctx.full_context())\\n\''\n
  \''437|    d.describe("abcd.py", "abstract classes")\\n\''\n \''438|    d.save_dev_contexts()\\n\''\n
  \''439|\\n\''\n \''440|    print("+++++")\\n\''\n \''441|    print(d.dev_contexts())\\n\''\n
  \''442|\\n\''\n \''443|    print("+++++")\\n\''\n \''444|    print(d.full_context())\\n\''\n
  \''445|\\n\''\n \''446|    editing = d.edit(current.name)\\n\''\n \''447|    print("+++++++++++
  path", editing.path)\\n\''\n \''448|\\n\''\n \''449|    editing.write("hello", append=True)\\n\''\n
  \''450|    insert_content(editing.path, "world", -1, -1)\'')\n\n```'', ''role'':
  ''tool'', ''tool_call_id'': ''call_v7H1rDOyNULWN6iGMsCQApVB''}, {''content'': ''##
  observation on turn 8\n\n### `file_content`\n\n```\n(\''1|from typing import Dict,
  ClassVar, List, Union\\n\''\n \''2|\\n\''\n \''3|from typing_extensions import Self\\n\''\n
  \''4|import pathlib\\n\''\n \''5|\\n\''\n \''6|from ghostos import Operator, Session\\n\''\n
  \''7|from ghostos.libraries.project.abcd import Directory, File, PyDevCtx\\n\''\n
  \''8|from ghostos.libraries.project.dev_context import PyDevCtxData\\n\''\n \''9|from
  ghostos.contracts.configs import YamlConfig\\n\''\n \''10|from ghostos.core.messages
  import MessageType, Role\\n\''\n \''11|from ghostos_common.helpers import generate_directory_tree,
  \''\n \''yaml_pretty_dump, get_module_fullname_from_path\\n\''\n \''12|from ghostos_common.helpers.files
  import DescriptionsGetter\\n\''\n \''13|from ghostos_moss import moss_runtime_ctx\\n\''\n
  \''14|from pydantic import Field\\n\''\n \''15|\\n\''\n \''16|\\n\''\n \''17|class
  DirectoryData(YamlConfig):\\n\''\n \''18|    relative_path = ".ghostos_dir.yml"\\n\''\n
  \''19|\\n\''\n \''20|    dev_contexts: Dict[str, PyDevCtxData] = Field(\\n\''\n
  \''21|        default_factory=dict,\\n\''\n \''22|        description="the saved
  dev context from title to value",\\n\''\n \''23|    )\\n\''\n \''24|    file_desc:
  Dict[str, str] = Field(\\n\''\n \''25|        default_factory=lambda: {".": ""},\\n\''\n
  \''26|    )\\n\''\n \''27|    editing: Union[str, None] = Field(\\n\''\n \''28|        default=None,\\n\''\n
  \''29|        description="the editing filename relative to the current \''\n \''directory",\\n\''\n
  \''30|    )\\n\''\n \''31|\\n\''\n \''32|    def save_to(self, path: pathlib.Path)
  -> None:\\n\''\n \''33|        if not path.is_dir():\\n\''\n "34|            raise
  NotADirectoryError(f\''{path} is not a directory\'')\\n"\n \''35|        content
  = \''\n \''yaml_pretty_dump(self.model_dump(exclude_defaults=True))\\n\''\n \''36|        file
  = path.joinpath(self.relative_path)\\n\''\n \''37|        with open(file, "w") as
  f:\\n\''\n \''38|            f.write(content)\\n\''\n \''39|\\n\''\n \''40|    def
  get_description(self, key=".") -> str:\\n\''\n \''41|        return self.file_desc.get(key,
  "")\\n\''\n \''42|\\n\''\n \''43|    def set_description(self, key=".", desc: str
  = "") -> None:\\n\''\n \''44|        self.file_desc[key] = desc\\n\''\n \''45|\\n\''\n
  \''46|    @classmethod\\n\''\n \''47|    def get_from(cls, path: pathlib.Path) ->
  "DirectoryData":\\n\''\n \''48|        if not path.is_dir():\\n\''\n "49|            raise
  NotADirectoryError(f\''{path} is not a directory\'')\\n"\n \''50|        file =
  path.joinpath(cls.relative_path)\\n\''\n \''51|        if not file.exists():\\n\''\n
  \''52|            return cls()\\n\''\n \''53|        with open(file, "r") as f:\\n\''\n
  \''54|            content = f.read()\\n\''\n \''55|            return cls.unmarshal(content)\\n\''\n
  \''56|\\n\''\n \''57|    def get_dev_context(self, name: str) -> PyDevCtxData:\\n\''\n
  \''58|        if name in self.dev_contexts:\\n\''\n \''59|            return self.dev_contexts[name]\\n\''\n
  \''60|        data = PyDevCtxData(title=name)\\n\''\n \''61|        self.dev_contexts[name]
  = data\\n\''\n \''62|        return data\\n\''\n \''63|\\n\''\n \''64|    def set_dev_context(self,
  data: PyDevCtxData, name: str = ".") -> \''\n \''None:\\n\''\n \''65|        self.dev_contexts[name]
  = data\\n\''\n \''66|\\n\''\n \''67|\\n\''\n \''68|class DirectoryFileDescriptionGetter(DescriptionsGetter):\\n\''\n
  \''69|\\n\''\n \''70|    def __init__(self, root: pathlib.Path):\\n\''\n \''71|        self.root
  = root\\n\''\n \''72|        self._cached = {}\\n\''\n \''73|\\n\''\n \''74|    def
  get(self, path: pathlib.Path, default: Union[str, None] = None) \''\n \''-> Union[str,
  None]:\\n\''\n \''75|        real_path = self.root.joinpath(path).absolute()\\n\''\n
  \''76|        if real_path in self._cached:\\n\''\n \''77|            return self._cached[real_path]\\n\''\n
  \''78|        value = self._get(real_path, default)\\n\''\n \''79|        self._cached[real_path]
  = value\\n\''\n \''80|        return value\\n\''\n \''81|\\n\''\n \''82|    def
  _get(self, path: pathlib.Path, default: Union[str, None] = None) \''\n \''-> Union[str,
  None]:\\n\''\n \''83|        if path.is_dir():\\n\''\n \''84|            return
  DirectoryData.get_from(path).get_description()\\n\''\n \''85|        elif path.is_file():\\n\''\n
  \''86|            return \''\n \''DirectoryData.get_from(path.parent).get_description(path.name)\\n\''\n
  \''87|        return default\\n\''\n \''88|\\n\''\n \''89|\\n\''\n \''90|class FileImpl(File):\\n\''\n
  \''91|    allow_ext: ClassVar[List[str]] = [\\n\''\n \''92|        ".md", ".txt",
  ".py", ".ipynb", ".ts", ".php", ".html", ".js", \''\n \''".css", ".yaml",\\n\''\n
  \''93|        ".yml", ".toml", ".json"\\n\''\n \''94|    ]\\n\''\n \''95|\\n\''\n
  \''96|    def __init__(\\n\''\n \''97|            self,\\n\''\n \''98|            filepath:
  pathlib.Path,\\n\''\n \''99|            dev_ctx: PyDevCtxData,\\n\''\n \''100|    ):\\n\''\n
  \''101|        if filepath.is_dir():\\n\''\n \''102|            raise TypeError(f"{filepath}
  is not a directory")\\n\''\n \''103|        self.path = filepath\\n\''\n \''104|        self.ctx
  = dev_ctx\\n\''\n \''105|        self.max_read_size = 5000\\n\''\n \''106|\\n\''\n
  \''107|    def read(self, line_number: bool = True, detail: bool = True) -> \''\n
  \''str:\\n\''\n \''108|        allowed = self.is_readable()\\n\''\n \''109|        for
  ext in self.allow_ext:\\n\''\n \''110|            if self.path.name.endswith(ext):\\n\''\n
  \''111|                allowed = True\\n\''\n \''112|        if not allowed:\\n\''\n
  \''113|            return f"File {self.path.name} are not readable now"\\n\''\n
  \''114|\\n\''\n \''115|        content = self.path.read_text()\\n\''\n \''116|        length
  = len(content)\\n\''\n \''117|        suffix = ""\\n\''\n \''118|        if length
  > self.max_read_size:\\n\''\n \''119|            content = content[:self.max_read_size]\\n\''\n
  \''120|            suffix = "..."\\n\''\n \''121|        if line_number:\\n\''\n
  \''122|            lines = content.splitlines()\\n\''\n \''123|            updated
  = []\\n\''\n \''124|            idx = 0\\n\''\n \''125|            for line in lines:\\n\''\n
  \''126|                idx += 1\\n\''\n \''127|                updated.append(f"{idx}|{line}")\\n\''\n
  \''128|            content = "\\\\n".join(updated)\\n\''\n \''129|        if not
  detail:\\n\''\n \''130|            return content\\n\''\n \''131|\\n\''\n \''132|        modulename
  = get_module_fullname_from_path(str(self.path), \''\n \''use_longest_match=True)\\n\''\n
  \''133|        if modulename is not None:\\n\''\n \''134|            py_info = f"\\\\n\\\\nfile
  is python module `{modulename}`."\\n\''\n "135|            return (f\''content of
  file {self.path} are:\''\\n"\n "136|                    f\''\\\\n\\\\n<content "\n
  \''length="{length}">{content}{suffix}</content>{py_info}\\\'')\\n\''\n \''137|\\n\''\n
  "138|        return f\''<content "\n \''length="{length}">{content}{suffix}</content>\\\''\\n\''\n
  \''139|\\n\''\n \''140|    def is_readable(self):\\n\''\n \''141|        allowed
  = False\\n\''\n \''142|        for ext in self.allow_ext:\\n\''\n \''143|            if
  self.path.name.endswith(ext):\\n\''\n \''144|                allowed = True\\n\''\n
  \''145|        return allowed\\n\''\n \''146|\\n\''\n \''147|    def write(self,
  content: str, append: bool = False) -> None:\\n\''\n \''148|        if not self.is_readable():\\n\''\n
  "149|            raise NotImplementedError(f\''{self.path} is not writable "\n "yet\'')\\n"\n
  \''150|\\n\''\n \''151|        origin = str(self.path.read_text())\\n\''\n \''152|        if
  append:\\n\''\n \''153|            content = origin + "\\\\n" + content\\n\''\n
  \''154|        with open(self.path, "w") as f:\\n\''\n \''155|            f.write(content)\\n\''\n
  \''156|\\n\''\n \''157|    def insert(self, content: str, start: int = -1, end:
  int = -1) -> \''\n \''None:\\n\''\n \''158|        if not self.is_readable():\\n\''\n
  "159|            raise NotImplementedError(f\''{self.path} is not writable "\n "yet\'')\\n"\n
  \''160|\\n\''\n \''161|        insert_content(self.path, content, start, end)\\n\''\n
  \''162|\\n\''\n \''163|    def continuous_write(self, instruction: str, start: int
  = -1, end: \''\n \''int = 0, max_round: int = 10) -> Operator:\\n\''\n \''164|        if
  not self.is_readable():\\n\''\n "165|            raise NotImplementedError(f\''{self.path}
  is not writable "\n "yet\'')\\n"\n \''166|\\n\''\n \''167|        return ContinuousWritingFileOperator(\\n\''\n
  \''168|            filepath=self.path,\\n\''\n \''169|            instruction=instruction,\\n\''\n
  \''170|            start=start,\\n\''\n \''171|            end=end,\\n\''\n \''172|            max_round=max_round,\\n\''\n
  \''173|        )\\n\''\n \''174|\\n\''\n \''175|\\n\''\n \''176|def insert_content(path:
  pathlib.Path, content: str, start: int, end: \''\n \''int) -> None:\\n\''\n \''177|    origin
  = path.read_text()\\n\''\n \''178|    lines = origin.splitlines()\\n\''\n \''179|    before
  = []\\n\''\n \''180|    after = []\\n\''\n \''181|    while start < 0 < len(lines):\\n\''\n
  \''182|        start = len(lines) + start + 1\\n\''\n \''183|    while end < 0 <
  len(lines):\\n\''\n \''184|        end = len(lines) + end + 1\\n\''\n \''185|\\n\''\n
  \''186|    idx = 0\\n\''\n \''187|    for line in lines:\\n\''\n \''188|        idx
  += 1\\n\''\n \''189|        if idx <= start:\\n\''\n \''190|            before.append(line)\\n\''\n
  \''191|        elif idx >= end and idx > start:\\n\''\n \''192|            after.append(line)\\n\''\n
  \''193|    before.extend([content])\\n\''\n \''194|    before.extend(after)\\n\''\n
  \''195|    with open(path, "w") as f:\\n\''\n \''196|        f.write("\\\\n".join(before))\\n\''\n
  \''197|\\n\''\n \''198|\\n\''\n \''199|class ContinuousWritingFileOperator(Operator):\\n\''\n
  \''200|\\n\''\n \''201|    def __init__(\\n\''\n \''202|            self,\\n\''\n
  \''203|            filepath: pathlib.Path,\\n\''\n \''204|            instruction:
  str,\\n\''\n \''205|            start: int,\\n\''\n \''206|            end: int,\\n\''\n
  \''207|            max_round: int,\\n\''\n \''208|            end_token: str = "<end-continuous-writing>",\\n\''\n
  \''209|    ):\\n\''\n \''210|        self.filepath = filepath\\n\''\n \''211|        self.instruction
  = instruction\\n\''\n \''212|        self.start = start\\n\''\n \''213|        self.end
  = end\\n\''\n \''214|        self.contents = []\\n\''\n \''215|        self.max_round
  = max_round\\n\''\n \''216|        self.end_token = end_token\\n\''\n \''217|        self.filename
  = self.filepath.name\\n\''\n \''218|\\n\''\n \''219|    def run(self, session: Session)
  -> Union[Operator, None]:\\n\''\n \''220|        llm_api = session.ghost_driver.get_llm_api(session)\\n\''\n
  \''221|        prompt = session.ghost_driver.get_current_prompt(session)\\n\''\n
  \''222|        idx = 0\\n\''\n \''223|        added = []\\n\''\n \''224|        while
  idx < self.max_round:\\n\''\n \''225|            _prompt = prompt.model_copy(deep=True)\\n\''\n
  \''226|            _prompt.clear_callable()\\n\''\n \''227|            _prompt.added.extend(added)\\n\''\n
  \''228|            \''\n \''_prompt.added.append(Role.new_system(self._turn_instruction(idx)))\\n\''\n
  \''229|\\n\''\n \''230|            items = llm_api.deliver_chat_completion(_prompt,
  \''\n \''stream=session.allow_streaming())\\n\''\n \''231|            messages,
  callers = session.respond(items)\\n\''\n \''232|            has_end_token = False\\n\''\n
  \''233|            for msg in messages:\\n\''\n \''234|                if not MessageType.is_text(msg):\\n\''\n
  \''235|                    continue\\n\''\n \''236|                if msg.content.endswith(self.end_token):\\n\''\n
  \''237|                    has_end_token = True\\n\''\n \''238|                    replaced
  = msg.content.replace(self.end_token, "")\\n\''\n \''239|                    msg.memory
  = msg.content\\n\''\n \''240|                    msg.content = replaced\\n\''\n
  \''241|                    added.append(msg)\\n\''\n \''242|                self.contents.append(msg.content)\\n\''\n
  \''243|            if has_end_token:\\n\''\n \''244|                break\\n\''\n
  \''245|        # do insert.\\n\''\n \''246|        insert_content(self.filepath,
  "\\\\n".join(self.contents), \''\n \''self.start, self.end)\\n\''\n \''247|        return
  session.mindflow().think(\\n\''\n \''248|            Role.new_system(\\n\''\n \''249|                f"continuous
  writing on {self.filename} at {self.start} \''\n \''to {self.end} is done after
  {idx} round"),\\n\''\n \''250|        )\\n\''\n \''251|\\n\''\n \''252|    def _turn_instruction(self,
  idx: int) -> str:\\n\''\n \''253|        return f"""\\n\''\n \''254|You are at continuous
  writing stage, writing text content into file \''\n \''{self.filename} continuously.
  \\n\''\n \''255|The block you are editing are from the origin content line \''\n
  \''`{self.start}` to `{self.end}`.\\n\''\n "256|All your generation will directly
  write into the block, SO DON\''T WRITE "\n \''ANYTHING not about the file. \\n\''\n
  \''257|\\n\''\n \''258|And Current round is {idx}/{self.max_round}. \\n\''\n \''259|\\n\''\n
  \''260|When you put end tokens `{self.end_token}` at end of your output, means \''\n
  \''all your output is done, and the loop will be break.\\n\''\n \''261|The end tokens
  will not record to the block you are editing.\\n\''\n \''262|Only use end tokens
  when you complete the whole writing. \\n\''\n \''263|\\n\''\n \''264|Follow the
  instruction: \\n\''\n \''265|```\\n\''\n \''266|{self.instruction}\\n\''\n \''267|```\\n\''\n
  \''268|\\n\''\n \''269|now start your writing:\\n\''\n \''270|"""\\n\''\n \''271|\\n\''\n
  \''272|    def destroy(self):\\n\''\n \''273|        pass\\n\''\n \''274|\\n\''\n
  \''275|\\n\''\n \''276|class DirectoryImpl(Directory):\\n\''\n \''277|    default_ignores:
  ClassVar[List[str]] = [\\n\''\n \''278|        ".gitignore",\\n\''\n \''279|        DirectoryData.relative_path,\\n\''\n
  \''280|        "__pycache__",\\n\''\n \''281|    ]\\n\''\n \''282|\\n\''\n \''283|    def
  __init__(self, path: pathlib.Path, ignores: List[str] = None, \''\n \''relative:
  Union[str, None] = None):\\n\''\n \''284|        self.path = path\\n\''\n \''285|        if
  relative is None:\\n\''\n \''286|            relative = self.path.absolute()\\n\''\n
  \''287|        self.relative = relative\\n\''\n \''288|        self.data = DirectoryData.get_from(path)\\n\''\n
  "289|        self.ctx = self.data.get_dev_context(\''.\'')\\n"\n \''290|        if
  not self.ctx.desc:\\n\''\n \''291|            self.ctx.desc = "dev context of this
  directory"\\n\''\n \''292|        if ignores is None:\\n\''\n \''293|            ignores
  = self.default_ignores.copy()\\n\''\n \''294|        gitignore = path.joinpath(".gitignore")\\n\''\n
  \''295|        if gitignore.exists():\\n\''\n \''296|            with open(gitignore,
  "r") as f:\\n\''\n \''297|                content = f.read()\\n\''\n \''298|                ignores.extend(content.splitlines())\\n\''\n
  \''299|        self._ignores = []\\n\''\n \''300|        for ignore in ignores:\\n\''\n
  \''301|            ignore = ignore.strip()\\n\''\n "302|            if ignore.startswith(\''#\''):\\n"\n
  \''303|                continue\\n\''\n \''304|            self._ignores.append(ignore)\\n\''\n
  \''305|\\n\''\n \''306|    def get_ignores(self) -> List[str]:\\n\''\n \''307|        return
  self._ignores\\n\''\n \''308|\\n\''\n \''309|    def full_context(self) -> str:\\n\''\n
  \''310|        editing_context = ""\\n\''\n \''311|        if self.data.editing:\\n\''\n
  \''312|            try:\\n\''\n \''313|                editing_context = f"currently
  editing file is \''\n \''`{self.data.editing}`, the content (with line number) \''\n
  \''are:\\\\n\\\\n<editing>\\\\n\\\\n"\\n\''\n \''314|                editing_context
  += \''\n \''self.edit(self.data.editing).read(line_number=True, detail=True)\\n\''\n
  \''315|                editing_context += "</editing>\\\\n"\\n\''\n \''316|            except
  Exception as e:\\n\''\n \''317|                self.data.editing = None\\n\''\n
  \''318|\\n\''\n \''319|        return f"""\\n\''\n \''320|full context of the Directory
  instance:\\n\''\n \''321|\\n\''\n \''322|<Directory path=`{self.path}`>\\n\''\n
  \''323|\\n\''\n \''324|The sub-files and sub-dirs of the current directory are as
  follows \''\n \''(recursion depth 2).\\n\''\n \''325|```\\n\''\n \''326|{self.lists(recursion=2)}\\n\''\n
  \''327|```\\n\''\n \''328|\\n\''\n \''329|DevContext at `Directory.ctx` are: \\n\''\n
  \''330|<dev-context>\\n\''\n \''331|{self.ctx.full_context()}\\n\''\n \''332|</dev-context>\\n\''\n
  \''333|\\n\''\n \''334|all the available dev contexts from name (or path) to description
  are: \\n\''\n \''335|```yaml\\n\''\n \''336|{yaml_pretty_dump(self.existing_dev_contexts())}\\n\''\n
  \''337|```\\n\''\n \''338|\\n\''\n \''339|{editing_context}\\n\''\n \''340|</Directory>\\n\''\n
  \''341|"""\\n\''\n \''342|\\n\''\n \''343|    def dev_contexts(self) -> Dict[str,
  PyDevCtx]:\\n\''\n \''344|        return self.data.dev_contexts\\n\''\n \''345|\\n\''\n
  \''346|    def existing_dev_contexts(self) -> Dict[str, str]:\\n\''\n \''347|        return
  {ctx.title: ctx.desc for ctx in \''\n \''self.data.dev_contexts.values()}\\n\''\n
  \''348|\\n\''\n \''349|    def new_dev_context(self, title: str, desc: str) -> PyDevCtxData:\\n\''\n
  \''350|        ctx = PyDevCtxData(title=title, desc=desc)\\n\''\n \''351|        self.data.dev_contexts[title]
  = ctx\\n\''\n \''352|        return ctx\\n\''\n \''353|\\n\''\n \''354|    def lists(self,
  *, prefix: str = "", recursion: int = 0, files: bool \''\n \''= True, dirs: bool
  = True) -> str:\\n\''\n \''355|        getter = DirectoryFileDescriptionGetter(self.path)\\n\''\n
  \''356|        return generate_directory_tree(\\n\''\n \''357|            self.path,\\n\''\n
  \''358|            prefix=prefix,\\n\''\n \''359|            recursion=recursion,\\n\''\n
  \''360|            descriptions=getter,\\n\''\n \''361|            ignores=self._ignores,\\n\''\n
  \''362|            files=files,\\n\''\n \''363|            dirs=dirs,\\n\''\n \''364|        )\\n\''\n
  \''365|\\n\''\n \''366|    def subdir(self, path: str) -> Self:\\n\''\n \''367|        real_path
  = self.path.joinpath(path)\\n\''\n \''368|        try:\\n\''\n \''369|            real_path.relative_to(self.path)\\n\''\n
  \''370|        except ValueError:\\n\''\n \''371|            raise ValueError(f"\\\''{path}\\\''
  is not a sub directory")\\n\''\n \''372|        if not real_path.is_dir():\\n\''\n
  \''373|            raise ValueError(f"\\\''{path}\\\'' is not a directory")\\n\''\n
  \''374|        if not real_path.exists():\\n\''\n \''375|            raise ValueError(f"\\\''{path}\\\''
  does not exist")\\n\''\n \''376|        return DirectoryImpl(real_path, self._ignores)\\n\''\n
  \''377|\\n\''\n \''378|    def describe(self, path: str, desc: str) -> None:\\n\''\n
  \''379|        self.data.file_desc[path] = desc\\n\''\n \''380|\\n\''\n \''381|    def
  mkdir(self, subdir: str, desc: str, dev_ctx: Union[PyDevCtx, \''\n \''None] = None)
  -> bool:\\n\''\n \''382|        real_subdir = self.path.joinpath(subdir).absolute()\\n\''\n
  \''383|        real_subdir.relative_to(self.path)\\n\''\n \''384|        if real_subdir.exists():\\n\''\n
  \''385|            return False\\n\''\n \''386|        real_subdir.mkdir()\\n\''\n
  \''387|        data = DirectoryData.get_from(real_subdir)\\n\''\n \''388|        data.set_description(desc=desc)\\n\''\n
  \''389|        if dev_ctx is not None:\\n\''\n \''390|            ctx = PyDevCtxData(**dev_ctx.model_dump())\\n\''\n
  \''391|            data.set_dev_context(ctx)\\n\''\n \''392|        return True\\n\''\n
  \''393|\\n\''\n \''394|    def touch(self, sub_file: str, desc: str, dev_ctx: Union[PyDevCtx,
  \''\n \''None] = None) -> bool:\\n\''\n \''395|        real_sub_path = self.path.joinpath(sub_file).absolute()\\n\''\n
  \''396|        real_sub_path.relative_to(self.path)\\n\''\n \''397|        if real_sub_path.exists():\\n\''\n
  \''398|            return False\\n\''\n \''399|        real_sub_path.touch()\\n\''\n
  \''400|        data = DirectoryData.get_from(real_sub_path.parent)\\n\''\n \''401|        data.set_description(desc=desc,
  key=real_sub_path.name)\\n\''\n \''402|        if dev_ctx is not None:\\n\''\n \''403|            ctx
  = PyDevCtxData(**dev_ctx.model_dump())\\n\''\n \''404|            data.set_dev_context(ctx,
  name=real_sub_path.name)\\n\''\n \''405|        return True\\n\''\n \''406|\\n\''\n
  \''407|    def focus(self, file_path: Union[str, None]) -> Union[File, None]:\\n\''\n
  \''408|        if file_path is None:\\n\''\n \''409|            self.data.editing
  = None\\n\''\n \''410|            return None\\n\''\n \''411|        file = self.edit(file_path)\\n\''\n
  \''412|        self.data.editing = file_path\\n\''\n \''413|        return file\\n\''\n
  \''414|\\n\''\n \''415|    def edit(self, file_path: str) -> FileImpl:\\n\''\n \''416|        real_path
  = self.path.joinpath(file_path).absolute()\\n\''\n \''417|        if not real_path.is_file():\\n\''\n
  \''418|            raise ValueError(f"\\\''{file_path}\\\'' is not a file")\\n\''\n
  \''419|        relative_path_obj = real_path.relative_to(self.path)\\n\''\n \''420|        relative_path
  = str(relative_path_obj)\\n\''\n \''421|        dev_context = self.data.get_dev_context(relative_path)\\n\''\n
  \''422|        return FileImpl(\\n\''\n \''423|            real_path,\\n\''\n \''424|            dev_ctx=dev_context,\\n\''\n
  \''425|        )\\n\''\n \''426|\\n\''\n \''427|    def save_dev_contexts(self):\\n\''\n
  \''428|        self.data.save_to(self.path)\\n\''\n \''429|\\n\''\n \''430|\\n\''\n
  \''431|if __name__ == "__main__":\\n\''\n \''432|    current = pathlib.Path(__file__)\\n\''\n
  \''433|    d = DirectoryImpl(current.parent)\\n\''\n \''434|    d.focus(current.name)\\n\''\n
  \''435|    print(d.lists())\\n\''\n \''436|    print(d.ctx.full_context())\\n\''\n
  \''437|    d.describe("abcd.py", "abstract classes")\\n\''\n \''438|    d.save_dev_contexts()\\n\''\n
  \''439|\\n\''\n \''440|    print("+++++")\\n\''\n \''441|    print(d.dev_contexts())\\n\''\n
  \''442|\\n\''\n \''443|    print("+++++")\\n\''\n \''444|    print(d.full_context())\\n\''\n
  \''445|\\n\''\n \''446|    editing = d.edit(current.name)\\n\''\n \''447|    print("+++++++++++
  path", editing.path)\\n\''\n \''448|\\n\''\n \''449|    editing.write("hello", append=True)\\n\''\n
  \''450|    insert_content(editing.path, "world", -1, -1)\'')\n\n```'', ''role'':
  ''developer''}, {''content'': ''åœ¨æŸ¥çœ‹ `FileImpl` ç±»çš„ `write` æ–¹æ³•æ—¶ï¼Œæ²¡æœ‰æ˜æ˜¾çš„é”™è¯¯ã€‚ä¸è¿‡ï¼Œä¸ºäº†ç¡®ä¿å†™å…¥æ“ä½œæˆåŠŸï¼Œå¯ä»¥æ£€æŸ¥ä»¥ä¸‹å‡ ç‚¹ï¼š\n\n1.
  **æ–‡ä»¶è·¯å¾„å’Œæƒé™**ï¼šç¡®ä¿æ–‡ä»¶è·¯å¾„æ˜¯æ­£ç¡®çš„ï¼Œå¹¶ä¸”ç¨‹åºæœ‰æƒé™å¯¹è¯¥æ–‡ä»¶è¿›è¡Œå†™æ“ä½œã€‚\n\n2. **è¿½åŠ é€»è¾‘**ï¼šåœ¨è¿½åŠ æ¨¡å¼ä¸‹ï¼Œåº”è¯¥æ˜¯å°†æ–°å†…å®¹ä¸åŸæœ‰å†…å®¹åˆå¹¶åå†™å…¥ã€‚å½“å‰é€»è¾‘çœ‹èµ·æ¥æ­£ç¡®ï¼Œä½†å¯ä»¥æ·»åŠ æ—¥å¿—æˆ–è°ƒè¯•ä¿¡æ¯æ¥ç¡®ä¿
  `origin` å’Œ `content` çš„å€¼æ˜¯é¢„æœŸçš„ã€‚\n\n3. **å¼‚å¸¸æ•è·**ï¼šå¯ä»¥åœ¨æ–‡ä»¶å†™å…¥æ“ä½œå‘¨å›´æ·»åŠ å¼‚å¸¸å¤„ç†ï¼Œä»¥æ•è·ä»»ä½•å¯èƒ½çš„IOé”™è¯¯å¹¶è¾“å‡ºè¯¦ç»†ä¿¡æ¯ã€‚\n\nå¦‚æœæ‚¨ç»§ç»­é‡åˆ°é—®é¢˜ï¼Œå»ºè®®æ‰“å°æ—¥å¿—æˆ–æ·»åŠ æ–­ç‚¹ä»¥æŸ¥çœ‹ç¨‹åºæ‰§è¡Œåˆ°çš„å…·ä½“ä½ç½®å’Œå˜é‡çš„å€¼ã€‚è¿™å°†æœ‰åŠ©äºæ›´å¿«åœ°è°ƒè¯•é—®é¢˜ã€‚\n\nå¦‚æœéœ€è¦ï¼Œæˆ‘å¯ä»¥å¸®åŠ©ä¿®æ”¹ä»£ç ä»¥å¢åŠ æ—¥å¿—æˆ–è€…å¼‚å¸¸å¤„ç†ã€‚'',
  ''role'': ''assistant'', ''tool_calls'': None, ''function_call'': None}, {''content'':
  ''ghostos.facade æœ‰å“ªäº›å‡½æ•°?'', ''role'': ''user''}], ''model'': ''gpt-4o'', ''function_call'':
  NOT_GIVEN, ''functions'': NOT_GIVEN, ''tools'': [{''function'': {''name'': ''moss'',
  ''description'': ''Useful to execute code in the python context that MOSS provide
  to you.The code must include a `run` function.'', ''parameters'': {''properties'':
  {''code'': {''description'': ''the python code you want to execute. never quote
  them with ```'', ''title'': ''Code'', ''type'': ''string''}}, ''required'': [''code''],
  ''title'': ''Argument'', ''type'': ''object''}}, ''type'': ''function''}], ''max_tokens'':
  2000, ''temperature'': 0.7, ''n'': 1, ''timeout'': 30.0, ''stream'': True, ''stream_options'':
  {''include_usage'': True}, ''top_p'': NOT_GIVEN}'
