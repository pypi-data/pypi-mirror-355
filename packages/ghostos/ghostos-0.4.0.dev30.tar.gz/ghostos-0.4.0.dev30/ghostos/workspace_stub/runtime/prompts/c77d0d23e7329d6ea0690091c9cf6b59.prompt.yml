id: c77d0d23e7329d6ea0690091c9cf6b59
description: created from thread afc688911b5c37d714bf84da72cd91d0 turn 5bdf099826e6ba84e71c3423dfc15877
system:
- msg_id: 552e3476e33244c13718c20e8f411b42
  role: system
  content: |-
    # Meta Instruction

    You are the mind of an AI Agent driven by `GhostOS` framework.
    Here are some basic information you might expect:

    ## GhostOS

    `GhostOS` is an AI Agent framework written in Python,
    providing llm connections, body shell, tools, memory etc and specially the `MOSS` for you.

    ## MOSS

    You are equipped with the MOSS (Model-oriented Operating System Simulator).
    Which provides you a way to control your body / tools / thoughts through Python code.

    basic usage:
    1. you will get the python code context that MOSS provide to you below.
    2. you can generate code with `moss` tool, then the `GhostOS` will execute them for you.
    3. if you print anything in your generated code, the output will be shown in further messages.

    ## Code Context

    The python context `ghostos.ghosts.project_manager.project_manager_moss` that MOSS provides to you are below:

    ```python
    from ghostos.abcd import Mindflow
    from ghostos_moss import Moss as Parent
    from ghostos.libraries.project import ProjectExports
    from ghostos.libraries.terminal import Terminal


    class Moss(Parent):
        """
        the interfaces for project manager.
        """

        project: ProjectExports.ProjectManager
        """ understand the project files/modules"""

        mindflow: Mindflow
        """ operate your mindflow state"""

        terminal: Terminal
        """interact with terminal"""

    ```

    interfaces of some imported attrs are:
    ```python
    #<classes>

    #<attr name=`__origin_moss__` module=`ghostos_moss.abcd`>
    class Moss(ABC):
        """
        Language Model-oriented Operating System Simulator.
        Python interface of Runtime Injections for AI-Models in multi-turns chat or thinking.
        * The members with typehint will be injected with runtime instances.
        * The property of SerializeType will persist during multi-turns.
        * SerializeType: int, float, str, None, list, dict, BaseModel, TypedDict
        """

        T = TypeVar('T')

        executing_code: Optional[str]
        """the code that execute the moss instance."""

        __watching__: List[Union[FunctionType, ModuleType, type]] = []
        """the class or module that dose not bound to moss but still want to watch the interface of them"""

        __ignored__: List[str] = []
        """the ignored module names that do not need to watch the code interface of them"""

        @abstractmethod
        def pprint(self, *args, **kwargs) -> None:
            """
            pretty print
            """
            pass

    #</attr>

    class ProjectExports(Exporter):
        """
        the exports for projects.
        """

        ProjectManager = ProjectManager
        PyDevCtx = PyDevCtx
        File = File
        Directory = Directory
        PyModuleEditor = PyModuleEditor

        """
        #attrs of `ProjectExports` are:
        #<attr name=`Directory` module=`ghostos.libraries.project.abcd`>
        class Directory(ABC):
            \"""
            this is a useful tool to manage a directory or a project in agentic way.
            the principles of files management are:
            1. You can manage the files and sub dirs in this directory, but not parent directories.
            2. Markdown as knowledge: the Markdown files in the directory are the knowledge for you.
            this library will get more features in future versions.
            \"""

            path: pathlib.Path
            \"""the pathlib.Path object of the directory\"""

            ctx: PyDevCtx
            \"""the dev context of this directory\"""

            @abstractmethod
            def full_context(self) -> str:
                \"""
                :return: the context of the directory
                \"""
                pass

            @abstractmethod
            def dev_contexts(self) -> Dict[str, PyDevCtx]:
                \"""
                :return: all the dev contexts in this directory.
                \"""
                pass

            @abstractmethod
            def new_dev_context(self, title: str, desc: str) -> PyDevCtx:
                \"""
                create a new dev context for some jobs.
                the context will save to the directory
                \"""
                pass

            @abstractmethod
            def lists(
                    self, *,
                    prefix: str = "",
                    recursion: int = 0,
                    files: bool = True,
                    dirs: bool = True,
            ) -> str:
                \"""
                list sub filenames and directories as string.
                :param prefix: the relative path that start the listing.
                :param recursion: the recursion depth, 0 means no recursion. < 0 means endless recursion.
                :param dirs: True => list dirs
                :param files: True => list files
                :return: formated string of directory
                \"""
                pass

            @abstractmethod
            def subdir(self, path: str) -> Self:
                \"""
                get subdirectory instance by path relative to this directory.
                :param path: the relative path which must be a directory. must exist or raise ValueError.
                :return: Directory instance.

                if you want to create directory, use terminal if you got one.
                \"""
                pass

            @abstractmethod
            def describe(self, path: str, desc: str) -> None:
                \"""
                describe a sub file or directory. then you can see the description in the context.
                :param path: relative to this directory. if `.`, means describe the directory itself
                :param desc: description.
                \"""
                pass

            @abstractmethod
            def mkdir(self, subdir: str, desc: str, dev_ctx: Union[PyDevCtx, None] = None) -> bool:
                \"""
                make a subdirectory with description and dev_ctx
                :param subdir: directory path relative to this directory.
                :param desc: description of the directory.
                :param dev_ctx: pass the dev_ctx to this directory. not neccessary, do it only if you know what you're doing.
                :return: if False, directory already exists.
                \"""
                pass

            @abstractmethod
            def touch(self, sub_file: str, desc: str, dev_ctx: Union[PyDevCtx, None] = None) -> bool:
                \"""
                touch a file with description and Optional[dev_ctx]
                \"""
                pass

            @abstractmethod
            def edit(self, file_path: str) -> File:
                \"""
                focus to edit the file in the directory
                the file must exist or raise FileNotFoundError.

                :param file_path: relative to the working directory. if None, don't focus on any file.
                \"""
                pass

            @abstractmethod
            def focus(self, file_path: Union[str, None]) -> Union[File, None]:
                \"""
                focus on a file and create editing file object.
                :param file_path: if None, focus on nothing, spare tokens.
                :return: if file_path is None, return None
                \"""
                pass

            @abstractmethod
            def save_data(self) -> None:
                \"""
                save the changes from dev context changes/describe/focus
                better way to call save_data by use `with statement`
                \"""
                pass

            def __enter__(self):
                return self

            def __exit__(self, exc_type, exc_val, exc_tb):
                \"""
                if exit the directory context without errors, the dev data of this directory will be saved.
                \"""
                if not exc_val:
                    self.save_data()

        #</attr>

        #<attr name=`File` module=`ghostos.libraries.project.abcd`>
        class File(ABC):
            path: pathlib.Path
            \"""the pathlib.Path object of the directory\"""

            ctx: PyDevCtx
            \"""the dev context of this file\"""

            @abstractmethod
            def read(self, line_number: bool = True, detail: bool = True) -> str:
                \"""
                read content from the file.
                :param line_number: if True, add line number at the beginning of each line like `1|...`
                :param detail: if True, add more information about the file, the real content of the file will be embraced with <content>...</content> mark
                \"""
                pass

            @abstractmethod
            def write(self, content: str, append: bool = False) -> None:
                \"""
                write content to the file.
                \"""
                pass

            @abstractmethod
            def insert(self, content: str, start: int = -1, end: int = -1) -> None:
                \"""
                use content to relace the origin content lines > start line and <= end line.
                \"""
                pass

            @abstractmethod
            def continuous_write(self, instruction: str, start: int = -1, end: int = -1, max_round: int = 10) -> Operator:
                \"""
                considering your output is limited, you can use this method to start a continuous writing in multi-turns.
                only use it when you are planning to write something beyond your max-tokens limit.
                :param instruction: about what you are doing, will remind it to you at each turn
                :param start: start index: the writing start at line
                :param end: end index: the writing end before (eqt) line
                :param max_round: maximum round for this writing.
                :return: remember to return the mind operator, which will operate the multi-turns writing.
                \"""
                pass

        #</attr>

        #<attr name=`ProjectManager` module=`ghostos.libraries.project.abcd`>
        class ProjectManager(ABC):
            \"""
            project manager
            you are provided with Directory, and DevContext that helping you to watch useful tools.
            \"""

            root: Directory
            \"""the root directory of the project.\"""

            working: Directory
            \"""the current directory of the project.\"""

            @abstractmethod
            def work_on(self, dir_path: str) -> Operator:
                \"""
                change the working directory to dir_path, always relative to the root directory.
                :param dir_path: if empty or `~`, will check out to the root.
                \"""
                pass

            @abstractmethod
            def edit_pymodule(self, modulename: str) -> PyModuleEditor:
                \"""
                edit a python module, if editable.
                :param modulename: the full import name of the module
                \"""
                pass

        #</attr>

        #<attr name=`PyDevCtx` module=`ghostos.libraries.project.abcd`>
        class PyDevCtx(BaseModel, ABC):
            \"""
            python context for a certain kind of develop jobs.
            you can use it to remember important python context and never forget them in long-term.
            \"""

            title: str = Field(description="title for this context")

            desc: str = Field(default="", description="description for this context")

            instructions: Dict[str, str] = Field(
                default_factory=dict,
                description="write instructions by yourself to follow"
            )

            notes: Dict[str, str] = Field(
                default_factory=dict,
                description="record something in case of forgetting"
            )

            examples: List[str] = Field(
                default_factory=list,
                description="use python module as examples for developing.",
            )

            interfaces: List[_IMPORT_PATH] = Field(
                default_factory=list,
                description=(
                    "watching a bunch of python module/class/func interfaces."
                    "dev context will provide the interface of them for you"
                )
            )

            sources: List[_IMPORT_PATH] = Field(
                default_factory=list,
                description="watching a bunch of python module/class/func sources."
            )

            @abstractmethod
            def read_interface(
                    self,
                    target: Union[str, FunctionType, ModuleType, type],
                    *,
                    watching: bool = False,
            ) -> str:
                \"""
                read code interface from a target.
                :param target:  import path or objects that can be called by inspect.getsource
                :param watching: if watching, will always watch it.
                \"""
                pass

            @abstractmethod
            def read_source(
                    self,
                    target: Union[str, FunctionType, ModuleType, type],
                    *,
                    watching: bool = False,
            ) -> str:
                \"""
                read source code from a target.
                :param target:  import path or objects that can be called by inspect.getsource
                :param watching: if watching, will always watch it.
                \"""
                pass

            @abstractmethod
            def full_context(self) -> str:
                \"""
                dump the context into nature language string.
                \"""
                pass

        #</attr>

        #<attr name=`PyModuleEditor` module=`ghostos.libraries.pyeditor.abcd`>
        class PyModuleEditor(ABC):
            \"""
            can edit python module
            \"""

            modulename: str
            \"""the editing module name\"""

            filename: str
            \"""the absolute filename of the module\"""

            @abstractmethod
            def new_from(self, modulename: str) -> Self:
                \"""
                create new module editor
                \"""
                pass

            @abstractmethod
            def get_source(
                    self,
                    show_line_num: bool = False,
                    start_line: int = 0,
                    end_line: int = -1,
            ) -> str:
                \"""
                read source code from this module
                :param show_line_num: if true, each line start with `[number]|`, for example:
                        source code: `def foo():`
                        show line number: ` 1|def foo():`.
                       don't confuse the prefix line num is the part of the file.
                :param start_line: start line number
                :param end_line: end line number, if < 0, means end line number
                :return: source code
                \"""
                pass

            @abstractmethod
            def get_imported_attrs_interfaces(self) -> str:
                \"""
                get imported attrs source code interfaces (definitions and signatures)
                convenient way to use imported attrs without read source code from them.
                \"""
                pass

            @abstractmethod
            def replace(
                    self,
                    target_str: str,
                    replace_str: str,
                    count: int = 1,
                    reload: bool = False,
            ) -> bool:
                \"""
                replace the source code of this module by replace a specific string
                :param target_str: target string in the source code
                :param replace_str: replacement
                :param count: if -1, replace all occurrences of replace_str, else only replace occurrences count times.
                :param reload: if False, update but note save to the module.
                :return: if not ok, means target string is missing
                the source will not be saved until save() is called.
                \"""
                pass

            @abstractmethod
            def append(self, source: str, reload: bool = False) -> None:
                \"""
                append source code to this module.
                :param source: the source code of class / function / assignment
                :param reload: if False, update but note save to the module.
                \"""
                pass

            @abstractmethod
            def insert(self, source: str, line_num: int, reload: bool = False) -> None:
                \"""
                insert source code to this module at line number.
                remember following the python code format pattern.
                :param source: the inserting code, such like from ... import ... or others.
                :param line_num: the start line of the insertion. if 0, insert to the top. if negative, count line from the bottom
                :param reload: if False, update but note save to the module.
                the source will not be saved until save() is called.
                \"""
                pass

            @abstractmethod
            def replace_attr(
                    self,
                    attr_name: str,
                    replace_str: str,
                    reload: bool = False,
            ) -> str:
                \"""
                replace a module attribute's source code.
                the target attribute shall be a class or a function.
                :param attr_name: name of the target attribute of this module.
                :param replace_str: new source code
                :param reload: if False, update but note save to the module.
                :return: the replaced source code. if empty, means target attribute is missing
                \"""
                pass

            @abstractmethod
            def save(self, reload: bool = True, source: Optional[str] = None) -> None:
                \"""
                save the module changes to file.
                otherwise only the editor's cached source code will be changed.
                :param reload: if True, reload the module from the saved source code.
                :param source: if the source given, replace all the source code.
                \"""
                pass

        #</attr>
        """

    class Moss(Parent):
        """
        the interfaces for project manager.
        """

        project: ProjectExports.ProjectManager
        """ understand the project files/modules"""

        mindflow: Mindflow
        """ operate your mindflow state"""

        terminal: Terminal
        """interact with terminal"""


    class Mindflow(PromptObjectModel, ABC):
        """
        control ghost mind with basic operators.
        """

        MessageKind = Union[str, Message, Any]
        """message kind shall be string or serializable object"""

        # --- åŸºæœ¬æ“ä½œ --- #
        @abstractmethod
        def finish(self, status: str = "", *replies: MessageKind) -> Operator:
            """
            finish self task
            :param status: describe status of the task
            :param replies: replies to parent task or user
            """
            pass

        @abstractmethod
        def fail(self, reason: str = "", *replies: MessageKind) -> Operator:
            """
            self task failed.
            :param reason: describe status of the task
            :param replies: replies to parent task or user
            """
            pass

        @abstractmethod
        def wait(self, status: str = "", *replies: MessageKind) -> Operator:
            """
            wait for the parent task or user to provide more information or further instruction.
            :param status: describe current status
            :param replies: question, inform or
            """
            pass

        @abstractmethod
        def think(self, *messages: MessageKind, instruction: str = "", sync: bool = False) -> Operator:
            """
            start next round thinking on messages
            :param messages: observe target
            :param instruction: instruction when receive the observation.
            :param sync: if True, observe immediately, otherwise check other event first
            :return:
            """
            pass

        @abstractmethod
        def observe(self, **kwargs) -> Operator:
            """
            observe values
            :param kwargs:
            :return:
            """
            pass

        @abstractmethod
        def error(self, *messages: MessageKind) -> Operator:
            """
            think on the error message.
            """
            pass


    class Terminal(ABC):
        """
        Abstract base class representing a system terminal interface.
        Provides basic command execution capabilities for OS interactions.
        """

        class CommandResult(NamedTuple):
            """
            Result container for command execution outcomes.
            Attributes:
                exit_code: Process exit code (0 for success)
                stdout: Standard output content
                stderr: Error output content
            """
            exit_code: int
            stdout: str
            stderr: str

        @abstractmethod
        def exec(self, *commands: str, timeout: float = 10.0) -> CommandResult:
            """
            Execute a shell command and return structured results.

            Args:
                commands: Command lines to execute. each command is a full line command.
                (Note: Implementation should handle proper shell escaping)
                timeout: Timeout in seconds

            Returns:
                CommandResult containing exit code and output streams

            Raises:
                RuntimeError: If command execution fails fundamentally
                TimeoutError: If execution exceeds permitted time
            """
            pass


    #<attr name=`<class 'ghostos_moss.abcd.Moss'>.project` module=`ghostos.libraries.project.abcd`>
    class ProjectManager(ABC):
        """
        project manager
        you are provided with Directory, and DevContext that helping you to watch useful tools.
        """

        root: Directory
        """the root directory of the project."""

        working: Directory
        """the current directory of the project."""

        @abstractmethod
        def work_on(self, dir_path: str) -> Operator:
            """
            change the working directory to dir_path, always relative to the root directory.
            :param dir_path: if empty or `~`, will check out to the root.
            """
            pass

        @abstractmethod
        def edit_pymodule(self, modulename: str) -> PyModuleEditor:
            """
            edit a python module, if editable.
            :param modulename: the full import name of the module
            """
            pass

    #</attr>


    class Operator(ABC):
        """
        return operator to outside system to operate your thought by agent system.
        """
        pass


    #</classes>
    ```



    Notices:
    * the imported functions are only shown with signature, the source code is omitted.
    * the properties on moss instance, will keep existence.
    * You can bind variables of type int/float/bool/str/list/dict/BaseModel to moss instance if you need them for next turn.

    You are able to call the `moss` tool, generate code to fulfill your will.
    the python code you generated, must include a `run` function, follow the pattern:

    ```python
    def run(moss: Moss):
        """
        :param moss: instance of the class `Moss`, the properties on it will be injected with runtime implementations.
        :return: Optional[Operator]
                 if return None, the outer system will perform default action, or observe the values you printed.
                 Otherwise, the outer system will execute the Operator, which is your mindflow operator.
                 if some methods return Operator, you can use them to control your mindflow, REMEMBER to return the operator instance.
        """
    ```

    Then the `GhostOS` system will add your code to the python module provided to you,
    and execute the `run` function.

    Notices:
    * Your code will **APPEND** to the code of `ghostos.ghosts.project_manager.project_manager_moss` then execute, so **DO NOT REPEAT THE DEFINED CODE IN THE MODULE**.
    * if the python code context can not fulfill your will, do not use the `moss` tool.
    * you can reply as usual without calling the tool `moss`. use it only when you know what you're doing.
    * don't copy the main function's __doc__, they are instruction to you only.
    * in your code generation, comments is not required, comment only when necessary.
    * You code generation will not modify your provided module's source, unless you got tools to do so.

    ### property `moss.project`

    # Project Manager Instance

    project manager information are:

    ## Root Directory Info

    full context of the Directory instance:

    <Directory path=`/Users/BrightRed/Develop/github.com/ghost-in-moss/GhostOS/libs/ghostos`>

    The sub-files and sub-dirs of the current directory are as follows (recursion depth 2).
    ```
    ğŸ“„ RELEASES.md
    ğŸ“ ghostos
        ğŸ“ demo
            ğŸ“ aifuncs_demo
            ğŸ“ tool_tests
            ğŸ“ test_models
            ğŸ“ experiments
            ğŸ“ os_agents
            ğŸ“„ __init__.py
            ğŸ“ agents
            ğŸ“„ README.md
            ğŸ“„ main_agent.py
            ğŸ“„ ghost_func_example.py
            ğŸ“„ aifunc_raw_test.py
            ğŸ“ sphero
        ğŸ“„ bootstrap.py
        ğŸ“„ streamlit.py
        ğŸ“ core
            ğŸ“ messages
            ğŸ“ aifunc
            ğŸ“ runtime
            ğŸ“„ __init__.py
            ğŸ“ models
            ğŸ“ model_funcs
            ğŸ“ llms
        ğŸ“ framework
            ğŸ“ tasks
            ğŸ“ messages
            ğŸ“ logger
            ğŸ“ cache
            ğŸ“ translation
            ğŸ“ processes
            ğŸ“ ghostos
            ğŸ“ eventbuses
            ğŸ“„ __init__.py
            ğŸ“ workspaces
            ğŸ“ storage
            ğŸ“ openai_realtime
            ğŸ“ realtime
            ğŸ“ audio
            ğŸ“ model_compatible
            ğŸ“ threads
            ğŸ“ variables
            ğŸ“ configs
            ğŸ“ documents
            ğŸ“ llms
            ğŸ“ messengers
            ğŸ“ assets
        ğŸ“ workspace_stub
            ğŸ“„ .example.env
            ğŸ“ .streamlit
            ğŸ“ source
            ğŸ“ runtime
            ğŸ“ configs
            ğŸ“ assets
            ğŸ“ memories
        ğŸ“ contracts
            ğŸ“„ configs.py
            ğŸ“„ variables.py
            ğŸ“„ documents.py
            ğŸ“„ shutdown.py
            ğŸ“„ cache.py
            ğŸ“„ __init__.py
            ğŸ“„ logger.py
            ğŸ“„ README.md
            ğŸ“„ assets.py
            ğŸ“„ translation.py
            ğŸ“„ storage.py
            ğŸ“„ modules.py
            ğŸ“„ workspace.py
            ğŸ“„ pool.py
        ğŸ“ facade
            ğŸ“„ _llms.py
            ğŸ“„ __init__.py
            ğŸ“„ README.md
            ğŸ“„ _model_funcs_facade.py
            ğŸ“„ _contracts.py
        ğŸ“„ __init__.py
        ğŸ“ libraries
            ğŸ“ pyeditor
            ğŸ“ replier
            ğŸ“ planner
            ğŸ“ codex
            ğŸ“ terminal
            ğŸ“ multighosts
            ğŸ“„ README.md
            ğŸ“ project
            ğŸ“ thinking
            ğŸ“ memo
            ğŸ“ notebook
        ğŸ“ ghosts
            ğŸ“ experimental
            ğŸ“ project_manager
            ğŸ“ moss_agent
            ğŸ“ chatbot
            ğŸ“„ __init__.py
            ğŸ“„ README.md
            ğŸ“ moss_ghost
        ğŸ“ abcd
            ğŸ“„ ghosts.py
            ğŸ“„ thoughts.py
            ğŸ“„ realtime.py
            ğŸ“„ __init__.py
            ğŸ“„ utils.py
            ğŸ“„ moss_action.py
            ğŸ“„ concepts.py
        ğŸ“ prototypes
            ğŸ“ streamlitapp
            ğŸ“„ __init__.py
            ğŸ“„ README.md
            ğŸ“ realtime_console
            ğŸ“ ghostfunc
            ğŸ“ spherogpt
            ğŸ“ console
        ğŸ“ scripts
            ğŸ“„ clear.py
            ğŸ“„ __init__.py
            ğŸ“ cli
            ğŸ“„ copy_workspace.py
        ğŸ“ actions
            ğŸ“„ __init__.py
            ğŸ“„ module_editor.py
        ğŸ“ thoughts
            ğŸ“„ meta_prompt_experiments.py
            ğŸ“„ __init__.py
            ğŸ“„ operator_thoughts.py
        ğŸ“„ errors.py
        ğŸ“ moss_libs
            ğŸ“„ __init__.py
            ğŸ“„ self_updater_moss.py
        ğŸ“„ __main__.py
    ğŸ“„ pyproject.toml
    ğŸ“ tests
        ğŸ“„ test_streamlit_render.py
        ğŸ“ core
            ğŸ“ messages
            ğŸ“ aifuncs
            ğŸ“„ test_bootstrap.py
            ğŸ“ llms
        ğŸ“ python
            ğŸ“„ test_class.py
            ğŸ“„ test_with_statement.py
            ğŸ“„ test_pydantic.py
            ğŸ“„ test_os.py
            ğŸ“„ test_yield.py
            ğŸ“„ test_typing.py
            ğŸ“„ test_iterable.py
            ğŸ“„ test_py_module.py
            ğŸ“„ test_copy.py
            ğŸ“„ test_bytes.py
            ğŸ“„ test_operators.py
            ğŸ“„ test_regex.py
            ğŸ“„ test_collection.py
            ğŸ“„ test_asyncio.py
            ğŸ“„ test_typed_dict.py
            ğŸ“„ test_property.py
            ğŸ“„ test_generic.py
            ğŸ“„ test_exec.py
            ğŸ“„ test_queue.py
            ğŸ“„ test_set.py
            ğŸ“„ test_inspect.py
            ğŸ“„ test_threads.py
            ğŸ“„ test_slice.py
            ğŸ“„ test_context.py
            ğŸ“„ test_func.py
            ğŸ“„ test_dict.py
            ğŸ“„ test_pkg.py
            ğŸ“„ test_enum.py
        ğŸ“ framework
            ğŸ“ tasks
            ğŸ“ messages
            ğŸ“ ghostos
            ğŸ“ eventbuses
            ğŸ“ openai_realtime
            ğŸ“ messenger
            ğŸ“ threads
            ğŸ“ variables
            ğŸ“ llms
        ğŸ“ contracts
            ğŸ“„ test_configs.py
            ğŸ“„ test_modules.py
            ğŸ“„ test_pool.py
        ğŸ“ ghostos
            ğŸ“„ test_chatbot.py
        ğŸ“ libraries
            ğŸ“ notebook
        ğŸ“ abcd
            ğŸ“„ test_moss_action.py
    ğŸ“„ README.md
    ```

    DevContext at `Directory.ctx` are:
    <dev-context>

    the information from this PyDevCtx instance:

    * title: `.`
    * desc: `dev context of this directory`

    </dev-context>

    all the available dev contexts from name (or path) to description are:
    ```yaml
    .: dev context of this directory

    ```
    <editing file=`None`>
    ```text
    empty
    ```
    </editing>

    </Directory>

    ## Working Directory Info

    working directory is the root directory

    ### property `moss.terminal`

    # Terminal Context

    basic information about the current terminal:
    ```bash
    [System Context]
    OS: macOS-14.6.1
    User: BrightRed
    Pwd: /Users/BrightRed/Develop/github.com/ghost-in-moss/GhostOS/libs/ghostos
    TimeZone: CST
    Time: 2025-04-01 15:16:36
    System Lang: None
    System Encoding: UTF-8

    ```

    ### property `moss.mindflow`

    # Mindflow

    You are handling a task `GhostOS-Project-Manager`:

    ```yaml
    name: GhostOS-Project-Manager
    description: |2

          Specialist agent to manage any project
    status_desc: ''

    ```
    If your task `description` is empty, means endless task, you shall not operate it;
    Otherwise you shall `finish` or `cancel` it while the task is done or canceled by user.

    use Mindflow to operate the task state if you need.

    # Agent Info

    The Agent info about who you are and what you are doing:

    ## Identity

    ```yaml
    name: GhostOS-Project-Manager
    description: |2

          Specialist agent to manage any project

    ```

    ## Persona

    Powered By: GhostOS Project
    Capabilities: Expert in project management, powered by advanced AI and the MOSS protocol,
    with full-code interface proficiency in Python tools.

    ## Instruction

    ## **1. Interacting with Engineer Users**
    - **Be Clear and Concise**: Use straightforward, technical language that engineers can easily understand.
    - **Provide Context**: Always explain the purpose and outcome of your actions.
    - **Ask for Clarification**: Politely request more details if a userâ€™s request is unclear, or you can not get enough context.
    - **Offer Suggestions**: Propose alternatives if a request cannot be fulfilled.

    ## **2. Encouraging Proactive Problem Solving**
    - **Anticipate Needs**: Suggest related tasks based on the userâ€™s actions.
    - **Highlight Issues**: Notify users of potential problems immediately.
    - **Automate Repetitive Tasks**: Offer to automate frequent or tedious tasks.

    ## **3. Security Considerations**
    - **Confirm Destructive Actions**: Always ask for confirmation before irreversible actions.
    - **Notify Users of Risks**: Warn users of potential risks before proceeding.

    ## **4. Expressing Gratitude**
    - **Acknowledge User Input**: Thank users for their instructions and feedback.
    - **Encourage Feedback**: Invite users to share suggestions for improvement, and record important ones on DevContext.
  seq: complete
  created: 1743491796.56
inputs:
- msg_id: 220bc84d3e47daa320d906af283c5dcd
  role: user
  content: å¸®æˆ‘åœ¨æ ¹ç›®å½•çº¿ä¸‹å†™ä¸€ä¸ª hello world
  seq: complete
  created: 1743491796.447
added:
- msg_id: chatcmpl-BHQ9OkcrZ9GoRPYfMJUpyss3LXR4H
  call_id: call_1MbA7YnZcrxWZdFRNa0f41Xr
  type: function_call
  finish_reason: tool_calls
  role: assistant
  name: moss
  content: '{"code":"def run(moss: Moss):\n    moss.project.working.touch(''hello_world.txt'',
    ''A simple hello world file'')"}'
  payloads:
    completion_usage:
      completion_tokens: 41
      prompt_tokens: 6956
      total_tokens: 6997
      completion_tokens_details:
        accepted_prediction_tokens: 0
        audio_tokens: 0
        reasoning_tokens: 0
        rejected_prediction_tokens: 0
      prompt_tokens_details:
        audio_tokens: 0
        cached_tokens: 0
    model_conf:
      model: gpt-4o
      description: ''
      service: openai
      temperature: 0.7
      n: 1
      max_tokens: 2000
      timeout: 30.0
      request_timeout: 40.0
      kwargs: {}
      message_types: null
      allow_streaming: true
      top_p: null
      reasoning: null
      compatible: null
      payloads: {}
    prompt_info:
      prompt_id: c77d0d23e7329d6ea0690091c9cf6b59
      desc: created from thread afc688911b5c37d714bf84da72cd91d0 turn 5bdf099826e6ba84e71c3423dfc15877
  seq: complete
  created: 1743491799.722
functions:
- name: moss
  description: Useful to execute code in the python context that MOSS provide to you.The
    code must include a `run` function.
  parameters:
    properties:
      code:
        description: the python code you want to execute. never quote them with ```
        title: Code
        type: string
    required:
    - code
    title: Argument
    type: object
functional_tokens:
- name: moss
  token: moss
  description: Useful to execute code in the python context that MOSS provide to you.The
    code must include a `run` function.
created: 1743491797
model:
  model: gpt-4o
  service: openai
run_start: 1743491796.5805
first_token: 1743491799.7219
run_end: 1743491799.5056
request_params: '{''messages'': [{''content'': ''# Meta Instruction\n\nYou are the
  mind of an AI Agent driven by `GhostOS` framework.\nHere are some basic information
  you might expect:\n\n## GhostOS\n\n`GhostOS` is an AI Agent framework written in
  Python, \nproviding llm connections, body shell, tools, memory etc and specially
  the `MOSS` for you.\n\n## MOSS\n\nYou are equipped with the MOSS (Model-oriented
  Operating System Simulator).\nWhich provides you a way to control your body / tools
  / thoughts through Python code.\n\nbasic usage: \n1. you will get the python code
  context that MOSS provide to you below. \n2. you can generate code with `moss` tool,
  then the `GhostOS` will execute them for you.\n3. if you print anything in your
  generated code, the output will be shown in further messages.\n\n## Code Context\n\nThe
  python context `ghostos.ghosts.project_manager.project_manager_moss` that MOSS provides
  to you are below:\n\n```python\nfrom ghostos.abcd import Mindflow\nfrom ghostos_moss
  import Moss as Parent\nfrom ghostos.libraries.project import ProjectExports\nfrom
  ghostos.libraries.terminal import Terminal\n\n\nclass Moss(Parent):\n    """\n    the
  interfaces for project manager.\n    """\n\n    project: ProjectExports.ProjectManager\n    """
  understand the project files/modules"""\n\n    mindflow: Mindflow\n    """ operate
  your mindflow state"""\n\n    terminal: Terminal\n    """interact with terminal"""\n\n```\n\ninterfaces
  of some imported attrs are:\n```python\n#<classes>\n\n#<attr name=`__origin_moss__`
  module=`ghostos_moss.abcd`>\nclass Moss(ABC):\n    """\n    Language Model-oriented
  Operating System Simulator.\n    Python interface of Runtime Injections for AI-Models
  in multi-turns chat or thinking.\n    * The members with typehint will be injected
  with runtime instances.\n    * The property of SerializeType will persist during
  multi-turns.\n    * SerializeType: int, float, str, None, list, dict, BaseModel,
  TypedDict\n    """\n\n    T = TypeVar(\''T\'')\n\n    executing_code: Optional[str]\n    """the
  code that execute the moss instance."""\n\n    __watching__: List[Union[FunctionType,
  ModuleType, type]] = []\n    """the class or module that dose not bound to moss
  but still want to watch the interface of them"""\n\n    __ignored__: List[str] =
  []\n    """the ignored module names that do not need to watch the code interface
  of them"""\n\n    @abstractmethod\n    def pprint(self, *args, **kwargs) -> None:\n        """\n        pretty
  print\n        """\n        pass\n\n#</attr>\n\nclass ProjectExports(Exporter):\n    """\n    the
  exports for projects.\n    """\n\n    ProjectManager = ProjectManager\n    PyDevCtx
  = PyDevCtx\n    File = File\n    Directory = Directory\n    PyModuleEditor = PyModuleEditor\n\n    """\n    #attrs
  of `ProjectExports` are:\n    #<attr name=`Directory` module=`ghostos.libraries.project.abcd`>\n    class
  Directory(ABC):\n        \\"""\n        this is a useful tool to manage a directory
  or a project in agentic way.\n        the principles of files management are:\n        1.
  You can manage the files and sub dirs in this directory, but not parent directories.\n        2.
  Markdown as knowledge: the Markdown files in the directory are the knowledge for
  you.\n        this library will get more features in future versions.\n        \\"""\n\n        path:
  pathlib.Path\n        \\"""the pathlib.Path object of the directory\\"""\n\n        ctx:
  PyDevCtx\n        \\"""the dev context of this directory\\"""\n\n        @abstractmethod\n        def
  full_context(self) -> str:\n            \\"""\n            :return: the context
  of the directory\n            \\"""\n            pass\n\n        @abstractmethod\n        def
  dev_contexts(self) -> Dict[str, PyDevCtx]:\n            \\"""\n            :return:
  all the dev contexts in this directory.\n            \\"""\n            pass\n\n        @abstractmethod\n        def
  new_dev_context(self, title: str, desc: str) -> PyDevCtx:\n            \\"""\n            create
  a new dev context for some jobs.\n            the context will save to the directory\n            \\"""\n            pass\n\n        @abstractmethod\n        def
  lists(\n                self, *,\n                prefix: str = "",\n                recursion:
  int = 0,\n                files: bool = True,\n                dirs: bool = True,\n        )
  -> str:\n            \\"""\n            list sub filenames and directories as string.\n            :param
  prefix: the relative path that start the listing.\n            :param recursion:
  the recursion depth, 0 means no recursion. < 0 means endless recursion.\n            :param
  dirs: True => list dirs\n            :param files: True => list files\n            :return:
  formated string of directory\n            \\"""\n            pass\n\n        @abstractmethod\n        def
  subdir(self, path: str) -> Self:\n            \\"""\n            get subdirectory
  instance by path relative to this directory.\n            :param path: the relative
  path which must be a directory. must exist or raise ValueError.\n            :return:
  Directory instance.\n\n            if you want to create directory, use terminal
  if you got one.\n            \\"""\n            pass\n\n        @abstractmethod\n        def
  describe(self, path: str, desc: str) -> None:\n            \\"""\n            describe
  a sub file or directory. then you can see the description in the context.\n            :param
  path: relative to this directory. if `.`, means describe the directory itself\n            :param
  desc: description.\n            \\"""\n            pass\n\n        @abstractmethod\n        def
  mkdir(self, subdir: str, desc: str, dev_ctx: Union[PyDevCtx, None] = None) -> bool:\n            \\"""\n            make
  a subdirectory with description and dev_ctx\n            :param subdir: directory
  path relative to this directory.\n            :param desc: description of the directory.\n            :param
  dev_ctx: pass the dev_ctx to this directory. not neccessary, do it only if you know
  what you\''re doing.\n            :return: if False, directory already exists.\n            \\"""\n            pass\n\n        @abstractmethod\n        def
  touch(self, sub_file: str, desc: str, dev_ctx: Union[PyDevCtx, None] = None) ->
  bool:\n            \\"""\n            touch a file with description and Optional[dev_ctx]\n            \\"""\n            pass\n\n        @abstractmethod\n        def
  edit(self, file_path: str) -> File:\n            \\"""\n            focus to edit
  the file in the directory\n            the file must exist or raise FileNotFoundError.\n\n            :param
  file_path: relative to the working directory. if None, don\''t focus on any file.\n            \\"""\n            pass\n\n        @abstractmethod\n        def
  focus(self, file_path: Union[str, None]) -> Union[File, None]:\n            \\"""\n            focus
  on a file and create editing file object.\n            :param file_path: if None,
  focus on nothing, spare tokens.\n            :return: if file_path is None, return
  None\n            \\"""\n            pass\n\n        @abstractmethod\n        def
  save_data(self) -> None:\n            \\"""\n            save the changes from dev
  context changes/describe/focus\n            better way to call save_data by use
  `with statement`\n            \\"""\n            pass\n\n        def __enter__(self):\n            return
  self\n\n        def __exit__(self, exc_type, exc_val, exc_tb):\n            \\"""\n            if
  exit the directory context without errors, the dev data of this directory will be
  saved.\n            \\"""\n            if not exc_val:\n                self.save_data()\n\n    #</attr>\n\n    #<attr
  name=`File` module=`ghostos.libraries.project.abcd`>\n    class File(ABC):\n        path:
  pathlib.Path\n        \\"""the pathlib.Path object of the directory\\"""\n\n        ctx:
  PyDevCtx\n        \\"""the dev context of this file\\"""\n\n        @abstractmethod\n        def
  read(self, line_number: bool = True, detail: bool = True) -> str:\n            \\"""\n            read
  content from the file.\n            :param line_number: if True, add line number
  at the beginning of each line like `1|...`\n            :param detail: if True,
  add more information about the file, the real content of the file will be embraced
  with <content>...</content> mark\n            \\"""\n            pass\n\n        @abstractmethod\n        def
  write(self, content: str, append: bool = False) -> None:\n            \\"""\n            write
  content to the file.\n            \\"""\n            pass\n\n        @abstractmethod\n        def
  insert(self, content: str, start: int = -1, end: int = -1) -> None:\n            \\"""\n            use
  content to relace the origin content lines > start line and <= end line.\n            \\"""\n            pass\n\n        @abstractmethod\n        def
  continuous_write(self, instruction: str, start: int = -1, end: int = -1, max_round:
  int = 10) -> Operator:\n            \\"""\n            considering your output is
  limited, you can use this method to start a continuous writing in multi-turns.\n            only
  use it when you are planning to write something beyond your max-tokens limit.\n            :param
  instruction: about what you are doing, will remind it to you at each turn\n            :param
  start: start index: the writing start at line\n            :param end: end index:
  the writing end before (eqt) line\n            :param max_round: maximum round for
  this writing.\n            :return: remember to return the mind operator, which
  will operate the multi-turns writing.\n            \\"""\n            pass\n\n    #</attr>\n\n    #<attr
  name=`ProjectManager` module=`ghostos.libraries.project.abcd`>\n    class ProjectManager(ABC):\n        \\"""\n        project
  manager\n        you are provided with Directory, and DevContext that helping you
  to watch useful tools.\n        \\"""\n\n        root: Directory\n        \\"""the
  root directory of the project.\\"""\n\n        working: Directory\n        \\"""the
  current directory of the project.\\"""\n\n        @abstractmethod\n        def work_on(self,
  dir_path: str) -> Operator:\n            \\"""\n            change the working directory
  to dir_path, always relative to the root directory.\n            :param dir_path:
  if empty or `~`, will check out to the root.\n            \\"""\n            pass\n\n        @abstractmethod\n        def
  edit_pymodule(self, modulename: str) -> PyModuleEditor:\n            \\"""\n            edit
  a python module, if editable.\n            :param modulename: the full import name
  of the module\n            \\"""\n            pass\n\n    #</attr>\n\n    #<attr
  name=`PyDevCtx` module=`ghostos.libraries.project.abcd`>\n    class PyDevCtx(BaseModel,
  ABC):\n        \\"""\n        python context for a certain kind of develop jobs.\n        you
  can use it to remember important python context and never forget them in long-term.\n        \\"""\n\n        title:
  str = Field(description="title for this context")\n\n        desc: str = Field(default="",
  description="description for this context")\n\n        instructions: Dict[str, str]
  = Field(\n            default_factory=dict,\n            description="write instructions
  by yourself to follow"\n        )\n\n        notes: Dict[str, str] = Field(\n            default_factory=dict,\n            description="record
  something in case of forgetting"\n        )\n\n        examples: List[str] = Field(\n            default_factory=list,\n            description="use
  python module as examples for developing.",\n        )\n\n        interfaces: List[_IMPORT_PATH]
  = Field(\n            default_factory=list,\n            description=(\n                "watching
  a bunch of python module/class/func interfaces."\n                "dev context will
  provide the interface of them for you"\n            )\n        )\n\n        sources:
  List[_IMPORT_PATH] = Field(\n            default_factory=list,\n            description="watching
  a bunch of python module/class/func sources."\n        )\n\n        @abstractmethod\n        def
  read_interface(\n                self,\n                target: Union[str, FunctionType,
  ModuleType, type],\n                *,\n                watching: bool = False,\n        )
  -> str:\n            \\"""\n            read code interface from a target.\n            :param
  target:  import path or objects that can be called by inspect.getsource\n            :param
  watching: if watching, will always watch it.\n            \\"""\n            pass\n\n        @abstractmethod\n        def
  read_source(\n                self,\n                target: Union[str, FunctionType,
  ModuleType, type],\n                *,\n                watching: bool = False,\n        )
  -> str:\n            \\"""\n            read source code from a target.\n            :param
  target:  import path or objects that can be called by inspect.getsource\n            :param
  watching: if watching, will always watch it.\n            \\"""\n            pass\n\n        @abstractmethod\n        def
  full_context(self) -> str:\n            \\"""\n            dump the context into
  nature language string.\n            \\"""\n            pass\n\n    #</attr>\n\n    #<attr
  name=`PyModuleEditor` module=`ghostos.libraries.pyeditor.abcd`>\n    class PyModuleEditor(ABC):\n        \\"""\n        can
  edit python module\n        \\"""\n\n        modulename: str\n        \\"""the editing
  module name\\"""\n\n        filename: str\n        \\"""the absolute filename of
  the module\\"""\n\n        @abstractmethod\n        def new_from(self, modulename:
  str) -> Self:\n            \\"""\n            create new module editor\n            \\"""\n            pass\n\n        @abstractmethod\n        def
  get_source(\n                self,\n                show_line_num: bool = False,\n                start_line:
  int = 0,\n                end_line: int = -1,\n        ) -> str:\n            \\"""\n            read
  source code from this module\n            :param show_line_num: if true, each line
  start with `[number]|`, for example:\n                    source code: `def foo():`\n                    show
  line number: ` 1|def foo():`.\n                   don\''t confuse the prefix line
  num is the part of the file.\n            :param start_line: start line number\n            :param
  end_line: end line number, if < 0, means end line number\n            :return: source
  code\n            \\"""\n            pass\n\n        @abstractmethod\n        def
  get_imported_attrs_interfaces(self) -> str:\n            \\"""\n            get
  imported attrs source code interfaces (definitions and signatures)\n            convenient
  way to use imported attrs without read source code from them.\n            \\"""\n            pass\n\n        @abstractmethod\n        def
  replace(\n                self,\n                target_str: str,\n                replace_str:
  str,\n                count: int = 1,\n                reload: bool = False,\n        )
  -> bool:\n            \\"""\n            replace the source code of this module
  by replace a specific string\n            :param target_str: target string in the
  source code\n            :param replace_str: replacement\n            :param count:
  if -1, replace all occurrences of replace_str, else only replace occurrences count
  times.\n            :param reload: if False, update but note save to the module.\n            :return:
  if not ok, means target string is missing\n            the source will not be saved
  until save() is called.\n            \\"""\n            pass\n\n        @abstractmethod\n        def
  append(self, source: str, reload: bool = False) -> None:\n            \\"""\n            append
  source code to this module.\n            :param source: the source code of class
  / function / assignment\n            :param reload: if False, update but note save
  to the module.\n            \\"""\n            pass\n\n        @abstractmethod\n        def
  insert(self, source: str, line_num: int, reload: bool = False) -> None:\n            \\"""\n            insert
  source code to this module at line number.\n            remember following the python
  code format pattern.\n            :param source: the inserting code, such like from
  ... import ... or others.\n            :param line_num: the start line of the insertion.
  if 0, insert to the top. if negative, count line from the bottom\n            :param
  reload: if False, update but note save to the module.\n            the source will
  not be saved until save() is called.\n            \\"""\n            pass\n\n        @abstractmethod\n        def
  replace_attr(\n                self,\n                attr_name: str,\n                replace_str:
  str,\n                reload: bool = False,\n        ) -> str:\n            \\"""\n            replace
  a module attribute\''s source code.\n            the target attribute shall be a
  class or a function.\n            :param attr_name: name of the target attribute
  of this module.\n            :param replace_str: new source code\n            :param
  reload: if False, update but note save to the module.\n            :return: the
  replaced source code. if empty, means target attribute is missing\n            \\"""\n            pass\n\n        @abstractmethod\n        def
  save(self, reload: bool = True, source: Optional[str] = None) -> None:\n            \\"""\n            save
  the module changes to file.\n            otherwise only the editor\''s cached source
  code will be changed.\n            :param reload: if True, reload the module from
  the saved source code.\n            :param source: if the source given, replace
  all the source code.\n            \\"""\n            pass\n\n    #</attr>\n    """\n\nclass
  Moss(Parent):\n    """\n    the interfaces for project manager.\n    """\n\n    project:
  ProjectExports.ProjectManager\n    """ understand the project files/modules"""\n\n    mindflow:
  Mindflow\n    """ operate your mindflow state"""\n\n    terminal: Terminal\n    """interact
  with terminal"""\n\n\nclass Mindflow(PromptObjectModel, ABC):\n    """\n    control
  ghost mind with basic operators.\n    """\n\n    MessageKind = Union[str, Message,
  Any]\n    """message kind shall be string or serializable object"""\n\n    # ---
  åŸºæœ¬æ“ä½œ --- #\n    @abstractmethod\n    def finish(self, status: str = "", *replies:
  MessageKind) -> Operator:\n        """\n        finish self task\n        :param
  status: describe status of the task\n        :param replies: replies to parent task
  or user\n        """\n        pass\n\n    @abstractmethod\n    def fail(self, reason:
  str = "", *replies: MessageKind) -> Operator:\n        """\n        self task failed.\n        :param
  reason: describe status of the task\n        :param replies: replies to parent task
  or user\n        """\n        pass\n\n    @abstractmethod\n    def wait(self, status:
  str = "", *replies: MessageKind) -> Operator:\n        """\n        wait for the
  parent task or user to provide more information or further instruction.\n        :param
  status: describe current status\n        :param replies: question, inform or\n        """\n        pass\n\n    @abstractmethod\n    def
  think(self, *messages: MessageKind, instruction: str = "", sync: bool = False) ->
  Operator:\n        """\n        start next round thinking on messages\n        :param
  messages: observe target\n        :param instruction: instruction when receive the
  observation.\n        :param sync: if True, observe immediately, otherwise check
  other event first\n        :return:\n        """\n        pass\n\n    @abstractmethod\n    def
  observe(self, **kwargs) -> Operator:\n        """\n        observe values\n        :param
  kwargs:\n        :return:\n        """\n        pass\n\n    @abstractmethod\n    def
  error(self, *messages: MessageKind) -> Operator:\n        """\n        think on
  the error message.\n        """\n        pass\n\n\nclass Terminal(ABC):\n    """\n    Abstract
  base class representing a system terminal interface.\n    Provides basic command
  execution capabilities for OS interactions.\n    """\n\n    class CommandResult(NamedTuple):\n        """\n        Result
  container for command execution outcomes.\n        Attributes:\n            exit_code:
  Process exit code (0 for success)\n            stdout: Standard output content\n            stderr:
  Error output content\n        """\n        exit_code: int\n        stdout: str\n        stderr:
  str\n\n    @abstractmethod\n    def exec(self, *commands: str, timeout: float =
  10.0) -> CommandResult:\n        """\n        Execute a shell command and return
  structured results.\n\n        Args:\n            commands: Command lines to execute.
  each command is a full line command.\n            (Note: Implementation should handle
  proper shell escaping)\n            timeout: Timeout in seconds\n\n        Returns:\n            CommandResult
  containing exit code and output streams\n\n        Raises:\n            RuntimeError:
  If command execution fails fundamentally\n            TimeoutError: If execution
  exceeds permitted time\n        """\n        pass\n\n\n#<attr name=`<class \''ghostos_moss.abcd.Moss\''>.project`
  module=`ghostos.libraries.project.abcd`>\nclass ProjectManager(ABC):\n    """\n    project
  manager\n    you are provided with Directory, and DevContext that helping you to
  watch useful tools.\n    """\n\n    root: Directory\n    """the root directory of
  the project."""\n\n    working: Directory\n    """the current directory of the project."""\n\n    @abstractmethod\n    def
  work_on(self, dir_path: str) -> Operator:\n        """\n        change the working
  directory to dir_path, always relative to the root directory.\n        :param dir_path:
  if empty or `~`, will check out to the root.\n        """\n        pass\n\n    @abstractmethod\n    def
  edit_pymodule(self, modulename: str) -> PyModuleEditor:\n        """\n        edit
  a python module, if editable.\n        :param modulename: the full import name of
  the module\n        """\n        pass\n\n#</attr>\n\n\nclass Operator(ABC):\n    """\n    return
  operator to outside system to operate your thought by agent system. \n    """\n    pass\n\n\n#</classes>\n```\n\n\n\nNotices:\n*
  the imported functions are only shown with signature, the source code is omitted.\n*
  the properties on moss instance, will keep existence. \n* You can bind variables
  of type int/float/bool/str/list/dict/BaseModel to moss instance if you need them
  for next turn.\n\nYou are able to call the `moss` tool, generate code to fulfill
  your will.\nthe python code you generated, must include a `run` function, follow
  the pattern:\n\n```python\ndef run(moss: Moss):\n    """\n    :param moss: instance
  of the class `Moss`, the properties on it will be injected with runtime implementations.\n    :return:
  Optional[Operator] \n             if return None, the outer system will perform
  default action, or observe the values you printed.\n             Otherwise, the
  outer system will execute the Operator, which is your mindflow operator.\n             if
  some methods return Operator, you can use them to control your mindflow, REMEMBER
  to return the operator instance.\n    """\n```\n\nThen the `GhostOS` system will
  add your code to the python module provided to you, \nand execute the `run` function.
  \n\nNotices: \n* Your code will **APPEND** to the code of `ghostos.ghosts.project_manager.project_manager_moss`
  then execute, so **DO NOT REPEAT THE DEFINED CODE IN THE MODULE**.\n* if the python
  code context can not fulfill your will, do not use the `moss` tool.\n* you can reply
  as usual without calling the tool `moss`. use it only when you know what you\''re
  doing.\n* don\''t copy the main function\''s __doc__, they are instruction to you
  only.\n* in your code generation, comments is not required, comment only when necessary.\n*
  You code generation will not modify your provided module\''s source, unless you
  got tools to do so.\n\n### property `moss.project`\n\n# Project Manager Instance\n\nproject
  manager information are:\n\n## Root Directory Info\n\nfull context of the Directory
  instance:\n\n<Directory path=`/Users/BrightRed/Develop/github.com/ghost-in-moss/GhostOS/libs/ghostos`>\n\nThe
  sub-files and sub-dirs of the current directory are as follows (recursion depth
  2).\n```\nğŸ“„ RELEASES.md\nğŸ“ ghostos\n    ğŸ“ demo\n        ğŸ“ aifuncs_demo\n        ğŸ“
  tool_tests\n        ğŸ“ test_models\n        ğŸ“ experiments\n        ğŸ“ os_agents\n        ğŸ“„
  __init__.py\n        ğŸ“ agents\n        ğŸ“„ README.md\n        ğŸ“„ main_agent.py\n        ğŸ“„
  ghost_func_example.py\n        ğŸ“„ aifunc_raw_test.py\n        ğŸ“ sphero\n    ğŸ“„ bootstrap.py\n    ğŸ“„
  streamlit.py\n    ğŸ“ core\n        ğŸ“ messages\n        ğŸ“ aifunc\n        ğŸ“ runtime\n        ğŸ“„
  __init__.py\n        ğŸ“ models\n        ğŸ“ model_funcs\n        ğŸ“ llms\n    ğŸ“ framework\n        ğŸ“
  tasks\n        ğŸ“ messages\n        ğŸ“ logger\n        ğŸ“ cache\n        ğŸ“ translation\n        ğŸ“
  processes\n        ğŸ“ ghostos\n        ğŸ“ eventbuses\n        ğŸ“„ __init__.py\n        ğŸ“
  workspaces\n        ğŸ“ storage\n        ğŸ“ openai_realtime\n        ğŸ“ realtime\n        ğŸ“
  audio\n        ğŸ“ model_compatible\n        ğŸ“ threads\n        ğŸ“ variables\n        ğŸ“
  configs\n        ğŸ“ documents\n        ğŸ“ llms\n        ğŸ“ messengers\n        ğŸ“ assets\n    ğŸ“
  workspace_stub\n        ğŸ“„ .example.env\n        ğŸ“ .streamlit\n        ğŸ“ source\n        ğŸ“
  runtime\n        ğŸ“ configs\n        ğŸ“ assets\n        ğŸ“ memories\n    ğŸ“ contracts\n        ğŸ“„
  configs.py\n        ğŸ“„ variables.py\n        ğŸ“„ documents.py\n        ğŸ“„ shutdown.py\n        ğŸ“„
  cache.py\n        ğŸ“„ __init__.py\n        ğŸ“„ logger.py\n        ğŸ“„ README.md\n        ğŸ“„
  assets.py\n        ğŸ“„ translation.py\n        ğŸ“„ storage.py\n        ğŸ“„ modules.py\n        ğŸ“„
  workspace.py\n        ğŸ“„ pool.py\n    ğŸ“ facade\n        ğŸ“„ _llms.py\n        ğŸ“„ __init__.py\n        ğŸ“„
  README.md\n        ğŸ“„ _model_funcs_facade.py\n        ğŸ“„ _contracts.py\n    ğŸ“„ __init__.py\n    ğŸ“
  libraries\n        ğŸ“ pyeditor\n        ğŸ“ replier\n        ğŸ“ planner\n        ğŸ“ codex\n        ğŸ“
  terminal\n        ğŸ“ multighosts\n        ğŸ“„ README.md\n        ğŸ“ project\n        ğŸ“
  thinking\n        ğŸ“ memo\n        ğŸ“ notebook\n    ğŸ“ ghosts\n        ğŸ“ experimental\n        ğŸ“
  project_manager\n        ğŸ“ moss_agent\n        ğŸ“ chatbot\n        ğŸ“„ __init__.py\n        ğŸ“„
  README.md\n        ğŸ“ moss_ghost\n    ğŸ“ abcd\n        ğŸ“„ ghosts.py\n        ğŸ“„ thoughts.py\n        ğŸ“„
  realtime.py\n        ğŸ“„ __init__.py\n        ğŸ“„ utils.py\n        ğŸ“„ moss_action.py\n        ğŸ“„
  concepts.py\n    ğŸ“ prototypes\n        ğŸ“ streamlitapp\n        ğŸ“„ __init__.py\n        ğŸ“„
  README.md\n        ğŸ“ realtime_console\n        ğŸ“ ghostfunc\n        ğŸ“ spherogpt\n        ğŸ“
  console\n    ğŸ“ scripts\n        ğŸ“„ clear.py\n        ğŸ“„ __init__.py\n        ğŸ“ cli\n        ğŸ“„
  copy_workspace.py\n    ğŸ“ actions\n        ğŸ“„ __init__.py\n        ğŸ“„ module_editor.py\n    ğŸ“
  thoughts\n        ğŸ“„ meta_prompt_experiments.py\n        ğŸ“„ __init__.py\n        ğŸ“„
  operator_thoughts.py\n    ğŸ“„ errors.py\n    ğŸ“ moss_libs\n        ğŸ“„ __init__.py\n        ğŸ“„
  self_updater_moss.py\n    ğŸ“„ __main__.py\nğŸ“„ pyproject.toml\nğŸ“ tests\n    ğŸ“„ test_streamlit_render.py\n    ğŸ“
  core\n        ğŸ“ messages\n        ğŸ“ aifuncs\n        ğŸ“„ test_bootstrap.py\n        ğŸ“
  llms\n    ğŸ“ python\n        ğŸ“„ test_class.py\n        ğŸ“„ test_with_statement.py\n        ğŸ“„
  test_pydantic.py\n        ğŸ“„ test_os.py\n        ğŸ“„ test_yield.py\n        ğŸ“„ test_typing.py\n        ğŸ“„
  test_iterable.py\n        ğŸ“„ test_py_module.py\n        ğŸ“„ test_copy.py\n        ğŸ“„
  test_bytes.py\n        ğŸ“„ test_operators.py\n        ğŸ“„ test_regex.py\n        ğŸ“„ test_collection.py\n        ğŸ“„
  test_asyncio.py\n        ğŸ“„ test_typed_dict.py\n        ğŸ“„ test_property.py\n        ğŸ“„
  test_generic.py\n        ğŸ“„ test_exec.py\n        ğŸ“„ test_queue.py\n        ğŸ“„ test_set.py\n        ğŸ“„
  test_inspect.py\n        ğŸ“„ test_threads.py\n        ğŸ“„ test_slice.py\n        ğŸ“„ test_context.py\n        ğŸ“„
  test_func.py\n        ğŸ“„ test_dict.py\n        ğŸ“„ test_pkg.py\n        ğŸ“„ test_enum.py\n    ğŸ“
  framework\n        ğŸ“ tasks\n        ğŸ“ messages\n        ğŸ“ ghostos\n        ğŸ“ eventbuses\n        ğŸ“
  openai_realtime\n        ğŸ“ messenger\n        ğŸ“ threads\n        ğŸ“ variables\n        ğŸ“
  llms\n    ğŸ“ contracts\n        ğŸ“„ test_configs.py\n        ğŸ“„ test_modules.py\n        ğŸ“„
  test_pool.py\n    ğŸ“ ghostos\n        ğŸ“„ test_chatbot.py\n    ğŸ“ libraries\n        ğŸ“
  notebook\n    ğŸ“ abcd\n        ğŸ“„ test_moss_action.py\nğŸ“„ README.md\n```\n\nDevContext
  at `Directory.ctx` are: \n<dev-context>\n\nthe information from this PyDevCtx instance:\n\n*
  title: `.`\n* desc: `dev context of this directory`\n\n</dev-context>\n\nall the
  available dev contexts from name (or path) to description are: \n```yaml\n.: dev
  context of this directory\n\n```\n<editing file=`None`>\n```text\nempty\n```\n</editing>\n\n</Directory>\n\n##
  Working Directory Info\n\nworking directory is the root directory\n\n### property
  `moss.terminal`\n\n# Terminal Context\n\nbasic information about the current terminal:
  \n```bash\n[System Context]\nOS: macOS-14.6.1\nUser: BrightRed\nPwd: /Users/BrightRed/Develop/github.com/ghost-in-moss/GhostOS/libs/ghostos\nTimeZone:
  CST\nTime: 2025-04-01 15:16:36\nSystem Lang: None\nSystem Encoding: UTF-8\n\n```\n\n###
  property `moss.mindflow`\n\n# Mindflow\n\nYou are handling a task `GhostOS-Project-Manager`:\n\n```yaml\nname:
  GhostOS-Project-Manager\ndescription: |2\n\n      Specialist agent to manage any
  project\nstatus_desc: \''\''\n\n```\nIf your task `description` is empty, means
  endless task, you shall not operate it;\nOtherwise you shall `finish` or `cancel`
  it while the task is done or canceled by user.  \n\nuse Mindflow to operate the
  task state if you need.\n\n# Agent Info\n\nThe Agent info about who you are and
  what you are doing:\n\n## Identity\n\n```yaml\nname: GhostOS-Project-Manager\ndescription:
  |2\n\n      Specialist agent to manage any project\n\n```\n\n## Persona\n\nPowered
  By: GhostOS Project\nCapabilities: Expert in project management, powered by advanced
  AI and the MOSS protocol, \nwith full-code interface proficiency in Python tools.\n\n##
  Instruction\n\n## **1. Interacting with Engineer Users**\n- **Be Clear and Concise**:
  Use straightforward, technical language that engineers can easily understand.  \n-
  **Provide Context**: Always explain the purpose and outcome of your actions.  \n-
  **Ask for Clarification**: Politely request more details if a userâ€™s request is
  unclear, or you can not get enough context.\n- **Offer Suggestions**: Propose alternatives
  if a request cannot be fulfilled.  \n\n## **2. Encouraging Proactive Problem Solving**\n-
  **Anticipate Needs**: Suggest related tasks based on the userâ€™s actions.  \n- **Highlight
  Issues**: Notify users of potential problems immediately.  \n- **Automate Repetitive
  Tasks**: Offer to automate frequent or tedious tasks.  \n\n## **3. Security Considerations**\n-
  **Confirm Destructive Actions**: Always ask for confirmation before irreversible
  actions.  \n- **Notify Users of Risks**: Warn users of potential risks before proceeding.  \n\n##
  **4. Expressing Gratitude**\n- **Acknowledge User Input**: Thank users for their
  instructions and feedback.  \n- **Encourage Feedback**: Invite users to share suggestions
  for improvement, and record important ones on DevContext.'', ''role'': ''developer''},
  {''content'': ''å¸®æˆ‘åœ¨æ ¹ç›®å½•çº¿ä¸‹å†™ä¸€ä¸ª hello world'', ''role'': ''user''}], ''model'': ''gpt-4o'',
  ''function_call'': NOT_GIVEN, ''functions'': NOT_GIVEN, ''tools'': [{''function'':
  {''name'': ''moss'', ''description'': ''Useful to execute code in the python context
  that MOSS provide to you.The code must include a `run` function.'', ''parameters'':
  {''properties'': {''code'': {''description'': ''the python code you want to execute.
  never quote them with ```'', ''title'': ''Code'', ''type'': ''string''}}, ''required'':
  [''code''], ''title'': ''Argument'', ''type'': ''object''}}, ''type'': ''function''}],
  ''max_tokens'': 2000, ''temperature'': 0.7, ''n'': 1, ''timeout'': 30.0, ''stream'':
  True, ''stream_options'': {''include_usage'': True}, ''top_p'': NOT_GIVEN}'
