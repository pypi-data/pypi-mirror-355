# coding: utf-8

"""
    Snowstorm

    SNOMED CT Terminology Server REST API

    The version of the OpenAPI document: 10.8.2
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501

import warnings
from pydantic import validate_call, Field, StrictFloat, StrictStr, StrictInt
from typing import Any, Dict, List, Optional, Tuple, Union
from typing_extensions import Annotated

from pydantic import Field, StrictBool, StrictInt, StrictStr, field_validator
from typing import Dict, List, Optional
from typing_extensions import Annotated
from snowstorm_client.models.description_component import DescriptionComponent
from snowstorm_client.models.items_page_description_component import ItemsPageDescriptionComponent
from snowstorm_client.models.page_browser_description_search_result_component import PageBrowserDescriptionSearchResultComponent

from snowstorm_client.api_client import ApiClient, RequestSerialized
from snowstorm_client.api_response import ApiResponse
from snowstorm_client.rest import RESTResponseType


class DescriptionsApi:
    """NOTE: This class is auto generated by OpenAPI Generator
    Ref: https://openapi-generator.tech

    Do not edit the class manually.
    """

    def __init__(self, api_client=None) -> None:
        if api_client is None:
            api_client = ApiClient.get_default()
        self.api_client = api_client


    @validate_call
    def count_semantic_tags(
        self,
        branch: StrictStr,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> Dict[str, int]:
        """List semantic tags of all active concepts together with a count of concepts using each.


        :param branch: (required)
        :type branch: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._count_semantic_tags_serialize(
            branch=branch,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "Dict[str, int]",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def count_semantic_tags_with_http_info(
        self,
        branch: StrictStr,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[Dict[str, int]]:
        """List semantic tags of all active concepts together with a count of concepts using each.


        :param branch: (required)
        :type branch: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._count_semantic_tags_serialize(
            branch=branch,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "Dict[str, int]",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def count_semantic_tags_without_preload_content(
        self,
        branch: StrictStr,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """List semantic tags of all active concepts together with a count of concepts using each.


        :param branch: (required)
        :type branch: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._count_semantic_tags_serialize(
            branch=branch,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "Dict[str, int]",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _count_semantic_tags_serialize(
        self,
        branch,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if branch is not None:
            _path_params['branch'] = branch
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/{branch}/descriptions/semantictags',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def fetch_description(
        self,
        branch: StrictStr,
        description_id: StrictStr,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> DescriptionComponent:
        """fetch_description


        :param branch: (required)
        :type branch: str
        :param description_id: (required)
        :type description_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._fetch_description_serialize(
            branch=branch,
            description_id=description_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "DescriptionComponent",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def fetch_description_with_http_info(
        self,
        branch: StrictStr,
        description_id: StrictStr,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[DescriptionComponent]:
        """fetch_description


        :param branch: (required)
        :type branch: str
        :param description_id: (required)
        :type description_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._fetch_description_serialize(
            branch=branch,
            description_id=description_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "DescriptionComponent",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def fetch_description_without_preload_content(
        self,
        branch: StrictStr,
        description_id: StrictStr,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """fetch_description


        :param branch: (required)
        :type branch: str
        :param description_id: (required)
        :type description_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._fetch_description_serialize(
            branch=branch,
            description_id=description_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "DescriptionComponent",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _fetch_description_serialize(
        self,
        branch,
        description_id,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if branch is not None:
            _path_params['branch'] = branch
        if description_id is not None:
            _path_params['descriptionId'] = description_id
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/{branch}/descriptions/{descriptionId}',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def find_browser_descriptions(
        self,
        branch: StrictStr,
        term: Optional[StrictStr] = None,
        active: Optional[StrictBool] = None,
        module: Optional[List[StrictStr]] = None,
        language: Annotated[Optional[List[StrictStr]], Field(description="Set of two character language codes to match. The English language code 'en' will not be added automatically, in contrast to the Accept-Language header which always includes it. Accept-Language header still controls result FSN and PT language selection.")] = None,
        type: Annotated[Optional[List[StrictInt]], Field(description="Set of description type ids to use include. Defaults to any. Pick descendants of '900000000000446008 | Description type (core metadata concept) |'. Examples: 900000000000003001 (FSN), 900000000000013009 (Synonym), 900000000000550004 (Definition)")] = None,
        semantic_tag: Optional[StrictStr] = None,
        semantic_tags: Annotated[Optional[List[StrictStr]], Field(description="Set of semantic tags.")] = None,
        preferred_in: Annotated[Optional[List[StrictInt]], Field(description="Set of description language reference sets. The description must be preferred in at least one of these to match.")] = None,
        acceptable_in: Annotated[Optional[List[StrictInt]], Field(description="Set of description language reference sets. The description must be acceptable in at least one of these to match.")] = None,
        preferred_or_acceptable_in: Annotated[Optional[List[StrictInt]], Field(description="Set of description language reference sets. The description must be preferred OR acceptable in at least one of these to match.")] = None,
        concept_active: Optional[StrictBool] = None,
        concept_refset: Optional[StrictStr] = None,
        group_by_concept: Optional[StrictBool] = None,
        search_mode: Optional[StrictStr] = None,
        offset: Optional[StrictInt] = None,
        limit: Optional[StrictInt] = None,
        accept_language: Optional[StrictStr] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> PageBrowserDescriptionSearchResultComponent:
        """Search for concept descriptions.

        The Accept-Language header is used to specify the user's preferred language, 'en' is always added as a fallback if not already included in the list. Each language is used as an optional clause for matching and will include the correct character folding behaviour for that language. The Accept-Language header list is also used to chose the best translated FSN and PT values in the response.

        :param branch: (required)
        :type branch: str
        :param term:
        :type term: str
        :param active:
        :type active: bool
        :param module:
        :type module: List[str]
        :param language: Set of two character language codes to match. The English language code 'en' will not be added automatically, in contrast to the Accept-Language header which always includes it. Accept-Language header still controls result FSN and PT language selection.
        :type language: List[str]
        :param type: Set of description type ids to use include. Defaults to any. Pick descendants of '900000000000446008 | Description type (core metadata concept) |'. Examples: 900000000000003001 (FSN), 900000000000013009 (Synonym), 900000000000550004 (Definition)
        :type type: List[int]
        :param semantic_tag:
        :type semantic_tag: str
        :param semantic_tags: Set of semantic tags.
        :type semantic_tags: List[str]
        :param preferred_in: Set of description language reference sets. The description must be preferred in at least one of these to match.
        :type preferred_in: List[int]
        :param acceptable_in: Set of description language reference sets. The description must be acceptable in at least one of these to match.
        :type acceptable_in: List[int]
        :param preferred_or_acceptable_in: Set of description language reference sets. The description must be preferred OR acceptable in at least one of these to match.
        :type preferred_or_acceptable_in: List[int]
        :param concept_active:
        :type concept_active: bool
        :param concept_refset:
        :type concept_refset: str
        :param group_by_concept:
        :type group_by_concept: bool
        :param search_mode:
        :type search_mode: str
        :param offset:
        :type offset: int
        :param limit:
        :type limit: int
        :param accept_language:
        :type accept_language: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._find_browser_descriptions_serialize(
            branch=branch,
            term=term,
            active=active,
            module=module,
            language=language,
            type=type,
            semantic_tag=semantic_tag,
            semantic_tags=semantic_tags,
            preferred_in=preferred_in,
            acceptable_in=acceptable_in,
            preferred_or_acceptable_in=preferred_or_acceptable_in,
            concept_active=concept_active,
            concept_refset=concept_refset,
            group_by_concept=group_by_concept,
            search_mode=search_mode,
            offset=offset,
            limit=limit,
            accept_language=accept_language,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "PageBrowserDescriptionSearchResultComponent",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def find_browser_descriptions_with_http_info(
        self,
        branch: StrictStr,
        term: Optional[StrictStr] = None,
        active: Optional[StrictBool] = None,
        module: Optional[List[StrictStr]] = None,
        language: Annotated[Optional[List[StrictStr]], Field(description="Set of two character language codes to match. The English language code 'en' will not be added automatically, in contrast to the Accept-Language header which always includes it. Accept-Language header still controls result FSN and PT language selection.")] = None,
        type: Annotated[Optional[List[StrictInt]], Field(description="Set of description type ids to use include. Defaults to any. Pick descendants of '900000000000446008 | Description type (core metadata concept) |'. Examples: 900000000000003001 (FSN), 900000000000013009 (Synonym), 900000000000550004 (Definition)")] = None,
        semantic_tag: Optional[StrictStr] = None,
        semantic_tags: Annotated[Optional[List[StrictStr]], Field(description="Set of semantic tags.")] = None,
        preferred_in: Annotated[Optional[List[StrictInt]], Field(description="Set of description language reference sets. The description must be preferred in at least one of these to match.")] = None,
        acceptable_in: Annotated[Optional[List[StrictInt]], Field(description="Set of description language reference sets. The description must be acceptable in at least one of these to match.")] = None,
        preferred_or_acceptable_in: Annotated[Optional[List[StrictInt]], Field(description="Set of description language reference sets. The description must be preferred OR acceptable in at least one of these to match.")] = None,
        concept_active: Optional[StrictBool] = None,
        concept_refset: Optional[StrictStr] = None,
        group_by_concept: Optional[StrictBool] = None,
        search_mode: Optional[StrictStr] = None,
        offset: Optional[StrictInt] = None,
        limit: Optional[StrictInt] = None,
        accept_language: Optional[StrictStr] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[PageBrowserDescriptionSearchResultComponent]:
        """Search for concept descriptions.

        The Accept-Language header is used to specify the user's preferred language, 'en' is always added as a fallback if not already included in the list. Each language is used as an optional clause for matching and will include the correct character folding behaviour for that language. The Accept-Language header list is also used to chose the best translated FSN and PT values in the response.

        :param branch: (required)
        :type branch: str
        :param term:
        :type term: str
        :param active:
        :type active: bool
        :param module:
        :type module: List[str]
        :param language: Set of two character language codes to match. The English language code 'en' will not be added automatically, in contrast to the Accept-Language header which always includes it. Accept-Language header still controls result FSN and PT language selection.
        :type language: List[str]
        :param type: Set of description type ids to use include. Defaults to any. Pick descendants of '900000000000446008 | Description type (core metadata concept) |'. Examples: 900000000000003001 (FSN), 900000000000013009 (Synonym), 900000000000550004 (Definition)
        :type type: List[int]
        :param semantic_tag:
        :type semantic_tag: str
        :param semantic_tags: Set of semantic tags.
        :type semantic_tags: List[str]
        :param preferred_in: Set of description language reference sets. The description must be preferred in at least one of these to match.
        :type preferred_in: List[int]
        :param acceptable_in: Set of description language reference sets. The description must be acceptable in at least one of these to match.
        :type acceptable_in: List[int]
        :param preferred_or_acceptable_in: Set of description language reference sets. The description must be preferred OR acceptable in at least one of these to match.
        :type preferred_or_acceptable_in: List[int]
        :param concept_active:
        :type concept_active: bool
        :param concept_refset:
        :type concept_refset: str
        :param group_by_concept:
        :type group_by_concept: bool
        :param search_mode:
        :type search_mode: str
        :param offset:
        :type offset: int
        :param limit:
        :type limit: int
        :param accept_language:
        :type accept_language: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._find_browser_descriptions_serialize(
            branch=branch,
            term=term,
            active=active,
            module=module,
            language=language,
            type=type,
            semantic_tag=semantic_tag,
            semantic_tags=semantic_tags,
            preferred_in=preferred_in,
            acceptable_in=acceptable_in,
            preferred_or_acceptable_in=preferred_or_acceptable_in,
            concept_active=concept_active,
            concept_refset=concept_refset,
            group_by_concept=group_by_concept,
            search_mode=search_mode,
            offset=offset,
            limit=limit,
            accept_language=accept_language,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "PageBrowserDescriptionSearchResultComponent",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def find_browser_descriptions_without_preload_content(
        self,
        branch: StrictStr,
        term: Optional[StrictStr] = None,
        active: Optional[StrictBool] = None,
        module: Optional[List[StrictStr]] = None,
        language: Annotated[Optional[List[StrictStr]], Field(description="Set of two character language codes to match. The English language code 'en' will not be added automatically, in contrast to the Accept-Language header which always includes it. Accept-Language header still controls result FSN and PT language selection.")] = None,
        type: Annotated[Optional[List[StrictInt]], Field(description="Set of description type ids to use include. Defaults to any. Pick descendants of '900000000000446008 | Description type (core metadata concept) |'. Examples: 900000000000003001 (FSN), 900000000000013009 (Synonym), 900000000000550004 (Definition)")] = None,
        semantic_tag: Optional[StrictStr] = None,
        semantic_tags: Annotated[Optional[List[StrictStr]], Field(description="Set of semantic tags.")] = None,
        preferred_in: Annotated[Optional[List[StrictInt]], Field(description="Set of description language reference sets. The description must be preferred in at least one of these to match.")] = None,
        acceptable_in: Annotated[Optional[List[StrictInt]], Field(description="Set of description language reference sets. The description must be acceptable in at least one of these to match.")] = None,
        preferred_or_acceptable_in: Annotated[Optional[List[StrictInt]], Field(description="Set of description language reference sets. The description must be preferred OR acceptable in at least one of these to match.")] = None,
        concept_active: Optional[StrictBool] = None,
        concept_refset: Optional[StrictStr] = None,
        group_by_concept: Optional[StrictBool] = None,
        search_mode: Optional[StrictStr] = None,
        offset: Optional[StrictInt] = None,
        limit: Optional[StrictInt] = None,
        accept_language: Optional[StrictStr] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Search for concept descriptions.

        The Accept-Language header is used to specify the user's preferred language, 'en' is always added as a fallback if not already included in the list. Each language is used as an optional clause for matching and will include the correct character folding behaviour for that language. The Accept-Language header list is also used to chose the best translated FSN and PT values in the response.

        :param branch: (required)
        :type branch: str
        :param term:
        :type term: str
        :param active:
        :type active: bool
        :param module:
        :type module: List[str]
        :param language: Set of two character language codes to match. The English language code 'en' will not be added automatically, in contrast to the Accept-Language header which always includes it. Accept-Language header still controls result FSN and PT language selection.
        :type language: List[str]
        :param type: Set of description type ids to use include. Defaults to any. Pick descendants of '900000000000446008 | Description type (core metadata concept) |'. Examples: 900000000000003001 (FSN), 900000000000013009 (Synonym), 900000000000550004 (Definition)
        :type type: List[int]
        :param semantic_tag:
        :type semantic_tag: str
        :param semantic_tags: Set of semantic tags.
        :type semantic_tags: List[str]
        :param preferred_in: Set of description language reference sets. The description must be preferred in at least one of these to match.
        :type preferred_in: List[int]
        :param acceptable_in: Set of description language reference sets. The description must be acceptable in at least one of these to match.
        :type acceptable_in: List[int]
        :param preferred_or_acceptable_in: Set of description language reference sets. The description must be preferred OR acceptable in at least one of these to match.
        :type preferred_or_acceptable_in: List[int]
        :param concept_active:
        :type concept_active: bool
        :param concept_refset:
        :type concept_refset: str
        :param group_by_concept:
        :type group_by_concept: bool
        :param search_mode:
        :type search_mode: str
        :param offset:
        :type offset: int
        :param limit:
        :type limit: int
        :param accept_language:
        :type accept_language: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._find_browser_descriptions_serialize(
            branch=branch,
            term=term,
            active=active,
            module=module,
            language=language,
            type=type,
            semantic_tag=semantic_tag,
            semantic_tags=semantic_tags,
            preferred_in=preferred_in,
            acceptable_in=acceptable_in,
            preferred_or_acceptable_in=preferred_or_acceptable_in,
            concept_active=concept_active,
            concept_refset=concept_refset,
            group_by_concept=group_by_concept,
            search_mode=search_mode,
            offset=offset,
            limit=limit,
            accept_language=accept_language,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "PageBrowserDescriptionSearchResultComponent",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _find_browser_descriptions_serialize(
        self,
        branch,
        term,
        active,
        module,
        language,
        type,
        semantic_tag,
        semantic_tags,
        preferred_in,
        acceptable_in,
        preferred_or_acceptable_in,
        concept_active,
        concept_refset,
        group_by_concept,
        search_mode,
        offset,
        limit,
        accept_language,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
            'module': 'multi',
            'language': 'multi',
            'type': 'multi',
            'semanticTags': 'multi',
            'preferredIn': 'multi',
            'acceptableIn': 'multi',
            'preferredOrAcceptableIn': 'multi',
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if branch is not None:
            _path_params['branch'] = branch
        # process the query parameters
        if term is not None:
            
            _query_params.append(('term', term))
            
        if active is not None:
            
            _query_params.append(('active', active))
            
        if module is not None:
            
            _query_params.append(('module', module))
            
        if language is not None:
            
            _query_params.append(('language', language))
            
        if type is not None:
            
            _query_params.append(('type', type))
            
        if semantic_tag is not None:
            
            _query_params.append(('semanticTag', semantic_tag))
            
        if semantic_tags is not None:
            
            _query_params.append(('semanticTags', semantic_tags))
            
        if preferred_in is not None:
            
            _query_params.append(('preferredIn', preferred_in))
            
        if acceptable_in is not None:
            
            _query_params.append(('acceptableIn', acceptable_in))
            
        if preferred_or_acceptable_in is not None:
            
            _query_params.append(('preferredOrAcceptableIn', preferred_or_acceptable_in))
            
        if concept_active is not None:
            
            _query_params.append(('conceptActive', concept_active))
            
        if concept_refset is not None:
            
            _query_params.append(('conceptRefset', concept_refset))
            
        if group_by_concept is not None:
            
            _query_params.append(('groupByConcept', group_by_concept))
            
        if search_mode is not None:
            
            _query_params.append(('searchMode', search_mode))
            
        if offset is not None:
            
            _query_params.append(('offset', offset))
            
        if limit is not None:
            
            _query_params.append(('limit', limit))
            
        # process the header parameters
        if accept_language is not None:
            _header_params['Accept-Language'] = accept_language
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/browser/{branch}/descriptions',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def find_descriptions(
        self,
        branch: StrictStr,
        description_ids: Annotated[Optional[List[StrictStr]], Field(description="Set of description ids to match")] = None,
        concept_id: Annotated[Optional[StrictStr], Field(description="The concept id to match")] = None,
        concept_ids: Annotated[Optional[List[StrictStr]], Field(description="Set of concept ids to match")] = None,
        offset: Optional[StrictInt] = None,
        limit: Optional[StrictInt] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ItemsPageDescriptionComponent:
        """find_descriptions


        :param branch: (required)
        :type branch: str
        :param description_ids: Set of description ids to match
        :type description_ids: List[str]
        :param concept_id: The concept id to match
        :type concept_id: str
        :param concept_ids: Set of concept ids to match
        :type concept_ids: List[str]
        :param offset:
        :type offset: int
        :param limit:
        :type limit: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._find_descriptions_serialize(
            branch=branch,
            description_ids=description_ids,
            concept_id=concept_id,
            concept_ids=concept_ids,
            offset=offset,
            limit=limit,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "ItemsPageDescriptionComponent",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def find_descriptions_with_http_info(
        self,
        branch: StrictStr,
        description_ids: Annotated[Optional[List[StrictStr]], Field(description="Set of description ids to match")] = None,
        concept_id: Annotated[Optional[StrictStr], Field(description="The concept id to match")] = None,
        concept_ids: Annotated[Optional[List[StrictStr]], Field(description="Set of concept ids to match")] = None,
        offset: Optional[StrictInt] = None,
        limit: Optional[StrictInt] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[ItemsPageDescriptionComponent]:
        """find_descriptions


        :param branch: (required)
        :type branch: str
        :param description_ids: Set of description ids to match
        :type description_ids: List[str]
        :param concept_id: The concept id to match
        :type concept_id: str
        :param concept_ids: Set of concept ids to match
        :type concept_ids: List[str]
        :param offset:
        :type offset: int
        :param limit:
        :type limit: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._find_descriptions_serialize(
            branch=branch,
            description_ids=description_ids,
            concept_id=concept_id,
            concept_ids=concept_ids,
            offset=offset,
            limit=limit,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "ItemsPageDescriptionComponent",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def find_descriptions_without_preload_content(
        self,
        branch: StrictStr,
        description_ids: Annotated[Optional[List[StrictStr]], Field(description="Set of description ids to match")] = None,
        concept_id: Annotated[Optional[StrictStr], Field(description="The concept id to match")] = None,
        concept_ids: Annotated[Optional[List[StrictStr]], Field(description="Set of concept ids to match")] = None,
        offset: Optional[StrictInt] = None,
        limit: Optional[StrictInt] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """find_descriptions


        :param branch: (required)
        :type branch: str
        :param description_ids: Set of description ids to match
        :type description_ids: List[str]
        :param concept_id: The concept id to match
        :type concept_id: str
        :param concept_ids: Set of concept ids to match
        :type concept_ids: List[str]
        :param offset:
        :type offset: int
        :param limit:
        :type limit: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._find_descriptions_serialize(
            branch=branch,
            description_ids=description_ids,
            concept_id=concept_id,
            concept_ids=concept_ids,
            offset=offset,
            limit=limit,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "ItemsPageDescriptionComponent",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _find_descriptions_serialize(
        self,
        branch,
        description_ids,
        concept_id,
        concept_ids,
        offset,
        limit,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
            'descriptionIds': 'multi',
            'conceptIds': 'multi',
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if branch is not None:
            _path_params['branch'] = branch
        # process the query parameters
        if description_ids is not None:
            
            _query_params.append(('descriptionIds', description_ids))
            
        if concept_id is not None:
            
            _query_params.append(('conceptId', concept_id))
            
        if concept_ids is not None:
            
            _query_params.append(('conceptIds', concept_ids))
            
        if offset is not None:
            
            _query_params.append(('offset', offset))
            
        if limit is not None:
            
            _query_params.append(('limit', limit))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/{branch}/descriptions',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )


