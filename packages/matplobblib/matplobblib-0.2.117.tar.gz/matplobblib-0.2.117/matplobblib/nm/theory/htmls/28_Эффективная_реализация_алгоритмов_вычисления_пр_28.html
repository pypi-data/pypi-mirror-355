<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>28. Эффективная реализация алгоритмов вычисления произведения матриц.</title>
    <style>
        body { font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif; margin: 20px; line-height: 1.6; color: #333; }
        h1 { color: #111; border-bottom: 2px solid #eee; padding-bottom: 0.3em; margin-top: 0; }
        img { max-width: 100%; height: auto; display: block; margin: 1em 0; border: 1px solid #ddd; border-radius: 4px; box-shadow: 0 2px 4px rgba(0,0,0,0.1); }
        p { margin: 1em 0; }
        div, section, article { margin-bottom: 1em; }
        /* Вы можете добавить сюда больше стилей или ссылку на CSS из оригинального документа, если это необходимо */
    </style>
</head>
<body>
<h1 class="c10" id="h.f3pr1sblrb4b"><span class="c17">28. Эффективная реализация алгоритмов вычисления произведения матриц.</span></h1><p class="c9"><span class="c12">Умножение матриц</span><span class="c1"> – одна из ключевых операций в линейной алгебре, машинном обучении и научных вычислениях. Для его эффективной реализации создано огромное количество методов.</span></p><p class="c9"><span class="c12">1. Наивное умножение</span><span class="c1"> (стандартный алгоритм).</span></p><p class="c9"><span class="c4">Пусть есть матрица </span><img src="file:///C:/Users/ivant/Desktop/proj/matplobblib/htmls/NM/images/image1.png"/><span class="c4"> размера </span><img src="file:///C:/Users/ivant/Desktop/proj/matplobblib/htmls/NM/images/image2.png"/><span class="c4"> и матрица </span><img src="file:///C:/Users/ivant/Desktop/proj/matplobblib/htmls/NM/images/image3.png"/><span class="c4"> размером </span><img src="file:///C:/Users/ivant/Desktop/proj/matplobblib/htmls/NM/images/image4.png"/><span class="c4">. Матрица </span><img src="file:///C:/Users/ivant/Desktop/proj/matplobblib/htmls/NM/images/image5.png"/><span class="c4"> – результат произведения размера </span><img src="file:///C:/Users/ivant/Desktop/proj/matplobblib/htmls/NM/images/image6.png"/><span class="c1">: </span></p><p class="c16"><img src="file:///C:/Users/ivant/Desktop/proj/matplobblib/htmls/NM/images/image7.png"/></p><p class="c9"><span class="c4">Для умножения матриц требуется (при </span><img src="file:///C:/Users/ivant/Desktop/proj/matplobblib/htmls/NM/images/image8.png"/><span class="c4">): </span><img src="file:///C:/Users/ivant/Desktop/proj/matplobblib/htmls/NM/images/image9.png"/><span class="c4"> умножений и </span><img src="file:///C:/Users/ivant/Desktop/proj/matplobblib/htmls/NM/images/image10.png"/><span class="c4"> суммирований </span><img src="file:///C:/Users/ivant/Desktop/proj/matplobblib/htmls/NM/images/image11.png"/><span class="c4"> </span><span class="c12">Сложность </span><span class="c4">наивного алгоритма: </span><img src="file:///C:/Users/ivant/Desktop/proj/matplobblib/htmls/NM/images/image12.png"/><span class="c1">.</span></p><p class="c9"><span class="c22 c12">2. Блочное умножение.</span></p><p class="c9"><span class="c4">С целью повышения эффективности использования кэш-памяти CPU существует алгоритм </span><span class="c12">блочного умножения</span><span class="c4"> матриц, в котором результирующая матрица формируется поблочно с использованием известной формулы </span><img src="file:///C:/Users/ivant/Desktop/proj/matplobblib/htmls/NM/images/image13.png"/><span class="c4">, либо </span><span class="c4">её</span><span class="c4"> более быстрых аналогов, а размер обрабатываемых данных на каждой итерации не превышает </span><span class="c4">ёмкость</span><span class="c4"> кэш-памяти. </span><span class="c12">Сложность</span><span class="c4">: </span><img src="file:///C:/Users/ivant/Desktop/proj/matplobblib/htmls/NM/images/image14.png"/><span class="c1">.</span></p><p class="c9"><span class="c4">Размер блока напрямую зависит от архитектуры вычислительной системы и определяет время выполнения умножения. Аналогичный подход применяется при умножении матриц с использованием </span><span class="c4"><a class="c30" href="https://www.google.com/url?q=https://ru.wikipedia.org/wiki/GPU&amp;sa=D&amp;source=editors&amp;ust=1749815225359386&amp;usg=AOvVaw3AepKG6Tpw_Lcft5tjg1YI">GPU</a></span><span class="c1"> с оптимизацией использования разделяемой памяти ограниченного объёма.</span></p><p class="c9"><span class="c1">(по сути то же наивное умножение, но блоками в целях оптимизации затрат памяти и времени)</span></p><p class="c9"><span class="c12">3. Алгоритм Штрассена </span><span class="c4">(см. </span><span class="c26 c4"><a class="c30" href="#h.8k4uop79fp7">вопрос 29</a></span><span class="c1">).</span></p><p class="c9"><span class="c12">4. Алгоритм Копперсмита–Винограда.</span></p><p class="c9"><span class="c12">Алгоритм Копперсмита–Винограда </span><span class="c4">–</span><span class="c12"> </span><span class="c4">улучшенная версия Штрассена с вычислительной </span><span class="c12">сложностью </span><img src="file:///C:/Users/ivant/Desktop/proj/matplobblib/htmls/NM/images/image15.png"/><span class="c4">. О</span><span class="c1">бладает лучшей асимптотикой среди известных алгоритмов умножения матриц. </span></p><p class="c9"><span class="c1">На практике алгоритм Копперсмита–Винограда не используется, так как он имеет очень большую константу пропорциональности и начинает выигрывать в быстродействии у других известных алгоритмов только для матриц, размер которых превышает память современных компьютеров.</span></p><p class="c9"><span class="c12 c22">5. Реализация в numpy.</span></p><p class="c9"><span class="c12">NumPy </span><span class="c4">использует BLAS (Basic Linear Algebra Subprograms) – </span><span class="c4">высокооптимизированные</span><span class="c1"> низкоуровневые библиотеки, предназначенные для выполнения основных операций линейной алгебры. </span></p><p class="c9"><span class="c12">Сложность</span><span class="c4">: </span><img src="file:///C:/Users/ivant/Desktop/proj/matplobblib/htmls/NM/images/image14.png"/><span class="c1">.</span></p><p class="c9"><span class="c4">Почему NumPy </span><span class="c12">эффективен</span><span class="c1">?</span></p><ul class="c20 lst-kix_s6558encdjv-0 start"><li class="c8 li-bullet-0"><span class="c1">Использование параллельных вычислений.</span></li><li class="c8 li-bullet-0"><span class="c1">Оптимизация доступа к памяти (блочное умножение, минимизация кэш-промахов).</span></li></ul><ul class="c20 lst-kix_s6558encdjv-1 start"><li class="c24 c27 c39 li-bullet-0"><span class="c1">Row-major или column-major (методы хранения многомерных массивов в линейном пространстве, например, random access memory – запоминающее устройство с произвольным доступом).</span></li><li class="c24 c27 c39 li-bullet-0"><span class="c1">Кэш-дружественные алгоритмы: разбиение матриц на блоки, которые помещаются в кэш.</span></li></ul><ul class="c20 lst-kix_s6558encdjv-0"><li class="c8 li-bullet-0"><span class="c1">Многопоточность (параллельное вычисление блоков матрицы).</span></li><li class="c8 li-bullet-0"><span class="c1">Алгоритмы в зависимости от размера:</span></li></ul><ul class="c20 lst-kix_s6558encdjv-1 start"><li class="c24 c27 c39 li-bullet-0"><span class="c1">Для маленьких матриц – наивный метод.</span></li><li class="c24 c27 c39 li-bullet-0"><span class="c1">Для больших – Штрассен или другие оптимизированные методы.</span></li></ul><p class="c6"><span class="c1"></span></p>
</body>
</html>