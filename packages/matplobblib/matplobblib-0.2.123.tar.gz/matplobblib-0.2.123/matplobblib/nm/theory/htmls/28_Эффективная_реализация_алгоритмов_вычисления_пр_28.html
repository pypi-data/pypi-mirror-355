<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>28. Эффективная реализация алгоритмов вычисления произведения матриц.</title>
    <style>
        body { font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif; margin: 20px; line-height: 1.6; color: #333; }
        h1 { color: #111; border-bottom: 2px solid #eee; padding-bottom: 0.3em; margin-top: 0; }
        img { max-width: 100%; height: auto; display: block; margin: 1em 0; border: 1px solid #ddd; border-radius: 4px; box-shadow: 0 2px 4px rgba(0,0,0,0.1); }
        p { margin: 1em 0; }
        div, section, article { margin-bottom: 1em; }
        /* Вы можете добавить сюда больше стилей или ссылку на CSS из оригинального документа, если это необходимо */
    </style>
</head>
<body>
<h1 class="c5" id="h.f3pr1sblrb4b"><span class="c3">28. Эффективная реализация алгоритмов вычисления произведения матриц.</span></h1><p class="c7 c8"><span class="c11 c4">Умножение матриц</span><span class="c6 c2"> – одна из ключевых операций в линейной алгебре, машинном обучении и научных вычислениях. Для его эффективной реализации создано огромное количество методов.</span></p><p class="c7 c8"><span class="c11 c4">1. Наивное умножение</span><span class="c6 c2"> (стандартный алгоритм).</span></p><p class="c7 c8"><span class="c2">Пусть есть матрица </span><img src="file:///C:/Users/ivant/Desktop/proj/matplobblib/htmls/NM/images/image12.png"/><span class="c2"> размера </span><img src="file:///C:/Users/ivant/Desktop/proj/matplobblib/htmls/NM/images/image13.png"/><span class="c2"> и матрица </span><img src="file:///C:/Users/ivant/Desktop/proj/matplobblib/htmls/NM/images/image14.png"/><span class="c2"> размером </span><img src="file:///C:/Users/ivant/Desktop/proj/matplobblib/htmls/NM/images/image15.png"/><span class="c2">. Матрица </span><img src="file:///C:/Users/ivant/Desktop/proj/matplobblib/htmls/NM/images/image16.png"/><span class="c2"> – результат произведения размера </span><img src="file:///C:/Users/ivant/Desktop/proj/matplobblib/htmls/NM/images/image17.png"/><span class="c6 c2">: </span></p><p class="c24 c8"><img src="file:///C:/Users/ivant/Desktop/proj/matplobblib/htmls/NM/images/image18.png"/></p><p class="c7 c8"><span class="c2">Для умножения матриц требуется (при </span><img src="file:///C:/Users/ivant/Desktop/proj/matplobblib/htmls/NM/images/image19.png"/><span class="c2">): </span><img src="file:///C:/Users/ivant/Desktop/proj/matplobblib/htmls/NM/images/image20.png"/><span class="c2"> умножений и </span><img src="file:///C:/Users/ivant/Desktop/proj/matplobblib/htmls/NM/images/image21.png"/><span class="c2"> суммирований </span><img src="file:///C:/Users/ivant/Desktop/proj/matplobblib/htmls/NM/images/image22.png"/><span class="c2"> </span><span class="c11 c4">Сложность </span><span class="c2">наивного алгоритма: </span><img src="file:///C:/Users/ivant/Desktop/proj/matplobblib/htmls/NM/images/image23.png"/><span class="c6 c2">.</span></p><p class="c7 c8"><span class="c6 c11 c4">2. Блочное умножение.</span></p><p class="c7 c8"><span class="c2">С целью повышения эффективности использования кэш-памяти CPU существует алгоритм </span><span class="c11 c4">блочного умножения</span><span class="c2"> матриц, в котором результирующая матрица формируется поблочно с использованием известной формулы </span><img src="file:///C:/Users/ivant/Desktop/proj/matplobblib/htmls/NM/images/image24.png"/><span class="c2">, либо </span><span class="c2">её</span><span class="c2"> более быстрых аналогов, а размер обрабатываемых данных на каждой итерации не превышает </span><span class="c2">ёмкость</span><span class="c2"> кэш-памяти. </span><span class="c11 c4">Сложность</span><span class="c2">: </span><img src="file:///C:/Users/ivant/Desktop/proj/matplobblib/htmls/NM/images/image25.png"/><span class="c6 c2">.</span></p><p class="c7 c8"><span class="c2">Размер блока напрямую зависит от архитектуры вычислительной системы и определяет время выполнения умножения. Аналогичный подход применяется при умножении матриц с использованием </span><span class="c2"><a class="c20" href="https://www.google.com/url?q=https://ru.wikipedia.org/wiki/GPU&amp;sa=D&amp;source=editors&amp;ust=1749905163585756&amp;usg=AOvVaw197M29JMhewimNCTYgpM83">GPU</a></span><span class="c6 c2"> с оптимизацией использования разделяемой памяти ограниченного объёма.</span></p><p class="c7 c8"><span class="c6 c2">(по сути то же наивное умножение, но блоками в целях оптимизации затрат памяти и времени)</span></p><p class="c7 c8"><span class="c11 c4">3. Алгоритм Штрассена </span><span class="c2">(см. </span><span class="c2 c40"><a class="c20" href="#h.8k4uop79fp7">вопрос 29</a></span><span class="c6 c2">).</span></p><p class="c7 c8"><span class="c11 c4">4. Алгоритм Копперсмита–Винограда.</span></p><p class="c7 c8"><span class="c11 c4">Алгоритм Копперсмита–Винограда </span><span class="c2">–</span><span class="c11 c4"> </span><span class="c2">улучшенная версия Штрассена с вычислительной </span><span class="c11 c4">сложностью </span><img src="file:///C:/Users/ivant/Desktop/proj/matplobblib/htmls/NM/images/image26.png"/><span class="c2">. О</span><span class="c6 c2">бладает лучшей асимптотикой среди известных алгоритмов умножения матриц. </span></p><p class="c7 c8"><span class="c6 c2">На практике алгоритм Копперсмита–Винограда не используется, так как он имеет очень большую константу пропорциональности и начинает выигрывать в быстродействии у других известных алгоритмов только для матриц, размер которых превышает память современных компьютеров.</span></p><p class="c7 c8"><span class="c6 c11 c4">5. Реализация в numpy.</span></p><p class="c7 c8"><span class="c11 c4">NumPy </span><span class="c2">использует BLAS (Basic Linear Algebra Subprograms) – </span><span class="c2">высокооптимизированные</span><span class="c6 c2"> низкоуровневые библиотеки, предназначенные для выполнения основных операций линейной алгебры. </span></p><p class="c7 c8"><span class="c11 c4">Сложность</span><span class="c2">: </span><img src="file:///C:/Users/ivant/Desktop/proj/matplobblib/htmls/NM/images/image25.png"/><span class="c6 c2">.</span></p><p class="c7 c8"><span class="c2">Почему NumPy </span><span class="c11 c4">эффективен</span><span class="c6 c2">?</span></p><ul class="c9 lst-kix_s6558encdjv-0 start"><li class="c7 c12 li-bullet-0"><span class="c6 c2">Использование параллельных вычислений.</span></li><li class="c7 c12 li-bullet-0"><span class="c6 c2">Оптимизация доступа к памяти (блочное умножение, минимизация кэш-промахов).</span></li></ul><ul class="c9 lst-kix_s6558encdjv-1 start"><li class="c7 c25 li-bullet-0"><span class="c6 c2">Row-major или column-major (методы хранения многомерных массивов в линейном пространстве, например, random access memory – запоминающее устройство с произвольным доступом).</span></li><li class="c7 c25 li-bullet-0"><span class="c6 c2">Кэш-дружественные алгоритмы: разбиение матриц на блоки, которые помещаются в кэш.</span></li></ul><ul class="c9 lst-kix_s6558encdjv-0"><li class="c7 c12 li-bullet-0"><span class="c6 c2">Многопоточность (параллельное вычисление блоков матрицы).</span></li><li class="c7 c12 li-bullet-0"><span class="c6 c2">Алгоритмы в зависимости от размера:</span></li></ul><ul class="c9 lst-kix_s6558encdjv-1 start"><li class="c7 c25 li-bullet-0"><span class="c6 c2">Для маленьких матриц – наивный метод.</span></li><li class="c7 c25 li-bullet-0"><span class="c6 c2">Для больших – Штрассен или другие оптимизированные методы.</span></li></ul><p class="c7 c14 c8"><span class="c6 c2"></span></p>
</body>
</html>