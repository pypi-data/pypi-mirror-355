from collections.abc import Sequence
from typing import Annotated, overload

from numpy.typing import ArrayLike

from . import Util as Util


class Circle(Shape):
    def __init__(self, radius: float, center x: float, center y: float) -> None: ...

    def collide(self, arg: CollisionObject, /) -> bool: ...

    def r(self) -> float:
        """radius of the circle"""

    def center(self) -> Annotated[ArrayLike, dict(dtype='float64', shape=(2), order='C')]:
        """center of the circle"""

    def x(self) -> float:
        """x-coordinate of center"""

    def y(self) -> float:
        """y-coordinate of center"""

    def draw(self, renderer: object, draw_params: object | None = None) -> None: ...

    def __getstate__(self) -> str: ...

    def __setstate__(self, arg: str, /) -> None: ...

class CollisionChecker:
    def __init__(self) -> None: ...

    def number_of_obstacles(self) -> int: ...

    def __str__(self) -> str: ...

    def add_collision_object(self, arg: CollisionObject, /) -> None: ...

    def clone(self) -> CollisionChecker: ...

    def collide(self, arg: CollisionObject, /) -> bool: ...

    def raytrace(self, arg0: float, arg1: float, arg2: float, arg3: float, arg4: bool, /) -> list: ...

    def find_all_colliding_objects(self, arg: CollisionObject, /) -> list[CollisionObject]: ...

    def time_slice(self, arg: int, /) -> CollisionChecker: ...

    def window_query(self, arg: RectAABB, /) -> CollisionChecker: ...

    def obstacles(self) -> list[CollisionObject]: ...

    def any_collides(self, arg: Sequence[CollisionObject], /) -> bool: ...

    def draw(self, renderer: object, draw_params: object | None = None) -> None: ...

    def __getstate__(self) -> str: ...

    def __setstate__(self, arg: str, /) -> None: ...

class CollisionObject:
    pass

class OBBTrajectoryBatch:
    def __init__(self, arg0: Annotated[ArrayLike, dict(dtype='float64', shape=(None, None), writable=False)], arg1: Annotated[ArrayLike, dict(dtype='int32', shape=(None), writable=False)], arg2: float, arg3: float, /) -> None:
        """
        See 05_collision_checks_dynamic_obstacles.ipynb for an initialization example.
        """

    def to_tvobstacle(self) -> list:
        """
        Returns a list of TimeVariantCollisionObjects corresponding to the OBB trajectory batch.
        """

class Point(Shape):
    def __init__(self, x: float, y: float) -> None: ...

    def collide(self, arg: CollisionObject, /) -> bool: ...

    def center(self) -> Annotated[ArrayLike, dict(dtype='float64', shape=(2), order='C')]: ...

    def __getstate__(self) -> str: ...

    def __setstate__(self, arg: str, /) -> None: ...

class Polygon(Shape):
    @overload
    def __init__(self, outer_boundary: Sequence[Sequence[float]], holes: Sequence[Sequence[Sequence[float]]], triangle mesh: Sequence[Triangle]) -> None: ...

    @overload
    def __init__(self, arg0: Sequence[Sequence[float]], arg1: Sequence[Sequence[Sequence[float]]], /) -> None: ...

    @overload
    def __init__(self, arg0: Sequence[Sequence[float]], arg1: Sequence[Sequence[Sequence[float]]], arg2: int, arg3: float, /) -> None: ...

    def collide(self, arg: CollisionObject, /) -> bool: ...

    def triangle_mesh(self) -> list[Triangle]: ...

    def vertices(self) -> list: ...

    def hole_vertices(self) -> list: ...

    def __str__(self) -> str: ...

    def draw(self, renderer: object, draw_params: object | None = None) -> None: ...

    def __getstate__(self) -> str: ...

    def __setstate__(self, arg: str, /) -> None: ...

class RectAABB(Shape):
    def __init__(self, half_width: float, half_height: float, center_x: float, center_y: float) -> None: ...

    def collide(self, arg: CollisionObject, /) -> bool: ...

    def __str__(self) -> str: ...

    def set_all(self, arg0: float, arg1: float, arg2: float, arg3: float, /) -> None: ...

    def min_x(self) -> float: ...

    def min_y(self) -> float: ...

    def max_x(self) -> float: ...

    def max_y(self) -> float: ...

    @property
    def r_x(self) -> float: ...

    def draw(self, renderer: object, draw_params: object | None = None) -> None: ...

    def __getstate__(self) -> str: ...

    def __setstate__(self, arg: str, /) -> None: ...

class RectOBB(Shape):
    def __init__(self, width/2: float, height/2: float, orientation: float, center x: float, center y: float) -> None: ...

    def collide(self, arg: CollisionObject, /) -> bool: ...

    def set_center(self, arg0: float, arg1: float, /) -> None: ...

    def merge(self, arg: RectOBB, /) -> RectOBB: ...

    def local_x_axis(self) -> Annotated[ArrayLike, dict(dtype='float64', shape=(2), order='C')]: ...

    def local_y_axis(self) -> Annotated[ArrayLike, dict(dtype='float64', shape=(2), order='C')]: ...

    def orientation(self) -> float:
        """OBB orientation"""

    def r_x(self) -> float:
        """Positive halfwidth extent of OBB along local x-axis"""

    def r_y(self) -> float:
        """Positive halfwidth extent of OBB along local y-axis"""

    def center(self) -> Annotated[ArrayLike, dict(dtype='float64', shape=(2), order='C')]: ...

    def __str__(self) -> str: ...

    def draw(self, renderer: object, draw_params: object | None = None) -> None: ...

    def __getstate__(self) -> str: ...

    def __setstate__(self, arg: str, /) -> None: ...

class Shape(CollisionObject):
    def getAABB(self) -> RectAABB: ...

class ShapeGroup(CollisionObject):
    def __init__(self) -> None: ...

    def collide(self, arg: CollisionObject, /) -> bool: ...

    def overlap(self, arg: ShapeGroup, /) -> list[tuple[int, int]]: ...

    def overlap_map(self, arg: ShapeGroup, /) -> dict: ...

    def add_shape(self, arg: Shape, /) -> None: ...

    def size(self) -> int: ...

    def window_query(self, arg: RectAABB, /) -> ShapeGroup: ...

    def unpack(self) -> list[Shape]: ...

    def draw(self, renderer: object, draw_params: object | None = None) -> None: ...

    def __getstate__(self) -> str: ...

    def __setstate__(self, arg: str, /) -> None: ...

class TimeVariantCollisionObject(CollisionObject):
    def __init__(self, time_start_idx: int) -> None: ...

    def collide(self, arg: CollisionObject, /) -> bool: ...

    def append_obstacle(self, arg: CollisionObject, /) -> int: ...

    def time_start_idx(self) -> int: ...

    def time_end_idx(self) -> int: ...

    def obstacle_at_time(self, arg: int, /) -> CollisionObject: ...

    def draw(self, renderer: object, draw_params: object | None = None) -> None: ...

    def __getstate__(self) -> str: ...

    def __setstate__(self, arg: str, /) -> None: ...

class Triangle(Shape):
    def __init__(self, x1: float, y1: float, x2: float, y2: float, x3: float, y3: float) -> None: ...

    def collide(self, arg: CollisionObject, /) -> bool: ...

    def vertices(self) -> list: ...

    def __str__(self) -> str: ...

    def draw(self, renderer: object, draw_params: object | None = None) -> None: ...

    def __getstate__(self) -> str: ...

    def __setstate__(self, arg: str, /) -> None: ...
