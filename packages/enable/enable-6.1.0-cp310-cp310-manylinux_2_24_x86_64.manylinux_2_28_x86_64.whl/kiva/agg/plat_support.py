# This file was automatically generated by SWIG (https://www.swig.org).
# Version 4.3.1
#
# Do not make changes to this file unless you know what you are doing - modify
# the SWIG interface file instead.

from sys import version_info as _swig_python_version_info
# Import the low-level C/C++ module
if __package__ or "." in __name__:
    from . import _plat_support
else:
    import _plat_support

try:
    import builtins as __builtin__
except ImportError:
    import __builtin__

def _swig_repr(self):
    try:
        strthis = "proxy of " + self.this.__repr__()
    except __builtin__.Exception:
        strthis = ""
    return "<%s.%s; %s >" % (self.__class__.__module__, self.__class__.__name__, strthis,)


def _swig_setattr_nondynamic_instance_variable(set):
    def set_instance_attr(self, name, value):
        if name == "this":
            set(self, name, value)
        elif name == "thisown":
            self.this.own(value)
        elif hasattr(self, name) and isinstance(getattr(type(self), name), property):
            set(self, name, value)
        else:
            raise AttributeError("You cannot add instance attributes to %s" % self)
    return set_instance_attr


def _swig_setattr_nondynamic_class_variable(set):
    def set_class_attr(cls, name, value):
        if hasattr(cls, name) and not isinstance(getattr(cls, name), property):
            set(cls, name, value)
        else:
            raise AttributeError("You cannot add class attributes to %s" % cls)
    return set_class_attr


def _swig_add_metaclass(metaclass):
    """Class decorator for adding a metaclass to a SWIG wrapped class - a slimmed down version of six.add_metaclass"""
    def wrapper(cls):
        return metaclass(cls.__name__, cls.__bases__, cls.__dict__.copy())
    return wrapper


class _SwigNonDynamicMeta(type):
    """Meta class to enforce nondynamic attributes (no new attributes) for a class"""
    __setattr__ = _swig_setattr_nondynamic_class_variable(type.__setattr__)



from numpy import ndarray

def is_array(obj):
    return type(obj) is ndarray

def is_correct_type(obj, numeric_type):
    return is_array(obj) and (obj.dtype == numeric_type)

def numpy_check(obj, typecode,
                exact_size = [],
                must_be_contiguous = 1,
                allow_coersion = 0):

    if is_correct_type(obj, typecode):
        ary = obj
    elif allow_coersion:
        ary = asarray(obj,typecode)
    else:
        raise TypeError("input is not an array or the array has the wrong type")

    if must_be_contiguous and not ary.flags["CONTIGUOUS"]:
        if allow_coersion:
            ary = ary.copy()
        else:
            raise TypeError("input array must be contiguous")

# check number of dimensions
    required_dims = len(exact_size)
    if required_dims and required_dims != len(ary.shape):
        raise ValueError("The input array does not have the correct shape")

# check exact shape of each dimension
    cnt = 0
    for desired,actual in zip(exact_size,ary.shape):
        if desired != -1 and desired != actual:
            raise ValueError("The %d dimensions of the array has the wrong shape" % (cnt))
        cnt += 1

    return ary

pix_format_undefined = _plat_support.pix_format_undefined
pix_format_gray8 = _plat_support.pix_format_gray8
pix_format_rgb555 = _plat_support.pix_format_rgb555
pix_format_rgb565 = _plat_support.pix_format_rgb565
pix_format_rgb24 = _plat_support.pix_format_rgb24
pix_format_bgr24 = _plat_support.pix_format_bgr24
pix_format_rgba32 = _plat_support.pix_format_rgba32
pix_format_argb32 = _plat_support.pix_format_argb32
pix_format_abgr32 = _plat_support.pix_format_abgr32
pix_format_bgra32 = _plat_support.pix_format_bgra32
end_of_pix_formats = _plat_support.end_of_pix_formats
class PixelMap(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    __swig_destroy__ = _plat_support.delete_PixelMap

    def __init__(self, width, height, format, clear_val, bottom_up):
        _plat_support.PixelMap_swiginit(self, _plat_support.new_PixelMap(width, height, format, clear_val, bottom_up))

    def draw(self, h_dc, x=0, y=0, scale=1.0):
    # fix me: brittle becuase we are hard coding
    # module and class name.  Done cause SWIG 1.3.24 does
    # some funky overloading stuff in it that breaks keyword
    # arguments.
        result = _plat_support.PixelMap_draw(self, h_dc, x, y, scale)
        return result



    def convert_to_rgbarray(self):
        return _plat_support.PixelMap_convert_to_rgbarray(self)

    def convert_to_argb32string(self):
        return _plat_support.PixelMap_convert_to_argb32string(self)


    def set_bmp_array(self):
         self.bmp_array = pixel_map_as_unowned_array(self)
         return self

    def draw_to_wxwindow(self, window, x, y):
        import wx
        window_dc = getattr(window,'_dc',None)
        if window_dc is None:
            window_dc = wx.PaintDC(window)
        arr = self.convert_to_rgbarray()
        sz = arr.shape[:2]
        image = wx.Image(*sz)
        image.SetDataBuffer(arr.data)
        bmp = wx.Bitmap(image)

        window_dc.DrawBitmap(bmp,x,y)
        return



# Register PixelMap in _plat_support:
_plat_support.PixelMap_swigregister(PixelMap)

def pixel_map_as_unowned_array(pix_map):
    return _plat_support.pixel_map_as_unowned_array(pix_map)

