from time import time
import numpy as np
import pandas as pd
from joblib import Parallel, delayed    


def drop_dup_rows(data):
    """ Drop duplicate rows. """
    print('\nDrop duplicates ...')
    cnt0 = data.shape[0]
    data = data.drop_duplicates().reset_index(drop=True)
    cnt1 = data.shape[0]
    print('Dropped duplicates: {}'.format( cnt0-cnt1 ))
    return data

def dropna(df, axis: int=0, th: float=0.05, max_na: int=None):
    """
    Drop rows (axis=0) or cols (axis=1) based on the ratio of NA values
    along the axis. Instead of ratio, you can also specify the max number
    of NA.
    Args:
        th (float): if ratio of NA values along the axis is larger that th,
                     then drop all the values
        max_na (int): specify max allowable number of na (instead of
                       specifying the ratio)
        axis (int): 0 to drop rows; 1 to drop cols
    """
    assert (axis in [0, 1]), "Invalid value for arg 'axis'."
    axis = 0 if (axis == 1) else 1

    if max_na is not None:
        assert max_na >= 0, 'max_na must be >=0.'
        idx = df.isna().sum(axis=axis) <= max_na
    else:
        idx = df.isna().sum(axis=axis)/df.shape[axis] <= th

    if axis == 0:
        df = df.iloc[:, idx.values]
    else:
        df = df.iloc[idx.values, :].reset_index(drop=True)
    return df


def canon_single_smile(smi):
    """ Canonicalize single SMILES string. """
    from rdkit import Chem
    try:
        mol = Chem.MolFromSmiles( smi )
        can_smi = Chem.MolToSmiles(mol, canonical=True)
    except:
        # import ipdb; ipdb.set_trace()
        print(f'Error in smile: {smi}')
        can_smi = np.nan
    return can_smi

def fps_single_smile(smi, radius=2, nbits=2048):
    """ Convert single smiles into Morgan fingerprints.
    From www.rdkit.org/docs/GettingStartedInPython.html#morgan-fingerprints-circular-fingerprints:
    When comparing the ECFP/FCFP FPs and the Morgan FPs generated by the RDKit, remember that the
    4 in ECFP4 corresponds to the diameter of the atom environments considered, while the Morgan FPs
    take a radius parameter. So when radius=2, this is roughly equivalent to ECFP4 and FCFP4.

    https://www.researchgate.net/post/How_to_choose_bits_and_radius_during_circular_fingerprint_calculation_in_RDKit
    The Morgan fingerprint is basically a reimplementation of the extended conectivity
    fingerprint (ECFP). There is a paper describing it if you want more details but in
    essence you go through each atom of the molecule and obtain all possible paths through
    this atom with a specific radius. Then each unique path is hashed into a number with a
    maximum based on bit number. The higher the radius, the bigger fragments are encoded.
    So a Morgan radius 2 has all paths found in Morgan radius 1 and then some additional
    ones. In general, people use radius 2 (similar to ECFP4) and 3 (similar to ECFP6). As
    for number of bits it depends on your dataset. The higher bit number the more
    discriminative your fingerprint can be. If you have a large and diverse dataset but
    only have 32 bits, it will not be good. I would start at 1024 bits but also check
    higher numbers and see if you are losing too much information.
    """
    # stackoverflow.com/questions/54809506/
    from rdkit import Chem
    from rdkit.Chem import AllChem, DataStructs
    # smi=pybel.readstring("smi", row["smiles"]).write("can").strip()
    mol = Chem.MolFromSmiles( smi )
    fp = AllChem.GetMorganFingerprintAsBitVect(mol=mol, radius=radius, nBits=nbits)
    fp_arr = np.array(fp) # .tolist()
    # res = {'SMILES': smi, 'fps': fp_arr}
    # return res
    return fp_arr

def canonicalize_smiles(smi_df, id_col_name='DrugID', smiles_col_name='smiles', par_jobs=1):

    smi_df = smi_df.astype({id_col_name: str, smiles_col_name: str})
    smi_df[smiles_col_name] = smi_df[smiles_col_name].map(lambda x: x.strip())
    smi_df[id_col_name] = smi_df[id_col_name].map(lambda x: x.strip())
    #fea_id0 = smi.shape[1]  # index of the first feature
    # Drop duplicates
    smi_df = drop_dup_rows(smi_df)

    print('\nCanonicalize SMILES.')
    smi_vec = []
    t0 = time()
    smiles = smi_df[smiles_col_name]
    if par_jobs>1:
        smi_vec = Parallel(n_jobs=par_jobs, verbose=1)(
                delayed(canon_single_smile)(smi) for smi in smiles)
    else:
        for i, smi in enumerate(smiles):
            if i%100000==0:
                print('{}: {:.2f} mins'.format(i, (time()-t0)/60 ))
            can_smi = canon_single_smile(smi)
            smi_vec.append(can_smi)

    can_smi_df = smi_df
    can_smi_df[smiles_col_name] = pd.Series(smi_vec)


    bad_smiles = can_smi_df[can_smi_df[smiles_col_name].isna()]
    good_smiles = can_smi_df[can_smi_df[smiles_col_name].notna()]
    return good_smiles, bad_smiles


def generate_fingerprints(smi_df, id_col_name='DrugID', smiles_col_name='smiles', radius=1, nbits=2048, par_jobs=1):
    """ Generate dataframe of fingerprints from SMILES. """
    smi_df = smi_df.reset_index(drop=True)
    smiles = smi_df[smiles_col_name].values
    fps_result = Parallel(n_jobs=par_jobs, verbose=1)(
            delayed(fps_single_smile)(smi, radius=radius, nbits=nbits) for smi in smiles)
    # fps_list = [dct['fps'] for dct in res]
    # smi_list = [dct['SMILES'] for dct in res]
    # fps_arr = np.vstack( fps_list )
    # fps = pd.DataFrame( fps_arr )
    # fps.insert(loc=0, column='SMILES', value=smi_list)
    fps_arr = np.vstack(fps_result)
    fps = pd.DataFrame(fps_arr, dtype=np.int8)
    fps = pd.concat([smi_df, fps], axis=1)
    fps = fps.drop(columns=[smiles_col_name])

    return fps



def generate_mordred(smi_df, id_col_name='DrugID', smiles_col_name='smiles', ignore_3D=True, par_jobs=1):

    """ Generate dataframe of Mordred descriptors from SMILES. """
    from rdkit import Chem
    from mordred import Calculator, descriptors
    smi_df = smi_df.reset_index(drop=True)

    # Convert SMILES to mols
    smiles = smi_df[smiles_col_name].values
    mols = [Chem.MolFromSmiles(smi) for smi in smiles]

    # Create Mordred calculator and compute descriptors from molecules 
    # mordred-descriptor.github.io/documentation/master/_modules/mordred/_base/calculator.html#Calculator.pandas
    calc = Calculator(descriptors, ignore_3D=ignore_3D)
    dd = calc.pandas( mols, nproc=par_jobs, nmols=None, quiet=False, ipynb=False )
    mordreds = pd.concat([smi_df, dd], axis=1)
    mordreds = mordreds.drop(columns=[smiles_col_name])

    # Filter NaNs (step 1)
    # Drop rows where all values are NaNs
    idx = (mordreds.isna().sum(axis=1) == mordreds.shape[1] ).values
    mordreds = mordreds.iloc[~idx, :].reset_index(drop=True)

    # Filter NaNs (step 2)
    # Drop rows based on a thershold of NaN values.
    # print(dd.isna().sum(axis=1).sort_values(ascending=False))
    # p=dd.isna().sum(axis=1).sort_values(ascending=False).hist(bins=100);
    th = 0.25
    mordreds = dropna(mordreds, axis=0, th=th)

    # Cast features (descriptors)
    mordreds = mordreds.astype({c: np.float32 for c in mordreds.columns[1:]})

    mordreds = mordreds.reset_index(drop=True)


    # Impute missing values
    mordreds_imputed = mordreds
    mordreds_imputed.iloc[:, 1:] = mordreds_imputed.iloc[:, 1:].fillna(0.0)



    return mordreds_imputed, mordreds

def generate_infomax(smi_df, id_col_name='DrugID', smiles_col_name='smiles'):
    # Generate infomax fingerprints (see: https://github.com/NetPharMedGroup/publication_fingerprint)
        import torch
        from torch.utils.data import DataLoader
        import dgl
        from dgl.nn.pytorch.glob import AvgPooling
        from dgllife.model import load_pretrained
        from dgllife.utils import mol_to_bigraph, PretrainAtomFeaturizer, PretrainBondFeaturizer
        from rdkit import Chem

        smi_df = smi_df.reset_index(drop=True)
        # load pretrained model
        model = load_pretrained('gin_supervised_infomax') # contextpred infomax edgepred masking
        model.to('cpu')
        model.eval()
    
        b_res = smi_df[smiles_col_name].tolist()
        graphs = []
        for smile in b_res:
            #print(smi)
            try:
                mol = Chem.MolFromSmiles(smile)
                if mol is None:
                    continue
                g = mol_to_bigraph(mol, add_self_loop=True,
                                node_featurizer=PretrainAtomFeaturizer(),
                                edge_featurizer=PretrainBondFeaturizer(),
                                canonical_atom_order=True)
                graphs.append(g)

            except:
                continue

        def collate(gs):
            return dgl.batch(gs)

        data_loader = DataLoader(graphs, batch_size=256, collate_fn=collate, shuffle=False)

        readout = AvgPooling()


        mol_emb = []
        for batch_id, bg in enumerate(data_loader):
            bg = bg.to('cpu')
            nfeats = [bg.ndata.pop('atomic_number').to('cpu'),
                    bg.ndata.pop('chirality_type').to('cpu')]
            efeats = [bg.edata.pop('bond_type').to('cpu'),
                    bg.edata.pop('bond_direction_type').to('cpu')]
            with torch.no_grad():
                node_repr = model(bg, nfeats, efeats)
            mol_emb.append(readout(bg, node_repr))
        mol_emb = torch.cat(mol_emb, dim=0).detach().cpu().numpy()
        print(mol_emb)

        mol_emb = pd.DataFrame(mol_emb)

        infomax_df = pd.concat([smi_df, mol_emb], axis=1)
        infomax_df = infomax_df.drop(columns=[smiles_col_name])

        return infomax_df    



