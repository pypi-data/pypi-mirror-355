# H∆Ø·ªöNG D·∫™N S·ª¨ D·ª§NG DETECT-ROW PACKAGE

## T·ªïng quan

Package `detect-row` l√† m·ªôt th∆∞ vi·ªán Python ƒë∆∞·ª£c thi·∫øt k·∫ø ƒë·ªÉ **ph√°t hi·ªán v√† tr√≠ch xu·∫•t c√°c h√†ng t·ª´ b·∫£ng trong ·∫£nh**, v·ªõi kh·∫£ nƒÉng t√≠ch h·ª£p OCR. ƒê√£ ƒë∆∞·ª£c publish l√™n PyPI t·∫°i: https://pypi.org/project/detect-row/

## C√†i ƒë·∫∑t

```bash
pip install detect-row
```

## C√°c ch·ª©c nƒÉng ch√≠nh

### 1. **AdvancedTableExtractor** - Ph√°t hi·ªán v√† tr√≠ch xu·∫•t b·∫£ng

```python
from detect_row import AdvancedTableExtractor
import os

# Kh·ªüi t·∫°o
table_extractor = AdvancedTableExtractor(
    input_dir=os.path.dirname("image0524.png"),  # Th∆∞ m·ª•c ch·ª©a ·∫£nh
    output_dir="output/tables"                   # Th∆∞ m·ª•c l∆∞u b·∫£ng ƒë√£ tr√≠ch xu·∫•t
)

# X·ª≠ l√Ω ·∫£nh
result = table_extractor.process_image("image0524.png", margin=5, check_text=True)

# T√¨m c√°c b·∫£ng ƒë√£ tr√≠ch xu·∫•t
table_files = []
tables_dir = "output/tables"

if os.path.exists(tables_dir):
    table_files = [f for f in os.listdir(tables_dir) if f.endswith('.jpg')]
    table_files.sort()

print(f"‚úÖ Tr√≠ch xu·∫•t ƒë∆∞·ª£c {len(table_files)} b·∫£ng")
```

### 2. **AdvancedRowExtractorMain** - Tr√≠ch xu·∫•t rows t·ª´ b·∫£ng

```python
from detect_row import AdvancedRowExtractorMain
import cv2

# Kh·ªüi t·∫°o
row_extractor = AdvancedRowExtractorMain()

# ƒê·ªçc ·∫£nh b·∫£ng
table_image = cv2.imread("output/tables/table_0.jpg")
table_name = "table_0"

# Tr√≠ch xu·∫•t rows
rows_result = row_extractor.extract_rows_from_table(table_image, table_name)

# X·ª≠ l√Ω k·∫øt qu·∫£
rows = []
if isinstance(rows_result, list):
    rows = rows_result
elif isinstance(rows_result, dict) and 'rows' in rows_result:
    rows = rows_result['rows']

print(f"‚úÖ Tr√≠ch xu·∫•t ƒë∆∞·ª£c {len(rows)} rows")

# L∆∞u t·ª´ng row
for i, row_data in enumerate(rows):
    if isinstance(row_data, dict) and 'image' in row_data:
        row_image = row_data['image']
    elif isinstance(row_data, np.ndarray):
        row_image = row_data
    
    if row_image is not None:
        filename = f"{table_name}_row_{i:02d}.jpg"
        cv2.imwrite(f"output/rows/{filename}", row_image)
        print(f"üíæ ƒê√£ l∆∞u: {filename}")
```

### 3. **Ph√°t hi·ªán ƒë∆∞·ªùng g·∫°ch d·ªçc v√† OCR c·ªôt STT**

```python
import cv2
import numpy as np
import pytesseract
import re

def extract_first_column_stt(row_image, table_name, row_index):
    """Ph√°t hi·ªán ƒë∆∞·ªùng g·∫°ch d·ªçc v√† OCR c·ªôt ƒë·∫ßu ti√™n (STT)"""
    height, width = row_image.shape[:2]
    
    # Chuy·ªÉn sang grayscale n·∫øu c·∫ßn
    if len(row_image.shape) == 3:
        gray = cv2.cvtColor(row_image, cv2.COLOR_BGR2GRAY)
    else:
        gray = row_image.copy()
    
    # Ph√°t hi·ªán ƒë∆∞·ªùng th·∫≥ng d·ªçc b·∫±ng HoughLinesP
    edges = cv2.Canny(gray, 50, 150, apertureSize=3)
    
    # T√¨m ƒë∆∞·ªùng th·∫≥ng d·ªçc
    lines = cv2.HoughLinesP(edges, 1, np.pi/180, threshold=int(height*0.3), 
                          minLineLength=int(height*0.5), maxLineGap=10)
    
    vertical_lines = []
    if lines is not None:
        for line in lines:
            x1, y1, x2, y2 = line[0]
            # Ki·ªÉm tra ƒë∆∞·ªùng th·∫≥ng d·ªçc (g√≥c g·∫ßn 90 ƒë·ªô)
            if abs(x2 - x1) < 10:  # ƒê∆∞·ªùng g·∫ßn nh∆∞ th·∫≥ng ƒë·ª©ng
                vertical_lines.append((x1 + x2) // 2)  # L·∫•y t·ªça ƒë·ªô x trung b√¨nh
    
    # T√¨m ƒë∆∞·ªùng g·∫°ch d·ªçc ƒë·∫ßu ti√™n (g·∫ßn nh·∫•t v·ªõi b√™n tr√°i)
    if vertical_lines:
        vertical_lines.sort()
        # L·ªçc c√°c ƒë∆∞·ªùng qu√° g·∫ßn b√™n tr√°i (c√≥ th·ªÉ l√† vi·ªÅn b·∫£ng)
        valid_lines = [x for x in vertical_lines if x > width * 0.05]
        
        if valid_lines:
            first_column_width = valid_lines[0]
            print(f"üîç Ph√°t hi·ªán ƒë∆∞·ªùng g·∫°ch d·ªçc t·∫°i x={first_column_width}px")
        else:
            # Fallback: s·ª≠ d·ª•ng 20% n·∫øu kh√¥ng t√¨m th·∫•y ƒë∆∞·ªùng g·∫°ch d·ªçc h·ª£p l·ªá
            first_column_width = int(width * 0.2)
            print(f"‚ö†Ô∏è Kh√¥ng t√¨m th·∫•y ƒë∆∞·ªùng g·∫°ch d·ªçc, s·ª≠ d·ª•ng 20% chi·ªÅu r·ªông: {first_column_width}px")
    else:
        # Fallback: s·ª≠ d·ª•ng 20% n·∫øu kh√¥ng ph√°t hi·ªán ƒë∆∞·ª£c ƒë∆∞·ªùng g·∫°ch d·ªçc
        first_column_width = int(width * 0.2)
        print(f"‚ö†Ô∏è Kh√¥ng ph√°t hi·ªán ƒë∆∞·ªùng g·∫°ch d·ªçc, s·ª≠ d·ª•ng 20% chi·ªÅu r·ªông: {first_column_width}px")
    
    # C·∫Øt c·ªôt ƒë·∫ßu ti√™n
    first_column = row_image[:, :first_column_width]
    
    # L∆∞u c·ªôt ƒë·∫ßu ti√™n ƒë·ªÉ debug
    first_col_filename = f"{table_name}_row_{row_index:02d}_stt.jpg"
    cv2.imwrite(f"output/rows/{first_col_filename}", first_column)
    
    # OCR c·ªôt ƒë·∫ßu ti√™n b·∫±ng pytesseract
    # C·∫•u h√¨nh OCR cho s·ªë
    custom_config = r'--oem 3 --psm 8 -c tessedit_char_whitelist=0123456789'
    stt_text = pytesseract.image_to_string(first_column, config=custom_config).strip()
    
    # L·ªçc ch·ªâ l·∫•y s·ªë
    stt_numbers = re.findall(r'\d+', stt_text)
    stt = stt_numbers[0] if stt_numbers else ""
    
    if stt:
        print(f"üìù Row {row_index}: STT = {stt}")
    else:
        print(f"‚ö†Ô∏è Row {row_index}: Kh√¥ng ph√°t hi·ªán STT (raw: '{stt_text}')")
    
    return {
        "stt": stt,
        "raw_ocr_text": stt_text,
        "first_column_file": first_col_filename,
        "first_column_width": first_column_width
    }

# S·ª≠ d·ª•ng
for i, row_data in enumerate(rows):
    if isinstance(row_data, np.ndarray):
        row_image = row_data
        stt_result = extract_first_column_stt(row_image, "table_0", i)
        print(f"STT Row {i}: {stt_result['stt']}")
```

## Workflow ho√†n ch·ªânh

### B∆∞·ªõc 1: Ti·ªÅn x·ª≠ l√Ω ·∫£nh (t√πy ch·ªçn)

```python
import cv2
import numpy as np

def preprocess_image(image_path):
    """Ph√°t hi·ªán v√† s·ª≠a g√≥c nghi√™ng"""
    img = cv2.imread(image_path)
    gray = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)
    
    # Ph√°t hi·ªán c·∫°nh v√† ƒë∆∞·ªùng th·∫≥ng
    edges = cv2.Canny(gray, 50, 150, apertureSize=3)
    lines = cv2.HoughLinesP(edges, 1, np.pi/180, 100, minLineLength=100, maxLineGap=10)
    
    if lines is None:
        return image_path
    
    # T√≠nh g√≥c nghi√™ng
    angles = []
    for line in lines:
        x1, y1, x2, y2 = line[0]
        if x2 - x1 != 0:
            angle = np.arctan2(y2 - y1, x2 - x1) * 180.0 / np.pi
            if abs(angle) < 45:
                angles.append(angle)
    
    if not angles or abs(np.mean(angles)) < 1.0:
        return image_path
    
    # Xoay ·∫£nh n·∫øu c·∫ßn
    angle_mean = np.mean(angles)
    (h, w) = img.shape[:2]
    center = (w // 2, h // 2)
    M = cv2.getRotationMatrix2D(center, angle_mean, 1.0)
    
    cos = np.abs(M[0, 0])
    sin = np.abs(M[0, 1])
    new_w = int((h * sin) + (w * cos))
    new_h = int((h * cos) + (w * sin))
    
    M[0, 2] += (new_w / 2) - center[0]
    M[1, 2] += (new_h / 2) - center[1]
    
    rotated = cv2.warpAffine(img, M, (new_w, new_h), 
                            flags=cv2.INTER_LINEAR, 
                            borderMode=cv2.BORDER_CONSTANT, 
                            borderValue=(255, 255, 255))
    
    rotated_path = image_path.replace('.png', '_rotated.png')
    cv2.imwrite(rotated_path, rotated)
    return rotated_path
```

### B∆∞·ªõc 2: Ph√°t hi·ªán v√† tr√≠ch xu·∫•t b·∫£ng

```python
from detect_row import AdvancedTableExtractor

def extract_tables(image_path, output_dir="./output"):
    """Ph√°t hi·ªán v√† tr√≠ch xu·∫•t b·∫£ng t·ª´ ·∫£nh"""
    extractor = AdvancedTableExtractor(
        input_dir=os.path.dirname(image_path),
        output_dir=f"{output_dir}/tables",
        debug_dir=f"{output_dir}/debug"
    )
    
    result = extractor.process_image(image_path, margin=5, check_text=True)
    
    # X·ª≠ l√Ω k·∫øt qu·∫£
    if isinstance(result.get('tables'), list):
        num_tables = len(result['tables'])
    else:
        num_tables = result.get('tables', 0)
    
    print(f"‚úÖ Ph√°t hi·ªán {num_tables} b·∫£ng")
    return result
```

### B∆∞·ªõc 3: Tr√≠ch xu·∫•t h√†ng t·ª´ b·∫£ng

```python
import os
import cv2
import numpy as np

def extract_rows_from_tables(table_dir, row_output_dir):
    """Tr√≠ch xu·∫•t h√†ng t·ª´ c√°c b·∫£ng ƒë√£ ph√°t hi·ªán"""
    os.makedirs(row_output_dir, exist_ok=True)
    
    table_files = [f for f in os.listdir(table_dir) if f.endswith(('.jpg', '.png'))]
    total_rows = 0
    
    for table_file in table_files:
        table_path = os.path.join(table_dir, table_file)
        table_name = os.path.splitext(table_file)[0]
        
        # ƒê·ªçc ·∫£nh b·∫£ng
        img = cv2.imread(table_path)
        if img is None:
            continue
        
        # Chuy·ªÉn sang ·∫£nh x√°m
        gray = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)
        
        # Ph√°t hi·ªán ƒë∆∞·ªùng k·∫ª ngang
        kernel = cv2.getStructuringElement(cv2.MORPH_RECT, (img.shape[1]//10, 1))
        horizontal = cv2.morphologyEx(gray, cv2.MORPH_OPEN, kernel)
        
        # T√¨m v·ªã tr√≠ ƒë∆∞·ªùng k·∫ª
        h_sum = np.sum(horizontal, axis=1)
        threshold = np.max(h_sum) * 0.3
        
        line_positions = []
        for i, val in enumerate(h_sum):
            if val > threshold:
                line_positions.append(i)
        
        # L·ªçc ƒë∆∞·ªùng k·∫ª g·∫ßn nhau
        if len(line_positions) > 1:
            filtered = [line_positions[0]]
            for pos in line_positions[1:]:
                if pos - filtered[-1] > 20:  # Kho·∫£ng c√°ch t·ªëi thi·ªÉu
                    filtered.append(pos)
            line_positions = filtered
        
        # C·∫Øt h√†ng
        rows_count = 0
        if len(line_positions) >= 2:
            for i in range(len(line_positions) - 1):
                y1 = max(0, line_positions[i])
                y2 = min(img.shape[0], line_positions[i + 1])
                
                if y2 - y1 > 15:  # Chi·ªÅu cao t·ªëi thi·ªÉu
                    row_img = img[y1:y2, :]
                    row_path = os.path.join(row_output_dir, f"{table_name}_row_{i:02d}.jpg")
                    cv2.imwrite(row_path, row_img)
                    rows_count += 1
                    total_rows += 1
        
        print(f"  Tr√≠ch xu·∫•t {rows_count} h√†ng t·ª´ {table_file}")
    
    print(f"‚úÖ T·ªïng c·ªông tr√≠ch xu·∫•t {total_rows} h√†ng t·ª´ {len(table_files)} b·∫£ng")
    return total_rows
```

### B∆∞·ªõc 4: OCR (t√πy ch·ªçn)

```python
from detect_row import TesseractRowExtractor

def perform_ocr(image_path, output_dir="./output"):
    """Th·ª±c hi·ªán OCR tr√™n ·∫£nh"""
    extractor = TesseractRowExtractor(
        input_dir=os.path.dirname(image_path),
        output_dir=f"{output_dir}/ocr",
        debug_dir=f"{output_dir}/ocr_debug"
    )
    
    result = extractor.process_image(
        image_path,
        lang="vie+eng",           # Ti·∫øng Vi·ªát + Ti·∫øng Anh
        config="--oem 1 --psm 6", # C·∫•u h√¨nh Tesseract
        output_format="json"
    )
    
    # X·ª≠ l√Ω k·∫øt qu·∫£ OCR
    total_text_rows = 0
    if 'data' in result and result['data']:
        total_text_rows = sum(item.get('rows', 0) for item in result['data'])
    
    print(f"‚úÖ OCR ph√°t hi·ªán {total_text_rows} h√†ng c√≥ text")
    return result
```

## V√≠ d·ª• s·ª≠ d·ª•ng ho√†n ch·ªânh

```python
#!/usr/bin/env python3
# -*- coding: utf-8 -*-

import os
import cv2
import numpy as np
import json
from datetime import datetime
from detect_row import AdvancedTableExtractor, AdvancedRowExtractorMain
import pytesseract
import re

def ensure_dir(path: str):
    """T·∫°o th∆∞ m·ª•c n·∫øu ch∆∞a c√≥"""
    os.makedirs(path, exist_ok=True)
    print(f"üìÅ Created directory: {path}")

def extract_first_column_stt(row_image, table_name, row_index, output_dir):
    """Ph√°t hi·ªán ƒë∆∞·ªùng g·∫°ch d·ªçc v√† OCR c·ªôt ƒë·∫ßu ti√™n (STT)"""
    height, width = row_image.shape[:2]
    
    # Chuy·ªÉn sang grayscale n·∫øu c·∫ßn
    if len(row_image.shape) == 3:
        gray = cv2.cvtColor(row_image, cv2.COLOR_BGR2GRAY)
    else:
        gray = row_image.copy()
    
    # Ph√°t hi·ªán ƒë∆∞·ªùng th·∫≥ng d·ªçc b·∫±ng HoughLinesP
    edges = cv2.Canny(gray, 50, 150, apertureSize=3)
    lines = cv2.HoughLinesP(edges, 1, np.pi/180, threshold=int(height*0.3), 
                          minLineLength=int(height*0.5), maxLineGap=10)
    
    vertical_lines = []
    if lines is not None:
        for line in lines:
            x1, y1, x2, y2 = line[0]
            if abs(x2 - x1) < 10:  # ƒê∆∞·ªùng g·∫ßn nh∆∞ th·∫≥ng ƒë·ª©ng
                vertical_lines.append((x1 + x2) // 2)
    
    # T√¨m ƒë∆∞·ªùng g·∫°ch d·ªçc ƒë·∫ßu ti√™n
    if vertical_lines:
        vertical_lines.sort()
        valid_lines = [x for x in vertical_lines if x > width * 0.05]
        
        if valid_lines:
            first_column_width = valid_lines[0]
            print(f"üîç Ph√°t hi·ªán ƒë∆∞·ªùng g·∫°ch d·ªçc t·∫°i x={first_column_width}px")
        else:
            first_column_width = int(width * 0.2)
            print(f"‚ö†Ô∏è S·ª≠ d·ª•ng 20% chi·ªÅu r·ªông: {first_column_width}px")
    else:
        first_column_width = int(width * 0.2)
        print(f"‚ö†Ô∏è Kh√¥ng ph√°t hi·ªán ƒë∆∞·ªùng g·∫°ch d·ªçc, s·ª≠ d·ª•ng 20%: {first_column_width}px")
    
    # C·∫Øt c·ªôt ƒë·∫ßu ti√™n
    first_column = row_image[:, :first_column_width]
    
    # L∆∞u c·ªôt ƒë·∫ßu ti√™n
    first_col_filename = f"{table_name}_row_{row_index:02d}_stt.jpg"
    first_col_path = os.path.join(output_dir, "rows", first_col_filename)
    cv2.imwrite(first_col_path, first_column)
    
    # OCR c·ªôt ƒë·∫ßu ti√™n
    custom_config = r'--oem 3 --psm 8 -c tessedit_char_whitelist=0123456789'
    stt_text = pytesseract.image_to_string(first_column, config=custom_config).strip()
    
    # L·ªçc ch·ªâ l·∫•y s·ªë
    stt_numbers = re.findall(r'\d+', stt_text)
    stt = stt_numbers[0] if stt_numbers else ""
    
    return {
        "stt": stt,
        "raw_ocr_text": stt_text,
        "first_column_file": first_col_filename,
        "first_column_width": first_column_width
    }

def process_image_complete(image_path="image0524.png", output_base="output"):
    """X·ª≠ l√Ω ·∫£nh ho√†n ch·ªânh t·ª´ A ƒë·∫øn Z"""
    
    print(f"üöÄ TR√çCH XU·∫§T B·∫¢NG S·ª¨ D·ª§NG PACKAGE DETECT-ROW")
    print(f"üì∏ ·∫¢nh ƒë·∫ßu v√†o: {image_path}")
    print(f"üìÅ Th∆∞ m·ª•c ƒë·∫ßu ra: {output_base}")
    print(f"‚è∞ Th·ªùi gian: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}")
    
    if not os.path.exists(image_path):
        print(f"‚ùå Kh√¥ng t√¨m th·∫•y ·∫£nh: {image_path}")
        return
    
    # T·∫°o th∆∞ m·ª•c output
    ensure_dir(output_base)
    ensure_dir(f"{output_base}/tables")
    ensure_dir(f"{output_base}/rows")
    ensure_dir(f"{output_base}/ocr")
    
    # B∆∞·ªõc 1: Tr√≠ch xu·∫•t b·∫£ng
    print(f"\n{'='*60}")
    print("B∆Ø·ªöC 1: TR√çCH XU·∫§T B·∫¢NG")
    print(f"{'='*60}")
    
    table_extractor = AdvancedTableExtractor(
        input_dir=os.path.dirname(image_path),
        output_dir=f"{output_base}/tables"
    )
    
    result = table_extractor.process_image(image_path, margin=5, check_text=True)
    
    # T√¨m c√°c b·∫£ng ƒë√£ tr√≠ch xu·∫•t
    table_files = []
    tables_dir = f"{output_base}/tables"
    
    if os.path.exists(tables_dir):
        table_files = [f for f in os.listdir(tables_dir) if f.endswith('.jpg')]
        table_files.sort()
    
    if not table_files:
        print("‚ùå Kh√¥ng tr√≠ch xu·∫•t ƒë∆∞·ª£c b·∫£ng n√†o!")
        return
    
    print(f"‚úÖ Tr√≠ch xu·∫•t ƒë∆∞·ª£c {len(table_files)} b·∫£ng")
    
    # B∆∞·ªõc 2: Tr√≠ch xu·∫•t rows
    print(f"\n{'='*60}")
    print("B∆Ø·ªöC 2: TR√çCH XU·∫§T ROWS V√Ä OCR STT")
    print(f"{'='*60}")
    
    all_results = []
    row_extractor = AdvancedRowExtractorMain()
    
    for table_file in table_files:
        table_path = os.path.join(tables_dir, table_file)
        table_name = os.path.splitext(table_file)[0]
        
        print(f"\n--- X·ª≠ l√Ω {table_name} ---")
        
        # ƒê·ªçc ·∫£nh b·∫£ng
        table_image = cv2.imread(table_path)
        if table_image is None:
            continue
        
        # Tr√≠ch xu·∫•t rows
        rows_result = row_extractor.extract_rows_from_table(table_image, table_name)
        
        # X·ª≠ l√Ω k·∫øt qu·∫£
        rows = []
        if isinstance(rows_result, list):
            rows = rows_result
        elif isinstance(rows_result, dict) and 'rows' in rows_result:
            rows = rows_result['rows']
        
        if not rows:
            print("‚ö†Ô∏è Kh√¥ng tr√≠ch xu·∫•t ƒë∆∞·ª£c rows")
            continue
        
        print(f"‚úÖ Tr√≠ch xu·∫•t ƒë∆∞·ª£c {len(rows)} rows")
        
        # L∆∞u t·ª´ng row v√† OCR STT
        ocr_results = []
        for i, row_data in enumerate(rows):
            row_image = None
            
            if isinstance(row_data, dict) and 'image' in row_data:
                row_image = row_data['image']
            elif isinstance(row_data, np.ndarray):
                row_image = row_data
            
            if row_image is not None:
                # L∆∞u row
                filename = f"{table_name}_row_{i:02d}.jpg"
                filepath = os.path.join(output_base, "rows", filename)
                cv2.imwrite(filepath, row_image)
                print(f"üíæ ƒê√£ l∆∞u: {filename}")
                
                # OCR STT
                try:
                    stt_result = extract_first_column_stt(row_image, table_name, i, output_base)
                    row_ocr = {
                        "row_index": i,
                        "filename": filename,
                        **stt_result
                    }
                    ocr_results.append(row_ocr)
                    
                    if stt_result['stt']:
                        print(f"üìù Row {i}: STT = {stt_result['stt']}")
                    else:
                        print(f"‚ö†Ô∏è Row {i}: Kh√¥ng ph√°t hi·ªán STT")
                        
                except Exception as e:
                    print(f"‚ö†Ô∏è L·ªói OCR row {i}: {e}")
        
        # L∆∞u k·∫øt qu·∫£ OCR
        ocr_file = os.path.join(output_base, "ocr", f"{table_name}_ocr.json")
        with open(ocr_file, 'w', encoding='utf-8') as f:
            json.dump(ocr_results, f, indent=2, ensure_ascii=False)
        
        all_results.append({
            "table_name": table_name,
            "total_rows": len(rows),
            "ocr_results": ocr_results,
            "success": True
        })
    
    # T·ªïng k·∫øt
    total_tables = len(all_results)
    total_rows = sum(r['total_rows'] for r in all_results)
    
    print(f"\nüéâ HO√ÄN TH√ÄNH!")
    print(f"‚úÖ ƒê√£ x·ª≠ l√Ω: {total_tables} b·∫£ng")
    print(f"‚úÖ ƒê√£ tr√≠ch xu·∫•t: {total_rows} rows")
    print(f"üìÅ K·∫øt qu·∫£ l∆∞u t·∫°i: {output_base}/")
    
    return all_results

# S·ª≠ d·ª•ng
if __name__ == "__main__":
    results = process_image_complete("image0524.png", "my_output")
```

## C√°c tham s·ªë quan tr·ªçng

### AdvancedTableExtractor

- `margin`: Kho·∫£ng c√°ch vi·ªÅn xung quanh b·∫£ng (m·∫∑c ƒë·ªãnh: 5)
- `check_text`: Ki·ªÉm tra text trong b·∫£ng (m·∫∑c ƒë·ªãnh: True)

### TesseractRowExtractor

- `lang`: Ng√¥n ng·ªØ OCR ("vie", "eng", "vie+eng")
- `config`: C·∫•u h√¨nh Tesseract
  - `--oem 1`: OCR Engine Mode
  - `--psm 6`: Page Segmentation Mode 
- `min_row_height`: Chi·ªÅu cao t·ªëi thi·ªÉu c·ªßa h√†ng (pixel)

## L∆∞u √Ω

1. **Y√™u c·∫ßu h·ªá th·ªëng:**
   - Python >= 3.6
   - OpenCV
   - Tesseract OCR (cho ch·ª©c nƒÉng OCR)

2. **C√†i ƒë·∫∑t Tesseract:**
   ```bash
   # Ubuntu/Debian
   sudo apt-get install tesseract-ocr tesseract-ocr-vie
   
   # Windows: Download t·ª´ https://github.com/UB-Mannheim/tesseract/wiki
   ```

3. **Ch·∫•t l∆∞·ª£ng ·∫£nh:**
   - ·∫¢nh n√™n c√≥ ƒë·ªô ph√¢n gi·∫£i cao (>= 300 DPI)
   - Tr√°nh ·∫£nh b·ªã m·ªù ho·∫∑c nghi√™ng qu√° nhi·ªÅu
   - ƒê∆∞·ªùng k·∫ª b·∫£ng r√µ r√†ng s·∫Ω cho k·∫øt qu·∫£ t·ªët h∆°n

4. **Ph√°t hi·ªán ƒë∆∞·ªùng g·∫°ch d·ªçc:**
   - Thu·∫≠t to√°n HoughLinesP ƒë∆∞·ª£c s·ª≠ d·ª•ng ƒë·ªÉ ph√°t hi·ªán ƒë∆∞·ªùng g·∫°ch d·ªçc
   - N·∫øu kh√¥ng ph√°t hi·ªán ƒë∆∞·ª£c, s·∫Ω fallback v·ªÅ 20% chi·ªÅu r·ªông
   - ƒê∆∞·ªùng g·∫°ch d·ªçc gi√∫p c·∫Øt c·ªôt STT ch√≠nh x√°c h∆°n

5. **OCR c·ªôt STT:**
   - S·ª≠ d·ª•ng pytesseract v·ªõi c·∫•u h√¨nh ch·ªâ nh·∫≠n di·ªán s·ªë (0-9)
   - K·∫øt qu·∫£ ƒë∆∞·ª£c l·ªçc b·∫±ng regex ƒë·ªÉ ch·ªâ l·∫•y s·ªë
   - L∆∞u c·∫£ ·∫£nh c·ªôt STT v√† k·∫øt qu·∫£ OCR ƒë·ªÉ debug

## C·∫•u tr√∫c output

```
output/
‚îú‚îÄ‚îÄ tables/                    # C√°c b·∫£ng ƒë√£ tr√≠ch xu·∫•t
‚îÇ   ‚îú‚îÄ‚îÄ table_0.jpg
‚îÇ   ‚îî‚îÄ‚îÄ table_1.jpg
‚îú‚îÄ‚îÄ rows/                      # C√°c h√†ng ƒë√£ c·∫Øt t·ª´ b·∫£ng
‚îÇ   ‚îú‚îÄ‚îÄ table_0_row_00.jpg     # Row ƒë·∫ßy ƒë·ªß
‚îÇ   ‚îú‚îÄ‚îÄ table_0_row_00_stt.jpg # C·ªôt STT ƒë√£ c·∫Øt
‚îÇ   ‚îú‚îÄ‚îÄ table_0_row_01.jpg
‚îÇ   ‚îú‚îÄ‚îÄ table_0_row_01_stt.jpg
‚îÇ   ‚îú‚îÄ‚îÄ table_1_row_00.jpg
‚îÇ   ‚îú‚îÄ‚îÄ table_1_row_00_stt.jpg
‚îÇ   ‚îî‚îÄ‚îÄ ...
‚îú‚îÄ‚îÄ ocr/                       # K·∫øt qu·∫£ OCR STT
‚îÇ   ‚îú‚îÄ‚îÄ table_0_ocr.json       # K·∫øt qu·∫£ OCR b·∫£ng 0
‚îÇ   ‚îî‚îÄ‚îÄ table_1_ocr.json       # K·∫øt qu·∫£ OCR b·∫£ng 1
‚îî‚îÄ‚îÄ analysis/                  # Ph√¢n t√≠ch v√† b√°o c√°o
    ‚îú‚îÄ‚îÄ summary_visualization.png
    ‚îú‚îÄ‚îÄ pip_package_summary.json
    ‚îî‚îÄ‚îÄ pip_package_report.txt
```

### V√≠ d·ª• n·ªôi dung file OCR JSON:

```json
[
  {
    "row_index": 0,
    "filename": "table_0_row_00.jpg",
    "first_column_file": "table_0_row_00_stt.jpg",
    "stt": "1",
    "raw_ocr_text": "1",
    "first_column_width": 108
  },
  {
    "row_index": 1,
    "filename": "table_0_row_01.jpg",
    "first_column_file": "table_0_row_01_stt.jpg",
    "stt": "2",
    "raw_ocr_text": "2",
    "first_column_width": 108
  }
]
```

## X·ª≠ l√Ω l·ªói th∆∞·ªùng g·∫∑p

### 1. Import Error
```python
# ƒê·∫£m b·∫£o ƒë√£ c√†i ƒë·∫∑t
pip install detect-row

# Ki·ªÉm tra version
import detect_row
print(detect_row.__version__)
```

### 2. Tesseract not found
```bash
# C√†i ƒë·∫∑t Tesseract v√† th√™m v√†o PATH
# Ho·∫∑c set ƒë∆∞·ªùng d·∫´n trong code:
import pytesseract
pytesseract.pytesseract.tesseract_cmd = r'C:\Program Files\Tesseract-OCR\tesseract.exe'
```

### 3. Unicode encoding (Windows)
```python
# S·ª≠ d·ª•ng UTF-8 encoding
import os
os.environ['PYTHONIOENCODING'] = 'utf-8'
```

## T√≠ch h·ª£p v√†o d·ª± √°n

Package n√†y ƒë∆∞·ª£c thi·∫øt k·∫ø ƒë·ªÉ d·ªÖ d√†ng t√≠ch h·ª£p v√†o c√°c d·ª± √°n x·ª≠ l√Ω t√†i li·ªáu, ƒë·∫∑c bi·ªát ph√π h·ª£p v·ªõi:
- X·ª≠ l√Ω phi·∫øu b·∫ßu c·ª≠
- Digitization t√†i li·ªáu
- Tr√≠ch xu·∫•t d·ªØ li·ªáu t·ª´ b·∫£ng bi·ªÉu
- OCR t√†i li·ªáu ti·∫øng Vi·ªát

## Support

- GitHub: (N·∫øu c√≥)
- PyPI: https://pypi.org/project/detect-row/
- Issues: B√°o c√°o l·ªói qua GitHub Issues

---

*H∆∞·ªõng d·∫´n n√†y ƒë∆∞·ª£c t·∫°o d·ª±a tr√™n package detect-row version 1.0.1* 