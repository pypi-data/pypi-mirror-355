# -*- coding: utf-8 -*-
"""
Tool Description Configuration File - Unified Format
Supports both FastMCP and description loader, includes detailed parameter explanations
"""

TOOL_DESCRIPTIONS = {
    # Geometry Calculator Tool
    "geometry_calculator": {
        "name": "geometry_calculator",
        "description": "Powerful geometry calculation tool, supporting plane geometry, solid geometry, and analytical geometry calculations.",
        "args": {
            "shape_type": "(string) Type of geometric shape. Required. Supports: 'circle', 'triangle', 'rectangle', 'polygon', 'ellipse', 'parallelogram', 'trapezoid', 'rhombus', 'regular_polygon', 'sphere', 'cube', 'cylinder', 'cone', 'pyramid', 'prism', 'torus', 'ellipsoid', 'analytical'.",
            "operation": "(string) Geometric operation to perform. Required. Supports: 'area', 'volume', 'surface_area', 'circumference', 'perimeter', 'properties', 'diagonal', 'distance', 'midpoint', 'slope', 'line_equation', 'angle', 'centroid', 'incircle', 'circumcircle'.",
            "dimensions": "(dict, Optional) Dictionary of dimension parameters for the geometric body. E.g., {'radius': 5}, {'length': 10, 'width': 5}. Keys must be strings, values must be positive numbers.",
            "points": "(list[list[float]], Optional) List of coordinate points, used for coordinate-based calculations. Format: [[x1,y1], [x2,y2], ...] or [[x1,y1,z1], [x2,y2,z2], ...].",
            "precision": "(int, Optional) Number of decimal places for the calculation result, range 0-15.",
            "unit": "(string, Optional) Measurement unit identifier, e.g., 'cm', 'm'. Defaults to 'default'.",
        },
        "returns": "Dictionary containing calculation results, returns corresponding geometric property values based on the operation type.",
        "examples": [
            "geometry_calculator(shape_type='circle', operation='properties', dimensions={'radius': 5})",
            "geometry_calculator(shape_type='triangle', operation='area', points=[[0,0], [3,0], [0,4]])",
        ],
    },
    # Number Theory Calculator Tool
    "number_theory_calculator": {
        "name": "number_theory_calculator",
        "description": "Advanced number theory calculation tool, supporting prime testing, factorization, modular arithmetic, etc.",
        "args": {
            "operation": "(string) Type of number theory operation. Required. Supports: 'prime_factorization', 'prime_test', 'generate_primes', 'modular_arithmetic', 'modular_exponentiation', 'extended_gcd', 'chinese_remainder', 'euler_totient', 'divisors', 'perfect_number', 'fibonacci', 'collatz', 'carmichael_function', 'jacobi_symbol', 'quadratic_residue', 'primitive_root', 'continued_fraction'.",
            "number": "(int, Optional) Primary operand. Most single-number operations require this parameter, must be a positive integer.",
            "numbers": "(list[int], Optional) List of numbers. Used for operations requiring multiple numbers, such as 'chinese_remainder' or 'jacobi_symbol'.",
            "modulus": "(int, Optional) Modulus. Used for modular arithmetic, must be a positive integer.",
            "base": "(int, Optional) Base. Used for 'modular_exponentiation'.",
            "exponent": "(int, Optional) Exponent. Used for 'modular_exponentiation', must be a non-negative integer.",
            "limit": "(int, Optional) Limit value. Used for 'generate_primes' or 'fibonacci', must be a positive integer.",
            "precision": "(int, Optional) Number of terms for continued fraction expansion. Range 1-50, default 10.",
        },
        "returns": "Dictionary containing number theory calculation results.",
        "examples": [
            "number_theory_calculator(operation='prime_factorization', number=60)",
            "number_theory_calculator(operation='prime_test', number=97)",
        ],
    },
    # Signal Processing Tool
    "signal_processing_calculator": {
        "name": "signal_processing_calculator",
        "description": "Professional digital signal processing tool, supporting FFT, filtering, modulation/demodulation, etc. Key features: ① All large data is automatically saved to the TMPFILE_PATH folder, returning only summary information and the data_file path; ② Supports chained analysis: FFT result files can be directly used for subsequent spectral_analysis; ③ Recommended to use the signal_file parameter to avoid large data transfers.",
        "args": {
            "operation": "(string) Type of signal processing operation. Required. Supports: 'fft'(Fast Fourier Transform), 'generate_signal'(signal generation), 'filter'(filtering), 'windowing'(windowing), 'autocorrelation'(autocorrelation), 'crosscorrelation'(cross-correlation), 'spectral_analysis'(spectral analysis), 'signal_metrics'(signal metrics), 'convolution'(convolution), 'deconvolution'(deconvolution), 'envelope_detection'(envelope detection), 'phase_analysis'(phase analysis), 'noise_reduction'(noise reduction), 'resampling'(resampling), 'modulation'(modulation), 'demodulation'(demodulation).",
            "signal": "(list[float], Optional) Input signal data. Choose one with signal_file. Recommended only for small datasets (<1000 points), use signal_file for large data.",
            "signal_file": "(string, Optional) Signal file path (.json format). Choose one with signal. Supports raw signal files, FFT result files, spectral_analysis files, etc. Highly recommended for large data processing and chained analysis. Path example: 'C:\\Users\\X\\Desktop\\test\\signal_xxx.json'.",
            "sampling_rate": "(float, Optional) Sampling rate (Hz). Must be a positive number. Example: 1000.0. If signal_file contains sampling rate information, this parameter can be omitted.",
            "frequency": "(float, Optional) Signal frequency (Hz). Used for signal generation, modulation/demodulation. Must be a positive number.",
            "filter_type": "(string, Optional) Filter type. Supports: 'lowpass', 'highpass', 'bandpass', 'moving_average', 'median', 'gaussian', 'savitzky_golay', 'wiener'.",
            "cutoff_freq": "(float, Optional) Cutoff frequency (Hz). Used for filtering, must be less than Nyquist frequency (sampling_rate/2).",
            "window_size": "(int, Optional) Window size. Used for windowing, spectral analysis, noise reduction. Range: 3-10000.",
            "overlap": "(float, Optional) Window overlap ratio. Used for spectral analysis (e.g., STFT), range 0-1. Defaults to 0.5.",
            "order": "(int, Optional) Filter order or polynomial order. Range: 1-20.",
            "duration": "(float, Optional) Signal duration (seconds). Used for signal generation, must be a positive number.",
            "signal_type": "(string, Optional) Signal type. Used for generate_signal operation. Supports: 'sine'(sine), 'cosine'(cosine), 'square'(square wave), 'sawtooth'(sawtooth wave), 'triangle'(triangle wave), 'chirp'(linear chirp), 'white_noise'(white noise), 'pink_noise'(pink noise), 'brown_noise'(brown noise), 'gaussian_noise'(Gaussian noise), 'uniform_noise'(uniform noise), 'impulse'(impulse), 'step'(step), 'exponential'(exponential decay), 'dc'(DC).",
            "noise_level": "(float, Optional) Noise amplitude or signal amplitude. Used for noise signals and some special signals, default 1.0.",
            "output_filename": "(string, Optional) Output filename (without path). If provided, TMPFILE_PATH will be automatically prepended to save signal data; if a file with the same name exists, a timestamp will be added to avoid overwriting.",
        },
        "returns": "Dictionary containing a summary of processing results. Key fields: ①data_file: Full path to the data file (located in TMPFILE_PATH), usable for subsequent analysis; ②operation: Type of operation; ③message: Processing status description; ④Specific summary information (e.g., dominant_frequency, spectral_features, autocorr_properties, envelope_stats). Note: All large data (frequencies, signal, magnitude, etc.) are saved to a file and not returned directly.",
        "examples": [
            "# Workflow Example 1: Various signal generations",
            "signal_processing_calculator(operation='generate_signal', signal_type='sine', frequency=50, sampling_rate=1000, duration=1.0)",
            "signal_processing_calculator(operation='generate_signal', signal_type='white_noise', sampling_rate=1000, duration=2.0, noise_level=0.5)",
            "signal_processing_calculator(operation='generate_signal', signal_type='square', frequency=10, sampling_rate=500, duration=1.0)",
            "signal_processing_calculator(operation='generate_signal', signal_type='chirp', frequency=20, sampling_rate=1000, duration=2.0)",
            "# Workflow Example 2: Signal generation -> FFT -> Spectral analysis",
            "result1 = signal_processing_calculator(operation='generate_signal', signal_type='pink_noise', sampling_rate=1000, duration=1.0, noise_level=1.0)",
            "result2 = signal_processing_calculator(operation='fft', signal_file=result1['data_file'])",
            "result3 = signal_processing_calculator(operation='spectral_analysis', signal_file=result2['data_file'])",
            "# Workflow Example 3: Correlation analysis",
            "signal_processing_calculator(operation='autocorrelation', signal_file='path/to/signal.json')  # Returns summary and data_file",
            "signal_processing_calculator(operation='crosscorrelation', signal=[sig1+sig2])  # Automatically splits into two signals",
            "# Workflow Example 4: Filtering and noise reduction",
            "signal_processing_calculator(operation='filter', signal_file='noisy_signal.json', filter_type='lowpass', cutoff_freq=100, sampling_rate=1000)",
            "signal_processing_calculator(operation='noise_reduction', signal_file='signal.json', filter_type='median', window_size=7)",
            "# Workflow Example 5: Modulation and demodulation",
            "result_mod = signal_processing_calculator(operation='modulation', signal=[...], frequency=100, sampling_rate=1000)",
            "signal_processing_calculator(operation='demodulation', signal_file=result_mod['data_file'], frequency=100, sampling_rate=1000)",
            "# Special signal generation",
            "signal_processing_calculator(operation='generate_signal', signal_type='impulse', sampling_rate=1000, duration=0.1)",
            "signal_processing_calculator(operation='generate_signal', signal_type='exponential', frequency=2.0, sampling_rate=100, duration=5.0)",
        ],
    },
    # Financial Mathematics Tool
    "financial_calculator": {
        "name": "financial_calculator",
        "description": "Professional financial mathematics calculation tool, supporting compound interest, investment analysis, risk assessment, etc.",
        "args": {
            "operation": "(string) Financial calculation operation type. Required. Supports: 'compound_interest', 'simple_interest', 'present_value', 'future_value', 'annuity', 'npv', 'irr', 'loan_payment', 'bond_pricing', 'portfolio_metrics', 'volatility', 'sharpe_ratio'.",
            "principal": "(float, Optional) Principal or initial investment amount. Must be a positive number.",
            "rate": "(float, Optional) Interest rate per period (decimal). Periodic rate, e.g., monthly rate. Choose one with annual_rate.",
            "time": "(int, Optional) Time period (years or number of periods). Must be a non-negative integer.",
            "cash_flows": "(list[float], Optional) Sequence of cash flows. Used for 'npv'/'irr' calculation. The first element is typically the negative initial investment.",
            "initial_investment": "(float, Optional) Initial investment amount, used for NPV/IRR etc.",
            "payment": "(float, Optional) Periodic payment amount. Used for 'annuity', 'loan_payment'.",
            "periods": "(int, Optional) Number of payment periods. Must be a positive integer.",
            "future_value": "(float, Optional) Future value.",
            "present_value": "(float, Optional) Present value.",
            "annual_rate": "(float, Optional) Annualized interest rate (decimal). If provided, it will be divided by payments_per_year to get the periodic rate for loan calculations.",
            "payments_per_year": "(int, Optional) Number of payments per year. Defaults to 12 (monthly).",
            "returns": "(list[float], Optional) Sequence of returns (decimal form). Used for portfolio analysis.",
            "prices": "(list[float], Optional) Sequence of prices. Used for volatility calculation.",
            "risk_free_rate": "(float, Optional) Risk-free interest rate (decimal form). Used for Sharpe ratio calculation.",
        },
        "returns": "Dictionary containing financial calculation results.",
        "examples": [
            "financial_calculator(operation='compound_interest', principal=1000, rate=0.05, time=10)",
            "financial_calculator(operation='npv', cash_flows=[-1000,300,400,500,600], rate=0.1)",
            "financial_calculator(operation='loan_payment', principal=100000, annual_rate=0.05, periods=360)",
        ],
    },
    # Probability and Statistics Tool
    "probability_calculator": {
        "name": "probability_calculator",
        "description": "Professional probability and statistics calculation tool, supporting probability distributions, hypothesis testing, Bayesian analysis, etc.",
        "args": {
            "operation": "(string) Probability/statistics operation type. Required. Supports: 'probability_mass', 'cumulative_distribution', 'inverse_cdf', 'random_sampling', 'distribution_stats', 'bayes_theorem', 'combinatorics', 'hypothesis_test', 'confidence_interval', 'monte_carlo'.",
            "distribution": "(string, Optional) Type of probability distribution. Supports: 'normal', 'binomial', 'poisson', 'exponential', 'uniform', 'chi_square', 't_distribution'.",
            "parameters": "(dict, Optional) Dictionary of distribution parameters. Normal distribution supports: {'mu': 0, 'sigma': 1} or {'mean': 0, 'std': 1}, Binomial distribution: {'n': 10, 'p': 0.5}. Keys must be strings, values are numerical.",
            "x_value": "(float, Optional) Single independent variable value for calculating probability or quantile.",
            "x_values": "(list[float], Optional) List of multiple independent variable values for calculating probability or quantiles.",
            "probability": "(float, Optional) Probability value. Range 0-1, used for 'inverse_cdf'.",
            "n_samples": "(int, Optional) Number of random samples. Must be a positive integer, max 100000.",
            "events": "(list[dict], Optional) List of events. Used for 'bayes_theorem', format: [{'name': 'A', 'prob': 0.1}, ...].",
            "data": "(list[float], Optional) Sample data. Used for 'hypothesis_test', 'confidence_interval'.",
        },
        "returns": "Dictionary containing probability and statistics calculation results.",
        "examples": [
            "probability_calculator(operation='probability_mass', distribution='normal', parameters={'mu':0,'sigma':1}, x_value=1.96)",
            "probability_calculator(operation='cumulative_distribution', distribution='normal', parameters={'mu':20,'sigma':3}, x_value=25)",
            "probability_calculator(operation='random_sampling', distribution='binomial', parameters={'n':10,'p':0.3}, n_samples=100)",
        ],
    },
    # Complex Analysis Suite
    "complex_analysis_suite": {
        "name": "complex_analysis_suite",
        "description": "Powerful complex analysis and complex function tool, supporting complex number form conversion, residue calculation, analytic continuation, complex plane visualization, and other advanced features.",
        "args": {
            "operation": "(string) Complex analysis operation type. Required. Supports: 'convert_form'(complex form conversion), 'arithmetic'(complex arithmetic), 'function_evaluation'(complex function evaluation), 'residue_calculation'(residue calculation), 'contour_integration'(contour integration), 'series_expansion'(series expansion), 'analytic_continuation'(analytic continuation), 'complex_plot'(complex function plotting), 'conformal_mapping'(conformal mapping), 'singularity_analysis'(singularity analysis, more powerful than complex_plot's singularity analysis).",
            "complex_number": "(string|complex, Optional) Single complex number. Supports string form like '3+4i' or complex object. Used for form conversion, function evaluation, etc.",
            "complex_numbers": "(list[string|complex], Optional) List of complex numbers. Used for complex arithmetic, requires at least 2 complex numbers.",
            "function_expression": "(string, Optional) Complex function expression. E.g., 'z**2 + 1', 'exp(z)', 'sin(z)/z'. Supports sympy syntax.",
            "variable": "(string, Optional) Complex variable name. Defaults to 'z'.",
            "contour_points": "(list[list[float]], Optional) Contour integration path points. Format: [[x1,y1], [x2,y2], ...], defines the integration path on the complex plane.",
            "singularities": "(list[string|complex], Optional) List of singularities. Used for residue calculation, e.g., ['0', '1+2i', '-1'].",
            "center": "(string|complex, Optional) Center for series expansion or analytic continuation. Defaults to 0.",
            "radius": "(float, Optional) Radius of convergence or continuation radius. Used for analytic continuation analysis.",
            "order": "(int, Optional) Order of pole or number of series terms. Used for residue calculation or series expansion.",
            "x_range": "(tuple[float, float], Optional) Real axis range for complex plane. Default (-5, 5). Used for plotting and analysis.",
            "y_range": "(tuple[float, float], Optional) Imaginary axis range for complex plane. Default (-5, 5). Used for plotting and analysis.",
            "resolution": "(int, Optional) Plotting resolution. Default 500. Affects image quality and computation time.",
            "colormap": "(string, Optional) Colormap. Default 'hsv'. Supports matplotlib colormaps.",
            "filename": "(string, Optional) Save filename. Without path, automatically saved to temporary directory.",
            "plot_type": "(string, Optional) Plot type. Supports 'domain_coloring'(domain coloring), 'all'(all plots). Default 'domain_coloring'.",
            "series_terms": "(int, Optional) Number of series expansion terms. Default 10.",
            "branch_cut": "(string, Optional) Branch cut description. Used for analytic continuation of multi-valued functions.",
            "method": "(string, Optional) Calculation method. Default 'auto'. Supports 'all'(all operations), 'add', 'multiply', etc.",
        },
        "returns": "Dictionary containing complex analysis results. Returns corresponding results based on operation type: form conversion returns various complex representations, residue calculation returns residue values and contour integrals, plotting returns file path and analysis information, etc.",
        "examples": [
            "complex_analysis_suite(operation='convert_form', complex_number='3+4i')",
            "complex_analysis_suite(operation='arithmetic', complex_numbers=['1+2i', '3-4i'], method='all')",
            "complex_analysis_suite(operation='function_evaluation', function_expression='z**2 + 1', complex_number='1+i')",
            "complex_analysis_suite(operation='residue_calculation', function_expression='1/(z**2 + 1)', singularities=['i', '-i'])",
            "complex_analysis_suite(operation='complex_plot', function_expression='z**2', x_range=(-2, 2), y_range=(-2, 2))",
            "complex_analysis_suite(operation='series_expansion', function_expression='exp(z)', center='0', series_terms=8)",
            "complex_analysis_suite(operation='conformal_mapping', function_expression='z**2', x_range=(-1, 1), y_range=(-1, 1))",
        ],
    },
    # Graph Theory Suite
    "graph_theory_suite": {
        "name": "graph_theory_suite",
        "description": "Professional graph theory analysis tool, supporting shortest path, maximum flow, connectivity analysis, centrality calculation, community detection, spectral analysis, and other comprehensive graph theory functions.",
        "args": {
            "operation": "(string) Graph theory operation type. Required. Supports: 'shortest_path', 'all_pairs_shortest_path', 'maximum_flow', 'connectivity_analysis', 'centrality_analysis', 'community_detection', 'spectral_analysis', 'graph_properties', 'minimum_spanning_tree', 'graph_coloring', 'clique_analysis', 'graph_visualization', 'graph_comparison', 'graph_generation'.",
            "graph_data": "(dict, Optional) Graph data dictionary. Format: {'nodes': [list of nodes], 'edges': [list of edges]}. Edges can be simple lists or lists of dictionaries with attributes.",
            "adjacency_matrix": "(list[list[int|float]], Optional) Adjacency matrix. Square matrix, elements represent connection weights between nodes, 0 means no connection.",
            "edge_list": "(list[list[int|string]], Optional) Edge list. Format: [[source_node, target_node], ...] or [[source_node, target_node, weight], ...].",
            "node_list": "(list[int|string], Optional) Node list. Used to specify node identifiers (e.g., '[1,2,3]').",
            "source_node": "(int|string, Optional) Source node. Used for algorithms like shortest path, maximum flow.",
            "target_node": "(int|string, Optional) Target node. Used for algorithms like shortest path, maximum flow.",
            "weight_attribute": "(string, Optional) Weight attribute name. Default 'weight'. Used for weighted graph algorithms.",
            "directed": "(bool, Optional) Whether it is a directed graph. Default False.",
            "algorithm": "(string, Optional) Algorithm selection. Default 'auto'. Supports: 'dijkstra', 'bellman_ford', 'floyd_warshall', 'bfs', 'kruskal', 'prim', 'louvain', 'girvan_newman', etc.",
            "k_value": "(int, Optional) K-value parameter. Used for k-clique analysis, spectral clustering, etc.",
            "threshold": "(float, Optional) Threshold parameter. Used for community detection, graph generation, etc.",
            "layout": "(string, Optional) Graph layout algorithm. Default 'spring'. Supports: 'spring', 'circular', 'random', 'shell', 'spectral', 'kamada_kawai'.",
            "filename": "(string, Optional) Save filename. Used for graph visualization output.",
            "node_colors": "(list[string], Optional) List of node colors. Used for visualization.",
            "edge_colors": "(list[string], Optional) List of edge colors. Used for visualization.",
            "node_sizes": "(list[int], Optional) List of node sizes. Used for visualization.",
            "show_labels": "(bool, Optional) Whether to display node labels. Default True.",
            "figsize": "(tuple[float, float], Optional) Figure size. Default (10, 8).",
        },
        "returns": "Dictionary containing graph theory analysis results. Returns corresponding results based on operation type: path analysis returns path and length, centrality analysis returns various centrality metrics, visualization returns image file path, etc.",
        "examples": [
            "graph_theory_suite(operation='shortest_path', edge_list=[[0,1,2], [1,2,3], [0,2,1]], source_node=0, target_node=2, algorithm='dijkstra')",
            "graph_theory_suite(operation='centrality_analysis', graph_data={'nodes': [0,1,2,3], 'edges': [[0,1], [1,2], [2,3], [3,0]]}, algorithm='all')",
            "graph_theory_suite(operation='community_detection', adjacency_matrix=[[0,1,1,0], [1,0,1,1], [1,1,0,1], [0,1,1,0]], algorithm='louvain')",
            "graph_theory_suite(operation='spectral_analysis', edge_list=[[0,1], [1,2], [2,0]], k_value=2)",
            "graph_theory_suite(operation='graph_visualization', graph_data={'nodes': ['A','B','C'], 'edges': [['A','B'], ['B','C']]}, layout='spring')",
            "graph_theory_suite(operation='maximum_flow', edge_list=[[0,1,10], [1,2,10], [0,2,1]], source_node=0, target_node=2, directed=True)",
            "graph_theory_suite(operation='graph_generation', algorithm='complete', k_value=5)",
        ],
    },
    # Basic Arithmetic Tool
    "basic_arithmetic": {
        "name": "basic_arithmetic",
        "description": "Basic arithmetic operations tool, supporting most addition, subtraction, multiplication, division, and high-precision calculations.",
        "args": {
            "operation": "(string) Arithmetic operation type. Required. Supports: 'add', 'subtract', 'multiply', 'product', 'divide', 'power', 'modulo', 'modulus', 'factorial', 'gcd', 'lcm', 'sum', 'average'.",
            "numbers": "(list[float]) List of numbers for the operation. Required, must contain at least one number.",
            "precision": "(int, Optional) Number of decimal places for the result. Range 0-15.",
            "use_decimal": "(bool, Optional) Whether to use high-precision decimal calculation. Defaults to False.",
        },
        "returns": "Dictionary containing the operation result.",
        "examples": [
            "basic_arithmetic(operation='add', numbers=[1, 2, 3, 4, 5])",
            "basic_arithmetic(operation='multiply', numbers=[2.5, 3.7], precision=3)",
        ],
    },
    # Mathematical Functions Tool
    "mathematical_functions": {
        "name": "mathematical_functions",
        "description": "Mathematical function calculation tool, supporting trigonometric, logarithmic, exponential functions, etc.",
        "args": {
            "function": "(string) Mathematical function type. Required. Supports: 'sin', 'cos', 'tan', 'asin', 'acos', 'atan', 'sinh', 'cosh', 'tanh', 'log', 'log10', 'ln', 'exp', 'sqrt', 'cbrt', 'abs', 'ceil', 'floor', 'round', 'factorial', 'gamma'.",
            "value": "(float) Input value for the function. Required.",
            "base": "(float, Optional) Base for logarithm. Only for 'log' function, defaults to 10.",
            "precision": "(int, Optional) Number of decimal places for the result. Range 0-15.",
            "angle_unit": "(string, Optional) Angle unit. Used for trigonometric functions, supports 'radians', 'degrees'. Defaults to 'radians'.",
        },
        "returns": "Dictionary containing the function calculation result.",
        "examples": [
            "mathematical_functions(function='sin', value=1.57, angle_unit='radians')",
            "mathematical_functions(function='log', value=100, base=10)",
        ],
    },
    # Number Converter Tool
    "number_converter": {
        "name": "number_converter",
        "description": "Number format conversion tool, supporting base conversion, scientific notation, etc.",
        "args": {
            "number": "(string) The number to convert (provided as a string). Required.",
            "from_base": "(int, Optional) Source base. Range 2-36, defaults to 10.",
            "to_base": "(int, Optional) Target base. Range 2-36, defaults to 10.",
            "operation": "(string, Optional) Type of conversion operation. Supports: 'convert'(base conversion), 'format'(formatting), 'scientific'(scientific notation), 'fraction'(fraction form). Defaults to 'convert'.",
            "precision": "(int, Optional) Precision. Number of decimal places for scientific/engineering notation.",
        },
        "returns": "Dictionary containing the conversion result.",
        "examples": [
            "number_converter(number='255', from_base=10, to_base=16)",
            "number_converter(number='1010', from_base=2, to_base=10)",
        ],
    },
    # Unit Converter Tool
    "unit_converter": {
        "name": "unit_converter",
        "description": "Physical unit conversion tool, supporting length, weight, temperature, etc., unit conversions.",
        "args": {
            "value": "(float) The numerical value to convert. Required.",
            "from_unit": "(string) Source unit. Required.",
            "to_unit": "(string) Target unit. Required.",
            "unit_type": "(string) Unit type. Required. Supports: 'length', 'weight', 'temperature', 'area', 'volume', 'time', 'speed', 'energy'.",
        },
        "returns": "Dictionary containing the conversion result.",
        "examples": [
            "unit_converter(value=100, from_unit='cm', to_unit='m', unit_type='length')",
            "unit_converter(value=32, from_unit='fahrenheit', to_unit='celsius', unit_type='temperature')",
        ],
    },
    # Precision Calculator Tool
    "precision_calculator": {
        "name": "precision_calculator",
        "description": "High-precision numerical calculation tool, supporting arithmetic operations with arbitrary precision.",
        "args": {
            "numbers": "(list[float]) List of numerical values for calculation. Required.",
            "operation": "(string) Operation type. Required. Supports: 'add', 'subtract', 'multiply', 'divide', 'power', 'sqrt', 'factorial'.",
            "precision_digits": "(int, Optional) Number of precision digits. Defaults to 10.",
            "rounding_mode": "(string, Optional) Rounding mode. Supports: 'round_half_up', 'round_down', etc. Defaults to 'round_half_up'.",
        },
        "returns": "Dictionary containing the high-precision calculation result.",
        "examples": [
            "precision_calculator(numbers=[1.123, 2.987], operation='add', precision_digits=15)",
            "precision_calculator(numbers=[2], operation='sqrt', precision_digits=20)",
        ],
    },
    # Number Properties Tool
    "number_properties": {
        "name": "number_properties",
        "description": "Numerical property analysis tool, analyzes various mathematical properties of numbers.",
        "args": {
            "number": "(float) The number to analyze. Required.",
            "analysis_type": "(string, Optional) Type of analysis. Supports: 'comprehensive'(comprehensive), 'prime'(prime), 'factor'(factor), 'digital'(digital features), 'classification'(classification). Defaults to 'comprehensive'.",
        },
        "returns": "Dictionary containing the number property analysis results.",
        "examples": [
            "number_properties(number=17, analysis_type='comprehensive')",
            "number_properties(number=100, analysis_type='factor')",
        ],
    },
    # Matrix Calculator Tool
    "matrix_calculator": {
        "name": "matrix_calculator",
        "description": "Matrix and linear algebra calculation tool, supporting basic operations and advanced analysis.",
        "args": {
            "operation": "(string) Matrix operation type. Required. Supports: 'basic', 'decomposition', 'eigenvalues', 'svd', 'properties', 'power', 'exponential', 'solve'. When operation='basic', 'method' can specify 'add', 'subtract', 'multiply', 'transpose', 'determinant', 'inverse', etc.; when operation='decomposition', 'method' supports 'qr', 'lu'; when operation='properties', 'method'/'property_type' supports 'rank', 'trace', 'condition_number', 'norm'.",
            "matrix_a": "(list[list[float]]) First matrix (2D array). Required.",
            "matrix_b": "(list[list[float]], Optional) Second matrix. Used for dual-matrix operations like addition, multiplication.",
            "method": "(string, Optional) Calculation method. E.g., 'LU', 'QR', 'SVD' for decomposition.",
            "power": "(int, Optional) Matrix power. Used for 'power' operation.",
            "property_type": "(string, Optional) Matrix property type. Used for 'properties' operation, e.g., 'condition_number', 'norm'.",
        },
        "returns": "Dictionary containing matrix calculation results.",
        "examples": [
            "matrix_calculator(operation='add', matrix_a=[[1,2],[3,4]], matrix_b=[[5,6],[7,8]])",
            "matrix_calculator(operation='determinant', matrix_a=[[1,2],[3,4]])",
        ],
    },
    # Statistics Analyzer Tool
    "statistics_analyzer": {
        "name": "statistics_analyzer",
        "description": "Statistical analysis tool, supporting descriptive statistics, hypothesis testing, correlation analysis, distribution analysis, etc.",
        "args": {
            "data1": "(list[float]) First set of sample data. Required.",
            "analysis_type": "(string) Main analysis type. Required. Supports: 'descriptive'(descriptive statistics), 'tests'(tests), 'distribution'(distribution analysis), 'confidence_interval'(confidence interval).",
            "data2": "(list[float], Optional) Second set of sample data. Used for analyses requiring two datasets, e.g., two-sample t-test or correlation analysis.",
            "test_type": "(string, Optional) Secondary analysis type. When analysis_type='tests', supports 'normality'(normality test), 'hypothesis'(hypothesis test), 'correlation'(correlation test). When analysis_type='distribution', supports 'fitting'(distribution fitting), 'percentiles'(percentiles), 'outliers'(outlier detection).",
            "hypothesis_test_type": "(string, Optional) Specific hypothesis test type. Used when test_type='hypothesis', e.g., 'one_sample_t', 'two_sample_t', 'paired_t', 'anova', 'chi_square'.",
            "confidence": "(float, Optional) Confidence level. Used for 'confidence_interval' or hypothesis testing. Range 0-1, defaults to 0.95.",
            "distribution_type": "(string, Optional) Specific distribution type. Used for distribution fitting (test_type='fitting'), e.g., 'normal', 'gamma', 'beta'. If provided, only this distribution is fitted; otherwise, all supported distributions are attempted.",
        },
        "returns": "Dictionary containing statistical analysis results.",
        "examples": [
            "statistics_analyzer(data1=[1,2,3,4,5], analysis_type='descriptive')",
            "statistics_analyzer(data1=[10,12,13,15,16], analysis_type='distribution', test_type='fitting', distribution_type='normal')",
            "statistics_analyzer(data1=[1,2,3,4,5,100], analysis_type='distribution', test_type='outliers')",
            "statistics_analyzer(data1=[1,2,3,4,5], analysis_type='tests', test_type='normality')",
        ],
    },
    # Calculus Engine
    "calculus_engine": {
        "name": "calculus_engine",
        "description": "Calculus computation tool, supporting differentiation, integration, limits, series, etc.",
        "args": {
            "expression": "(string) Mathematical expression (string format). Required.",
            "operation": "(string) Calculus operation type. Required. Supports: 'derivative', 'integral', 'limit', 'series', 'taylor', 'solve'.",
            "variable": "(string, Optional) Variable name. Defaults to 'x'.",
            "variables": "(list[str], Optional) List of multiple variables. Used for multivariable operations like partial derivatives.",
            "limits": "(list[float], Optional) List of integration limits. Format [lower_limit, upper_limit]. Used for definite integrals.",
            "point": "(float, Optional) Single calculation point. Used for numerical derivative, limit point, etc.",
            "points": "(list[float], Optional) List of multiple calculation points. Used for batch calculation of derivative values, etc.",
            "order": "(int, Optional) Order. Used for higher-order derivatives or number of series terms. Defaults to 1.",
            "method": "(string, Optional) Calculation method. Supports 'quad' (numerical integration), etc. Defaults to 'quad'.",
            "mode": "(string, Optional) Calculation mode. Supports 'symbolic' (symbolic computation), 'numeric' (numerical computation). Defaults to 'symbolic'.",
        },
        "returns": "Dictionary containing calculus computation results.",
        "examples": [
            "calculus_engine(expression='x**2 + 3*x + 1', operation='derivative')",
            "calculus_engine(expression='sin(x)', operation='integral', limits=[0, 3.14159])",
            "calculus_engine(expression='1/(1+x**2)', operation='integral', limits=[-1, 1], method='quad')",
            "calculus_engine(expression='x**2', operation='derivative', points=[1, 2, 3])",
        ],
    },
    # Optimization Suite
    "optimization_suite": {
        "name": "optimization_suite",
        "description": "Numerical optimization algorithm tool, supporting function optimization, equation solving, linear programming, etc.",
        "args": {
            "objective_function": "(string, Optional) Objective function expression. Required for 'minimize'/'maximize'/'root_finding' operations; can be omitted when operation='linear_programming'.",
            "variables": "(list[str], Optional) List of variable names. Required for symbolic/numerical optimization; can be omitted if using pure linear programming (lp_c/lp_A_*).",
            "operation": "(string, Optional) Optimization operation type. Supports: 'minimize', 'maximize', 'root_finding', 'linear_programming'. Defaults to 'minimize'.",
            "method": "(string, Optional) Optimization method. E.g., 'BFGS', 'Nelder-Mead'. Defaults to 'auto'.",
            "initial_guess": "(list[float], Optional) List of initial guess values.",
            "bounds": "(list[tuple[float, float]], Optional) List of variable bounds. Format: [(lower_bound, upper_bound), ...].",
            "constraints": "(list[dict], Optional) List of constraints. Each constraint is in {'type': 'eq'/'ineq', 'fun': '...'} format.",
            "equation": "(string, Optional) Equation expression. Used for 'root_finding' operation.",
            "root_method": "(string, Optional) Equation solving method. Defaults to 'fsolve'.",
            "lp_c": "(list[float], Optional) Linear programming objective function coefficients. Used for 'linear_programming' operation.",
            "lp_A_ub": "(list[list[float]], Optional) Linear programming inequality constraint matrix. Used for 'linear_programming' operation.",
            "lp_b_ub": "(list[float], Optional) Linear programming inequality constraint right-hand side vector. Used for 'linear_programming' operation.",
            "lp_A_eq": "(list[list[float]], Optional) Linear programming equality constraint matrix. Used for 'linear_programming' operation.",
            "lp_b_eq": "(list[float], Optional) Linear programming equality constraint right-hand side vector. Used for 'linear_programming' operation.",
        },
        "returns": "Dictionary containing optimization results.",
        "examples": [
            "# Unconstrained function minimization",
            "optimization_suite(objective_function='(x-1)**2 + (y-2)**2', variables=['x', 'y'], operation='minimize')",
            "# Find equation root",
            "optimization_suite(objective_function='x**2 - 4', variables=['x'], operation='root_finding')",
            "# Linear programming (only lp_* parameters provided, no objective_function/variables needed)",
            "optimization_suite(operation='linear_programming', lp_c=[1, 2], lp_A_ub=[[1, 1]], lp_b_ub=[3])",
        ],
    },
    # Regression Modeler Tool
    "regression_modeler": {
        "name": "regression_modeler",
        "description": "Regression analysis and machine learning modeling tool, supporting various regression algorithms and prediction functions.",
        "args": {
            "operation": "(string, Optional) Regression operation type. Supports: 'fit'(fitting), 'predict'(prediction), 'residual_analysis'(residual analysis), 'model_comparison'(model comparison). Defaults to 'fit'.",
            "x_data": "(list[list[float]], Optional) Independent variable data. 2D array or list. Training data for 'fit' operation, data to predict for 'predict' operation.",
            "y_data": "(list[float], Optional) Dependent variable data. 1D array or list. Training labels for 'fit' operation.",
            "model_type": "(string, Optional) Regression model type. Supports: 'linear', 'polynomial', 'ridge', 'lasso', 'elastic_net', 'logistic'. Defaults to 'linear'.",
            "degree": "(int, Optional) Degree for polynomial regression. Defaults to 2.",
            "alpha": "(float, Optional) Regularization parameter. Defaults to 1.0.",
            "l1_ratio": "(float, Optional) Elastic Net L1 ratio. Range 0-1, defaults to 0.5.",
            "cv_folds": "(int, Optional) Number of cross-validation folds. Defaults to 5.",
            "test_size": "(float, Optional) Test set proportion. Range 0-1, defaults to 0.2.",
            "training_x": "(list[list[float]], Optional) Training independent variable data. Provide training data when using 'predict' operation.",
            "training_y": "(list[float], Optional) Training dependent variable data. Provide training labels when using 'predict' operation.",
            "model_params": "(dict, Optional) Pre-trained model parameters. Used for 'predict' operation, includes intercept and slopes/coefficients.",
            "y_true": "(list[float], Optional) True values. Used for 'residual_analysis' operation.",
            "y_pred": "(list[float], Optional) Predicted values. Used for 'residual_analysis' operation.",
            "models_results": "(list[dict], Optional) List of model results. Used for 'model_comparison' operation.",
        },
        "returns": "Dictionary containing regression analysis results.",
        "examples": [
            "regression_modeler(operation='fit', x_data=[[1], [2], [3]], y_data=[2, 4, 6], model_type='linear')",
            "regression_modeler(operation='predict', x_data=[[12]], training_x=[[1], [2], [3]], training_y=[2, 4, 6], model_type='linear')",
            "regression_modeler(operation='predict', x_data=[[12]], model_type='linear', model_params={'intercept': 0, 'slopes': [2]})",
            "regression_modeler(operation='fit', x_data=[[1], [2], [3]], y_data=[2, 4, 6], model_type='polynomial', degree=3)",
        ],
    },
    # Expression Evaluator Tool
    "expression_evaluator": {
        "name": "expression_evaluator",
        "description": "Mathematical expression evaluation and symbolic computation tool.",
        "args": {
            "expression": "(string) Mathematical expression. Required.",
            "variables": "(dict, Optional) Dictionary of variable values. Format: {'x': 1, 'y': 2}.",
            "mode": "(string, Optional) Computation mode. Supports: 'evaluate', 'simplify', 'expand', 'factor'. Defaults to 'evaluate'.",
            "output_format": "(string, Optional) Output format. Supports: 'decimal', 'fraction', 'scientific', 'latex'. Defaults to 'decimal'.",
        },
        "returns": "Dictionary containing expression evaluation results.",
        "examples": [
            "expression_evaluator(expression='2*x + 3*y', variables={'x': 5, 'y': 7})",
            "expression_evaluator(expression='x**2 + 2*x + 1', mode='factor')",
        ],
    },
    # Data Visualization Tool
    "create_and_save_chart": {
        "name": "create_and_save_chart",
        "description": "Data visualization and chart creation tool, supporting various statistical chart types.",
        "args": {
            "chart_type": "(string) Chart type. Required. Supports: 'bar', 'pie', 'line', 'scatter', 'histogram', 'box', 'heatmap', 'correlation_matrix', 'multi_series_line'.",
            "data": "(list[float], Optional) Single series data. Used for bar, pie, histogram, box plots.",
            "x_data": "(list[float], Optional) X-axis data. Used for line, scatter, multi-series line plots.",
            "y_data": "(list[float], Optional) Y-axis data. Used for line, scatter plots.",
            "y_data_series": "(list[list[float]], Optional) Multi-series Y-axis data. Used for multi-series line plots.",
            "series_labels": "(list[str], Optional) Labels for multi-series plots.",
            "matrix_data": "(list[list[float]], Optional) Matrix data. Used for heatmaps, multi-group box plots, correlation matrices.",
            "labels": "(list[str], Optional) Data labels. Used for bar charts, pie charts, etc.",
            "title": "(string, Optional) Chart title. Defaults to 'Statistical Chart'.",
            "xlabel": "(string, Optional) X-axis label. Defaults to 'X-axis'.",
            "ylabel": "(string, Optional) Y-axis label. Defaults to 'Y-axis'.",
            "filename": "(string, Optional) Save filename (without path and extension). If not provided, will be auto-generated.",
            "format": "(string, Optional) Image format. Supports 'png', 'jpg', 'svg', etc. Defaults to 'png'.",
            "colors": "(list[str], Optional) List of colors. Used for custom chart colors.",
            "figsize": "(tuple[float, float], Optional) Figure size. Format (width, height).",
            "dpi": "(int, Optional) Image resolution. Defaults to 300.",
            "style": "(string, Optional) Chart style. Defaults to 'whitegrid'.",
            "show_values": "(bool, Optional) Whether to display value labels. Used for bar charts. Defaults to False.",
            "horizontal": "(bool, Optional) Whether it is a horizontal bar chart. Used for bar charts. Defaults to False.",
            "trend_line": "(bool, Optional) Whether to display a trend line. Used for scatter plots. Defaults to False.",
            "trend_line_color": "(string, Optional) Trend line color. Used for scatter plots.",
            "trend_line_equation": "(string, Optional) Trend line equation text. Used for scatter plots.",
            "bins": "(int, Optional) Number of bins for histogram. Defaults to 30.",
            "annotate": "(bool, Optional) Whether to display numerical annotations. Used for heatmaps. Defaults to True.",
            "colormap": "(string, Optional) Colormap. Used for heatmaps. Defaults to 'viridis'.",
            "color": "(string, Optional) Single color. Used for line plots, scatter plots, etc.",
            "line_width": "(float, Optional) Line width. Used for line plots. Defaults to 2.0.",
            "line_style": "(string, Optional) Line style. Used for line plots. Defaults to '-'.",
            "marker": "(string, Optional) Marker style. Used for line plots, scatter plots. Defaults to 'o'.",
            "marker_size": "(int, Optional) Marker size. Used for line plots, scatter plots. Defaults to 6.",
            "alpha": "(float, Optional) Transparency. Range 0-1. Defaults to 0.7.",
            "grid": "(bool, Optional) Whether to display grid. Defaults to True.",
        },
        "returns": "Dictionary containing chart creation results, including file save path, operation status, data summary, etc.",
        "examples": [
            "create_and_save_chart(chart_type='line', x_data=[1,2,3,4], y_data=[1,4,2,3], title='Line Plot')",
            "create_and_save_chart(chart_type='histogram', data=[1,2,2,3,3,3,4,4,5], filename='histogram_plot')",
            "create_and_save_chart(chart_type='bar', data=[10,24,35,20], labels=['A','B','C','D'], filename='bar_chart', format='svg')",
            "create_and_save_chart(chart_type='scatter', x_data=[1,2,3,4,5], y_data=[2,4,1,3,5], trend_line=True)",
            "create_and_save_chart(chart_type='multi_series_line', x_data=[1,2,3,4], y_data_series=[[1,4,2,3], [2,3,4,1]], series_labels=['Series 1', 'Series 2'])",
        ],
    },
    # Function Plotting Tool
    "plot_function_curve": {
        "name": "plot_function_curve",
        "description": "Mathematical function curve plotting tool, supporting function graph visualization and derivative analysis.",
        "args": {
            "function_expression": "(string) Function expression. Required. Supports common math functions like sin, cos, tan, exp, log, sqrt, etc.",
            "variable": "(string, Optional) Independent variable name. Defaults to 'x'.",
            "x_range": "(tuple[float, float], Optional) X-axis range. Format (min_value, max_value). Defaults to (-10, 10).",
            "num_points": "(int, Optional) Number of plotting points. Defaults to 1000.",
            "title": "(string, Optional) Chart title. Defaults to 'Function Plot'.",
            "xlabel": "(string, Optional) X-axis label. Defaults to 'X-axis'.",
            "ylabel": "(string, Optional) Y-axis label. Defaults to 'Y-axis'.",
            "filename": "(string, Optional) Save filename (without path and extension). If not provided, a timestamped filename is auto-generated.",
            "format": "(string, Optional) Image format. Supports 'png', 'jpg', 'svg', etc. Defaults to 'png'.",
            "figsize": "(tuple[float, float], Optional) Figure size. Format (width, height). Defaults to (10, 6).",
            "dpi": "(int, Optional) Image resolution. Defaults to 300.",
            "color": "(string, Optional) Function curve color. Defaults to 'blue'.",
            "line_width": "(float, Optional) Line width. Defaults to 2.0.",
            "grid": "(bool, Optional) Whether to display grid. Defaults to True.",
            "grid_alpha": "(float, Optional) Grid transparency. Range 0-1. Defaults to 0.3.",
            "derivative_order": "(int, Optional) Derivative order. If provided, the n-th derivative curve of the function will also be plotted.",
            "show_critical_points": "(bool, Optional) Whether to show critical points (extrema). Defaults to False. Only effective if derivative_order is provided.",
            "show_equation": "(bool, Optional) Whether to display the function equation on the plot. Defaults to True.",
            "equation_position": "(string, Optional) Equation display position. Supports 'upper right', 'upper left', 'lower right', 'lower left'. Defaults to 'upper right'.",
            "alpha": "(float, Optional) Line transparency. Range 0-1. Defaults to 1.0.",
            "line_style": "(string, Optional) Line style. Defaults to '-'.",
            "marker": "(string, Optional) Data point marker. Defaults to '' (no marker).",
            "marker_size": "(int, Optional) Marker size. Defaults to 6.",
        },
        "returns": "Dictionary containing function plotting results, including file save path, operation status, function information, etc.",
        "examples": [
            "plot_function_curve(function_expression='x**2 + 2*x + 1')",
            "plot_function_curve(function_expression='sin(x)', x_range=(-6.28, 6.28), filename='sine_wave')",
            "plot_function_curve(function_expression='x**3 - 3*x', derivative_order=1, show_critical_points=True, filename='cubic_with_critical_points')",
            "plot_function_curve(function_expression='exp(-x**2)', x_range=(-3, 3), color='red', show_equation=True)",
        ],
    },
    # Resource Cleanup Tool
    "cleanup_resources": {
        "name": "cleanup_resources",
        "description": "Deletes files generated in OUTPUT_PATH (or default temporary directory) and performs basic resource cleanup. Call only when the user explicitly indicates deletion of temporary or output files.",
        "args": {},
        "returns": "Dictionary containing cleanup results, reporting the number of cleaned files and status.",
        "examples": ["cleanup_resources()"],
    },
}
