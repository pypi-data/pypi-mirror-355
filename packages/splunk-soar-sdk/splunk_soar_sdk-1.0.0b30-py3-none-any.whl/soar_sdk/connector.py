from dataclasses import dataclass
from typing import Any, TYPE_CHECKING, Union, Optional
from collections.abc import Iterable, AsyncIterable
from collections.abc import Mapping

from pydantic import ValidationError
import httpx

from soar_sdk.input_spec import InputSpecification
from soar_sdk.shims.phantom.action_result import ActionResult as PhantomActionResult
from soar_sdk.shims.phantom.base_connector import BaseConnector
from soar_sdk.apis.artifact import Artifact
from soar_sdk.apis.container import Container
from soar_sdk.apis.vault import Vault

from .abstract import SOARClient, JSONType

if TYPE_CHECKING:
    from .actions_provider import ActionsProvider


_INGEST_STATE_KEY = "ingestion_state"
_AUTH_STATE_KEY = "auth_state"
_CACHE_STATE_KEY = "asset_cache"


@dataclass
class BasicAuth:
    username: str
    password: str


class AppConnector(BaseConnector, SOARClient):
    """
    The connector mainly generated by the App Wizard. It is extended to properly work
    with handlers provided by the app.

    Serves as the layer for exposing public BaseConnector API interface, so that App
    is no longer calling phantom library directly.

    In the future it should be replaced by another class accessing SOAR API.
    """

    def __init__(self, actions_provider: "ActionsProvider") -> None:
        # Call the BaseConnectors init first
        super().__init__()

        self.actions_provider = actions_provider
        self._client = httpx.Client(
            base_url=AppConnector.get_soar_base_url(),
            verify=False,  # noqa: S501
        )
        self.csrf_token: str = ""

        self.ingestion_state: dict = {}
        self.auth_state: dict = {}
        self.asset_cache: dict = {}
        self._artifacts_api = Artifact(soar_client=self)
        self._containers_api = Container(soar_client=self)
        self._vault_api = Vault(soar_client=self)
        self.basic_auth: Optional[BasicAuth] = None

    @property
    def client(self) -> httpx.Client:
        return self._client

    @property
    def artifact(self) -> Artifact:
        return self._artifacts_api

    @property
    def container(self) -> Container:
        return self._containers_api

    @property
    def vault(self) -> Vault:
        return self._vault_api

    def update_client(self, input_data: InputSpecification) -> None:
        self.authenticate_soar_client(input_data)
        self._containers_api.set_executing_asset(input_data.asset_id)

    def authenticate_soar_client(self, input_data: InputSpecification) -> None:
        session_id = input_data.user_session_token
        if session_id:
            self.__login()
        else:
            if input_data.soar_auth:
                self._client = httpx.Client(
                    base_url=input_data.soar_auth.phantom_url,
                    verify=False,  # noqa: S501
                )
                self.__login()
                self.__basic_auth = BasicAuth(
                    input_data.soar_auth.username, input_data.soar_auth.password
                )
                session_id = self.get_session_id()

        if session_id:
            current_cookies = self._client.headers.get("Cookie", "")
            update_cookies = f"sessionid={session_id};{current_cookies}"
            self._client.headers.update({"Cookie": update_cookies})

    def __login(self) -> None:
        response = self._client.get("/login")
        response.raise_for_status()
        self.csrf_token = response.cookies.get("csrftoken") or ""
        self._client.cookies.update(response.cookies)
        self._client.headers.update({"X-CSRFToken": self.csrf_token})
        cookies = f"csrftoken={self.csrf_token}"
        self._client.headers.update({"Cookie": cookies})

    def get_session_id(self) -> str:
        self._client.post(
            "/login",
            data={
                "username": self.__basic_auth.username,
                "password": self.__basic_auth.password,
                "csrfmiddlewaretoken": self.csrf_token,
            },
            headers={"Referer": f"{self._client.base_url}/login"},
        )
        session_id = self._client.cookies.get("sessionid")
        return session_id or ""

    def get(
        self,
        endpoint: str,
        *,
        params: Optional[Union[dict[str, Any], httpx.QueryParams]] = None,
        headers: Optional[dict[str, str]] = None,
        cookies: Optional[dict[str, str]] = None,
        timeout: Optional[httpx.Timeout] = None,
        auth: Optional[Union[httpx.Auth, tuple[str, str]]] = None,
        follow_redirects: bool = False,
        extensions: Optional[Mapping[str, Any]] = None,
    ) -> httpx.Response:
        """
        Perform a GET request to the specfic endpoint using the soar client
        """
        response = self._client.get(
            endpoint,
            params=params,
            headers=headers,
            cookies=cookies,
            timeout=timeout,
            auth=auth,
            follow_redirects=follow_redirects,
            extensions=extensions,
        )
        response.raise_for_status()
        return response

    def post(
        self,
        endpoint: str,
        *,
        content: Optional[
            Union[str, bytes, Iterable[bytes], AsyncIterable[bytes]]
        ] = None,
        data: Optional[Mapping[str, Any]] = None,
        files: Optional[dict[str, Any]] = None,
        json: Optional[JSONType] = None,
        params: Optional[dict[str, Any]] = None,
        headers: Optional[dict[str, str]] = None,
        cookies: Optional[dict[str, str]] = None,
        auth: Optional[Union[httpx.Auth, tuple[str, str]]] = None,
        timeout: Optional[Union[float, httpx.Timeout]] = None,
        follow_redirects: bool = True,
        extensions: Optional[Mapping[str, Any]] = None,
    ) -> httpx.Response:
        """
        Perform a POST request to the specfic endpoint using the soar client
        """
        headers = headers or {}
        headers.update({"Referer": f"{self._client.base_url}/{endpoint}"})
        response = self._client.post(
            endpoint,
            headers=headers,
            content=content,
            data=data,
            files=files,
            json=json,
            params=params,
            cookies=cookies,
            auth=auth,  # type: ignore[arg-type]
            timeout=timeout,
            follow_redirects=follow_redirects,
            extensions=extensions,
        )
        response.raise_for_status()
        return response

    def put(
        self,
        endpoint: str,
        *,
        content: Optional[
            Union[str, bytes, Iterable[bytes], AsyncIterable[bytes]]
        ] = None,
        data: Optional[Mapping[str, Any]] = None,
        files: Optional[dict[str, Any]] = None,
        json: Optional[JSONType] = None,
        params: Optional[dict[str, Any]] = None,
        headers: Optional[dict[str, str]] = None,
        cookies: Optional[dict[str, str]] = None,
        auth: Optional[Union[httpx.Auth, tuple[str, str]]] = None,
        timeout: Optional[Union[float, httpx.Timeout]] = None,
        follow_redirects: bool = True,
        extensions: Optional[Mapping[str, Any]] = None,
    ) -> httpx.Response:
        """
        Perform a PUT request to the specfic endpoint using the soar client
        """
        headers = headers or {}
        headers.update({"Referer": f"{self._client.base_url}/{endpoint}"})
        response = self._client.put(
            endpoint,
            headers=headers,
            content=content,
            data=data,
            files=files,
            json=json,
            params=params,
            cookies=cookies,
            auth=auth,  # type: ignore[arg-type]
            timeout=timeout,
            follow_redirects=follow_redirects,
            extensions=extensions,
        )
        response.raise_for_status()
        return response

    def delete(
        self,
        endpoint: str,
        *,
        params: Optional[Union[dict[str, Any], httpx.QueryParams]] = None,
        headers: Optional[dict[str, str]] = None,
        cookies: Optional[dict[str, str]] = None,
        auth: Optional[Union[httpx.Auth, tuple[str, str]]] = None,
        timeout: Optional[httpx.Timeout] = None,
        follow_redirects: bool = False,
        extensions: Optional[Mapping[str, Any]] = None,
    ) -> httpx.Response:
        """
        Perform a DELETE request to the specfic endpoint using the soar client
        """

        headers = headers or {}
        headers.update({"Referer": f"{self._client.base_url}/{endpoint}"})
        response = self._client.delete(
            endpoint,
            params=params,
            headers=headers,
            cookies=cookies,
            auth=auth
            or httpx.BasicAuth(self.__basic_auth.username, self.__basic_auth.password)
            if self.basic_auth
            else None,  # type: ignore[arg-type]
            timeout=timeout,
            follow_redirects=follow_redirects,
            extensions=extensions,
        )
        response.raise_for_status()
        return response

    @classmethod
    def get_soar_base_url(cls) -> str:
        return cls._get_phantom_base_url()

    def set_csrf_info(self, token: str, referer: str) -> None:
        """Public method for setting the CSRF token in connector."""
        self._set_csrf_info(token, referer)

    def handle(
        self, input_data: InputSpecification, handle: Optional[int] = None
    ) -> str:
        """Public method for executing an action from a JSON string."""
        self.print_progress_message = True
        return self._handle_action(input_data.json(), handle or 0)

    def handle_action(self, param: dict[str, Any]) -> None:
        # Get the action that we are supposed to execute for this App Run
        action_id = self.get_action_identifier()
        self.debug_print("action_id", action_id)

        if handler := self.actions_provider.get_action(action_id):
            try:
                params = handler.meta.parameters.parse_obj(param)
            except (ValueError, ValidationError):
                # FIXME: Consider adding more details to this error, but be aware
                #  of possible PIIs.
                self.save_progress(
                    "Validation Error - the params data for action could not be parsed"
                )
                return

            handler(params)

        else:
            raise RuntimeError(f"Action {action_id} not found.")

    def initialize(self) -> bool:
        # Load the state in initialize, use it to store data
        # that needs to be accessed across actions
        state = self.load_state() or {}
        self.ingestion_state = state.get(_INGEST_STATE_KEY, {})
        self.auth_state = state.get(_AUTH_STATE_KEY, {})
        self.asset_cache = state.get(_CACHE_STATE_KEY, {})

        return True

    def finalize(self) -> bool:
        state = {
            _INGEST_STATE_KEY: self.ingestion_state,
            _AUTH_STATE_KEY: self.auth_state,
            _CACHE_STATE_KEY: self.asset_cache,
        }
        self.save_state(state)
        return True

    def add_result(self, action_result: PhantomActionResult) -> PhantomActionResult:
        return self.add_action_result(action_result)

    def get_results(self) -> list[PhantomActionResult]:
        return self.get_action_results()

    def debug(
        self,
        tag: str,
        dump_object: Union[str, list, dict, PhantomActionResult, Exception] = "",
    ) -> None:
        self.debug_print(tag, dump_object)

    def error(
        self,
        tag: str,
        dump_object: Union[str, list, dict, PhantomActionResult, Exception] = "",
    ) -> None:
        self.error_print(tag, dump_object)

    def add_exception(self, exception: Exception) -> None:
        self._BaseConnector__conn_result.add_exception(exception)
