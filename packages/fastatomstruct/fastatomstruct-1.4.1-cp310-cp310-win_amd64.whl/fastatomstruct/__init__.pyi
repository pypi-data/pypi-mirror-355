"""
This type stub file was generated by pyright.
"""

import ase
import numpy as np
from enum import Enum
from typing import Any, Callable, Dict, List, Optional, Union
from time import time
from .fastatomstruct import *
from scipy.integrate import simpson as simps
from scipy.fftpack import fft
from tidynamics import msd

"""
This type stub file was generated by pyright.
"""
rank = ...

def is_root() -> bool:
    """Check if the current process is the root process."""
    ...

def chunks(indices: List[int], n: int):
    """Yield successive chunks from list of atoms."""
    ...

def ipar(
    func: Callable, atoms: List[ase.Atoms], *args: List[Any], **kwargs: Dict[Any, Any]
) -> List[Any]:
    """Image-based parallelization.

    The calculation of many structural quantities is parallelized over atoms.
    However, image-based parallelization (or a mixture of both) can be more efficient
    in some cases. This function makes using this parallelization layer quite easy.
    You can just use it as a simple wrapper around other functions implemented in
    `fastatomstruct` (see example below). **This function needs a working installation
    of the MPI4Py package!** You can set the `RAYON_NUM_THREADS` enviroment variable
    to control the number of threads.

    Arguments:
        func (Callable): Some function from the `fastatomstruct` package
        atoms (List[ase.Atoms]): List of ASE configurations

    Returns:
        List of results; type depends on the output of func

    Examples:

    The exemplary file "Sb-1.00-300-100.traj" `can be found here <https://zivgitlab.uni-muenster.de/ag-salinga/fastatomstruct/-/raw/master/python/test/structures/Sb-1.00-300-100.traj>`__.
    The code below needs to be run e.g. with `mpirun -n 2 test.py`. In this case,
    two processes will be used.

    .. plot::

       >>> import matplotlib.pyplot as plt
       >>> import fastatomstruct as fs
       >>> from ase import io
       >>> if fs.is_root():
       >>>     atoms = io.read("Sb-1.00-300-100.traj", index="::200")
       >>> q = fs.ipar(fs.q_tetrahedral, atoms, fs.CutoffMode.Fixed(3.2), 3)
       >>> if fs.is_root():
       >>>     plt.hist(q[0], bins=25, alpha=0.5)
       >>>     plt.hist(q[1], bins=25, color="C3", alpha=0.5)
    """
    ...

def static_structure_factor(
    atoms: Union[ase.Atoms, List[ase.Atoms]],
    q: np.ndarray,
    r_max: float,
    n_bins: int,
    filter: Optional[Union[FilterTag, FilterElement]] = ...,
) -> np.ndarray:
    """Static structure factor, as calculated from the RDF.

    For isotropic systems, the static structure factor can be calculated using

    .. math::

        S(q) = q + 4 \\pi \\rho \\int_0^\\infty r (g(r) - 1) \\frac{\\sin{qr}}{q} dr,

    with :math:`q` the absolute value of the reciprocal vector and :math:`g(r)`
    the radial distribution function.

    Arguments:
        atoms (Union[ase.Atoms, List[ase.Atoms]]): Atoms object(s) from ASE
        q (np.ndarray): Array with values of :math:`q`
        r_max (float): Cutoff radius for calculating the radial distribution function
        n_bins (int): Number of bins for calculating the radial distribution function
        filter (Optional[Union[fastatomstruct.FilterTag, fastatomstruct.FilterElement]]): Filter applied to the atoms

    Returns:
        np.ndarray of floats with values of :math:`S(q)`

    Examples
    --------

    The exemplary file "SbViscosity-1000K.traj" `can be found here <https://zivgitlab.uni-muenster.de/ag-salinga/fastatomstruct/-/raw/master/python/test/structures/SbViscosity-1000K.traj>`__.

    .. plot::

       >>> import matplotlib.pyplot as plt
       >>> import fastatomstruct as fs
       >>> import numpy as np
       >>> from ase import io
       >>> atoms = atoms = io.read("SbViscosity-1000K.traj", index="-500::10")
       >>> q = np.linspace(1.1, 10, 100)
       >>> s = fs.static_structure_factor(atoms, q, 10, 100)
       >>> plt.plot(q, s)
       >>> plt.xlabel(r"$q$")
       >>> plt.ylabel(r"$S(q)$")
       >>> plt.xlim(0, 10)
    """
    ...

def mean_squared_displacement(atoms: List[ase.Atoms], timestep: float) -> np.ndarray:
    """Mean squared displacment of a trajectory.

    The MSD is calculated using the `tidynamics` package. It is defined as

    .. math::

        \\mathrm{MSD} = \\frac{1}{N} \\sum_{i = 1}^N |\\vec{x}_i(t) - \\vec{x}_i(0)|^2,

    where the :math:`\\vec{x}_i(t)` are the atomic positions at time :math:`t`.

    Arguments:
        atoms (List[ase.Atoms]): Trajectory, atoms objects from ASE
        timestep (float): Time step

    Returns:
        NumPy Array of floats containing the mean squared displacement

    Examples
    --------

    The exemplary file "Sb-1.00-300-100.traj" `can be found here <https://zivgitlab.uni-muenster.de/ag-salinga/fastatomstruct/-/raw/master/python/test/structures/Sb-1.00-300-100.traj>`__.

    .. plot::

       >>> import matplotlib.pyplot as plt
       >>> import fastatomstruct as fs
       >>> import numpy as np
       >>> from ase import io
       >>> atoms = io.read("Sb-1.00-300-100.traj", index=":")
       >>> time, msd = fs.mean_squared_displacement(atoms, 200)
       >>> plt.loglog(time, msd)
       >>> plt.xlabel(r"$t$ (ps)")
       >>> plt.ylabel(r"Mean squared displacement ($\\mathrm{\\AA^2}$)")
    """
    ...

def squared_displacement(atoms: List[ase.Atoms]) -> np.ndarray:
    """Squared displacment of a trajectory.

    The SD is calculated using the `tidynamics` package. It is defined as

    .. math::

        \\mathrm{SD}_i = |\vec{x}_i(t) - \vec{x}_i(0)|^2,

    where the :math:`\vec{x}_i(t)` are the atomic positions at time :math:`t`.

    Arguments:
        atoms (List[ase.Atoms]): Trajectory, atoms objects from ASE

    Returns:
        NumPy Array of floats containing the mean squared displacement

    Examples
    --------

    The exemplary file "Sb-1.00-300-100.traj" `can be found here <https://zivgitlab.uni-muenster.de/ag-salinga/fastatomstruct/-/raw/master/python/test/structures/Sb-1.00-300-100.traj>`__.

    >>> import fastatomstruct as fs
    >>> from ase import io
    >>> atoms = io.read("Sb-1.00-300-100.traj", index=":")
    >>> fs.mean_squared_displacement(atoms)
    array([[-2.91038305e-11,  8.38161177e-02,  1.25422533e-01, ...,
             6.15651363e-01,  5.27809637e-01,  6.19426924e-01],
           [ 0.00000000e+00,  9.27498088e-02,  1.52887610e-01, ...,
             1.07754904e+00,  1.10512104e+00,  1.46645886e+00],
           [-1.16415322e-10,  8.61089322e-02,  1.37081905e-01, ...,
             1.27085909e+00,  1.18840340e+00,  9.64727558e-01],
           ...,
           [-4.65661287e-10,  9.55223907e-02,  1.56593970e-01, ...,
             4.45991428e-01,  2.80684893e-01,  1.91919705e-01],
           [ 0.00000000e+00,  8.69368854e-02,  1.34933834e-01, ...,
             4.86719506e-01,  3.47152810e-01,  5.66086433e-01],
           [-9.31322575e-10,  8.86508557e-02,  1.46782934e-01, ...,
             6.20435820e-01,  7.15149704e-01,  1.23890466e+00]])
    """
    ...

class VDOSMethod(Enum):
    DIRECT = ...
    VACF = ...

def vibrational_dos(
    atoms: List[ase.Atoms],
    timestep: float,
    full_out: bool = ...,
    method: VDOSMethod = ...,
    area: float = ...,
    use_masses: bool = ...,
    window: bool = ...,
    mirror: bool = ...,
    npad: Optional[int] = ...,
    to_next: bool = ...,
):
    """Phonon DOS by direct FFT of velocities, or FFT of the VACF.

    The vibrational density of states (DOS) :cite:`leeInitioStudiesStructural1993` is calculated using either the direct Fast Fourier Transform (FFT) of the velocities or the FFT of the Velocity Auto-Correlation Function (VACF). The method used is specified by the `method` argument.

    - If `method` is `VDOSMethod.DIRECT`, the DOS is calculated by performing an FFT on the velocity data directly.
    - If `method` is `VDOSMethod.VACF`, the DOS is calculated by first computing the VACF of the velocities and then performing an FFT on the VACF.

    The integral area under the frequency-PDOS curve is normalized to the value specified by the `area` argument. Zero-padding the velocities (specified by `npad`) is recommended.

    Welch windowing can be applied to the data before performing the FFT to reduce spectral leakage, which is controlled by the `window` argument. Additionally, the data can be mirrored before the FFT, controlled by the `mirror` argument.

    The function returns a tuple containing the frequency and the PDOS. If `full_out` is set to True, additional outputs may be included in the returned tuple.

    Arguments:
        atoms (List[ase.Atoms]): Atoms object(s) from ASE
        timestep (float): Time step
        full_out (bool): Whether all output should be given, or just frequency and PDOS
        method (fastatomstruct.VDOSMethod): Method for the DOS calculation (VDOSMethod.DIRECT or VDOSMethod.VACF). PDOSMethod.DIRECT is recommended.
        area (float): Normalize area under frequency-PDOS curve to this value
        use_masses (bool): Whether to use masses in the calculation (default: True)
        window (bool): Use Welch windowing on data before FFT (reduces leaking effect,
        recommended, default is True)
        mirror (bool): Mirror one-sided VACF at t=0 before FFT (default: False)
        to_next (bool): method=PDOSMethod.DIRECT only: Pad `vel` with zeros along `axis` up to the next power of two after the array length determined by `npad`. This gives you speed, but variable (better) frequency resolution. Default: False

    Returns
    -------
        if full_out = False
            | ``(faxis, pdos)``
            | faxis : 1d array [1/unit(dt)]
            | pdos : 1d array, the phonon DOS, normalized to `area`
        if full_out = True
            | if method == 'direct':
            |     ``(faxis, pdos, (full_faxis, full_pdos, split_idx))``
            | if method == 'vavcf':
            |     ``(faxis, pdos, (full_faxis, full_pdos, split_idx, vacf, fft_vacf))``
            |     fft_vacf : 1d complex array, result of fft(vacf) or fft(mirror(vacf))
            |     vacf : 1d array, the VACF

    Examples
    --------

    .. plot::

       >>> import matplotlib.pyplot as plt
       >>> import fastatomstruct as fs
       >>> from ase import io
       >>> atoms = io.read("SbViscosity-1000K.traj", index=":")
       >>> freq, pdos = fs.vibrational_dos(atoms, 50)
       >>> freq *= 1000
       >>> plt.plot(freq, pdos, label="Direct")
       >>> freq, pdos = fs.vibrational_dos(atoms, 50, method=fs.VDOSMethod.VACF)
       >>> freq *= 1000
       >>> plt.plot(freq, pdos, color="C3", label="VACF")
       >>> plt.xlim(freq.min(), freq.max())
       >>> plt.xlim(0, 5)
       >>> plt.ylim(0, 350)
       >>> plt.xlabel("Frequency (THz)")
       >>> plt.ylabel("Phonon DOS")
       >>> plt.legend()
       >>> plt.tight_layout()
    """
    ...
