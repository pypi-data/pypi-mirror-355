"""Secure, simple authentication utilities for FastHTML applications"""

# AUTOGENERATED! DO NOT EDIT! File to edit: ../nbs/00_auth.ipynb.

# %% auto 0
__all__ = ['hash_password', 'verify_password', 'User', 'init_auth_tables', 'create_user', 'get_user_by_id', 'get_user_by_email',
           'get_user_by_username', 'update_user', 'delete_user', 'check_permission', 'authenticate_user', 'UserLogin',
           'track_login', 'is_username_available', 'is_email_available', 'validate_user_data', 'user_auth_before',
           'get_user_from_session', 'create_auth_token', 'verify_auth_token']

# %% ../nbs/00_auth.ipynb 3
import bcrypt
import secrets
from typing import Optional, Dict, Any, List
from functools import wraps
from dataclasses import dataclass, field
from datetime import datetime
from fastlite import *
from apswutils.db import NotFoundError
import sqlite3

# %% ../nbs/00_auth.ipynb 4
__all__ = ['hash_password', 'verify_password', 'User', 'init_auth_tables', 'create_user', 'get_user_by_id', 'get_user_by_email',
           'get_user_by_username', 'update_user', 'delete_user', 'authenticate_user', 'check_permission', 'UserLogin', 'track_login',
           'is_username_available', 'is_email_available', 'validate_user_data', 'user_auth_before',
           'get_user_from_session', 'create_auth_token', 'verify_auth_token']

# %% ../nbs/00_auth.ipynb 9
def hash_password(password: str # The password to hash
                  ) -> str:     # The hashed password
    """Hash a password using bcrypt with a cost factor of 12.
    """
    salt = bcrypt.gensalt(rounds=12)
    hashed = bcrypt.hashpw(password.encode('utf-8'), salt)
    return hashed.decode('utf-8')

# %% ../nbs/00_auth.ipynb 12
def verify_password(password: str, # The password to verify
                    hashed: str    # The hashed password to compare against
                    ) -> bool:     # True if password matches hash, False otherwise
    """Verify a password against a bcrypt hash.
    """
    try:
        return bcrypt.checkpw(
            password.encode('utf-8'), 
            hashed.encode('utf-8')
        )
    except (ValueError, TypeError):
        # Invalid hash format
        return False

# %% ../nbs/00_auth.ipynb 15
@dataclass
class User:
    """User model for authentication.
    """
    username: str # The unique username
    email: str # The unique email address
    password_hash: str # The hashed password
    role: str = 'user' # The user role
    is_active: bool = True # Whether the user is active
    created_at: datetime = field(default_factory=datetime.utcnow) # The creation timestamp
    updated_at: datetime = field(default_factory=datetime.utcnow) # The last update timestamp
    id: Optional[int] = None

# %% ../nbs/00_auth.ipynb 16
def init_auth_tables(db_path: str = 'data.db' # The path to the SQLite database file
                    ) -> Database:            # The FastHTML Database instance configured with the User table
    """Creates the users table with proper schema and indexes. Uses FastHTML's MiniDataAPI for simple, transparent database operations.
    """
    # Create database connection using fastlite
    db = Database(db_path)
    
    # Create users table using MiniDataAPI pattern
    # Note: fastlite creates table name as 'user' (singular) by default
    users = db.create(User, pk='id')
    
    # Create user_logins table using MiniDataAPI pattern
    logins = db.create(UserLogin, pk='id', name='user_logins')
    
    # Create indexes for performance
    with db.conn:
        # User table indexes
        db.conn.execute('''
            CREATE INDEX IF NOT EXISTS idx_user_email 
            ON user(email)
        ''')
        db.conn.execute('''
            CREATE INDEX IF NOT EXISTS idx_user_username 
            ON user(username)
        ''')
        db.conn.execute('''
            CREATE UNIQUE INDEX IF NOT EXISTS idx_user_email_unique 
            ON user(email)
        ''')
        db.conn.execute('''
            CREATE UNIQUE INDEX IF NOT EXISTS idx_user_username_unique 
            ON user(username)
        ''')
        
        # User logins table index for foreign key performance
        db.conn.execute('''
            CREATE INDEX IF NOT EXISTS idx_user_logins_user_id 
            ON user_logins(user_id)
        ''')
    
    return db

# %% ../nbs/00_auth.ipynb 19
def create_user(db: Database,                  # The FastHTML Database instance
                username: str,                 # The unique username
                email: str,                    # The unique email address
                password: str,                 # The plain text password
                role: str = 'user',            # The user role
                table_name: str = 'user'       # The table name
                ) -> Optional[Dict[str, Any]]: # The created user dict or None if user already exists
    """Create a new user in the database.
    """
    users = db[table_name]
    
    # Check if user already exists
    if users(where="email = ? OR username = ?", where_args=[email, username]):
        return None
    
    # Create user with hashed password
    user_data = User(
        username=username,
        email=email,
        password_hash=hash_password(password),
        role=role
    )
    
    # Insert using MiniDataAPI
    return users.insert(user_data)

# %% ../nbs/00_auth.ipynb 20
def get_user_by_id(db: Database,                  # The FastHTML Database instance
                   user_id: int,                  # The user ID
                   table_name: str = 'user'       # The table name
                   ) -> Optional[Dict[str, Any]]: # The user dict or None if not found
    """Get user by ID.
    """
    users = db[table_name]
    try:
        return users[user_id]
    except NotFoundError:
        return None

# %% ../nbs/00_auth.ipynb 21
def get_user_by_email(db: Database,                  # The FastHTML Database instance
                      email: str,                    # The email address
                      table_name: str = 'user'       # The table name
                      ) -> Optional[Dict[str, Any]]: # The user dict or None if not found
    """Get user by email address.
    """
    users = db[table_name]
    results = users(where="email = ?", where_args=[email])
    return results[0] if results else None

# %% ../nbs/00_auth.ipynb 22
def get_user_by_username(db: Database,                  # The FastHTML Database instance
                         username: str,                 # The username
                         table_name: str = 'user'       # The table name
                         ) -> Optional[Dict[str, Any]]: # The user dict or None if not found
    """Get user by username.
    """
    users = db[table_name]
    results = users(where="username = ?", where_args=[username])
    return results[0] if results else None

# %% ../nbs/00_auth.ipynb 23
def update_user(db: Database,                          # The FastHTML Database instance
                user_id: int,                          # The user ID
                table_name: str = 'user',              # The table name
                **kwargs) -> Optional[Dict[str, Any]]: # The updated user dict or None if not found
    """Update user attributes.
    """
    users = db[table_name]
    
    # Get existing user
    try:
        user = users[user_id]
        if not user:
            return None
    except NotFoundError:
        return None
    
    # Update timestamp
    kwargs['updated_at'] = datetime.utcnow()
    
    # If password is being updated, hash it
    if 'password' in kwargs:
        kwargs['password_hash'] = hash_password(kwargs.pop('password'))
    
    # Update using MiniDataAPI - fastlite expects the record as first arg, then kwargs
    updated_user = dict(user)  # Make a copy
    updated_user.update(kwargs)  # Apply updates
    return users.update(updated_user)

# %% ../nbs/00_auth.ipynb 24
def delete_user(db: Database,            # The FastHTML Database instance
                user_id: int,            # The user ID
                table_name: str = 'user' # The table name
                ) -> bool:               # True if deleted, False if not found
    """Delete a user from the database.
    """
    users = db[table_name]
    
    # Check if user exists
    try:
        user = users[user_id]
        if not user:
            return False
    except NotFoundError:
        return False
    
    # Delete using MiniDataAPI
    users.delete(user_id)
    return True

# %% ../nbs/00_auth.ipynb 26
def check_permission(user: User,        # The User object to check
                     required_role: str # The required role
                     ) -> bool:         # True if user has permission, False otherwise
    """Check if a user has the required role or higher.
    
    Role hierarchy:
    - 'admin' has all permissions
    - 'user' has basic permissions
    - Custom roles can be added as needed
    """
    # Define role hierarchy (higher number = more permissions)
    role_hierarchy = {
        'user': 1,
        'admin': 2
    }
    
    # Get user's role level (default to 0 if role not found)
    user_role_level = role_hierarchy.get(user.role, 0)
    
    # Get required role level (default to highest if not found)
    required_role_level = role_hierarchy.get(required_role, float('inf'))
    
    # User has permission if their role level is >= required level
    return user_role_level >= required_role_level

# %% ../nbs/00_auth.ipynb 28
def authenticate_user(db: Database,                  # The FastHTML Database instance
                      username_or_email: str,        # The username or email address
                      password: str,                 # The plain text password
                      table_name: str = 'user'       # The table name
                      ) -> Optional[Dict[str, Any]]: # The authenticated user dict or None if invalid credentials
    """Authenticate a user by username/email and password.
    """
    # Try to find user by email first, then username
    user = get_user_by_email(db, username_or_email, table_name)
    if not user:
        user = get_user_by_username(db, username_or_email, table_name)
    
    # Verify password if user found
    if user and verify_password(password, user['password_hash']):
        return user
    
    return None

# %% ../nbs/00_auth.ipynb 29
@dataclass
class UserLogin:
    """Login tracking record for security and analytics."""
    user_id: int
    ip_address: Optional[str] = None
    user_agent: Optional[str] = None
    login_time: datetime = field(default_factory=datetime.utcnow)
    id: Optional[int] = None

#| export
def track_login(db: Database, # The FastHTML Database instance
                user_id: int, # The user ID
                ip_address: Optional[str] = None, # The IP address of the login
                user_agent: Optional[str] = None, # The user agent string
                table_name: str = 'user_logins' # The table name
                ) -> Dict[str, Any]: # The login record
    """Track user login for security and analytics using MiniDataAPI pattern.
    
    Creates a login record with timestamp and metadata. Returns the created login record.
    """
    # Create or get the logins table using MiniDataAPI
    logins = db.create(UserLogin, pk='id', name=table_name)
    
    # Create login record
    login_data = UserLogin(
        user_id=user_id,
        ip_address=ip_address,
        user_agent=user_agent
    )
    
    # Insert using MiniDataAPI
    result = logins.insert(login_data)
    
    # Convert to dict if needed for consistency
    if hasattr(result, '__dict__'):
        return vars(result)
    return result

# %% ../nbs/00_auth.ipynb 32
def is_username_available(db: Database, # The FastHTML Database instance
                          username: str, # The username to check
                          table_name: str = 'user' # The table name
                          ) -> bool: # True if username is available, False if taken
    """Check if username is available for registration.
    """
    return get_user_by_username(db, username, table_name) is None

# %% ../nbs/00_auth.ipynb 33
def is_email_available(db: Database, # The FastHTML Database instance
                       email: str, # The email address to check
                       table_name: str = 'user' # The table name
                       ) -> bool: # True if email is available, False if taken
    """Check if email is available for registration.
    """
    return get_user_by_email(db, email, table_name) is None

# %% ../nbs/00_auth.ipynb 34
def validate_user_data(username: str, # The username to validate
                       email: str, # The email address to validate
                       password: str # The password to validate
                       ) -> List[str]: # The list of validation errors (empty if valid)
    """Validate user registration data.
    """
    errors = []
    
    # Username validation
    if not username or len(username) < 3:
        errors.append("Username must be at least 3 characters long")
    elif not username.replace('_', '').replace('-', '').isalnum():
        errors.append("Username can only contain letters, numbers, underscores, and hyphens")
    
    # Email validation (basic)
    if not email or '@' not in email:
        errors.append("Invalid email address")
    else:
        parts = email.split('@')
        if len(parts) != 2 or not parts[0] or not parts[1] or '.' not in parts[1]:
            errors.append("Invalid email address")
    
    # Password validation
    if not password or len(password) < 8:
        errors.append("Password must be at least 8 characters long")
    
    return errors

# %% ../nbs/00_auth.ipynb 37
def user_auth_before(req, # The FastHTML Request object
                     sess, # The FastHTML Session object
                     login_path='/login' # The login path
                     ): # None or RedirectResponse if not authenticated
    """Beforeware function to check authentication status.
    
    Following FastHTML's standard authentication pattern:
    - Sets req.scope['auth'] for automatic injection in route handlers
    - Returns None if authenticated (continue processing)
    - Returns RedirectResponse if not authenticated
    """
    from fasthtml.common import RedirectResponse
    auth = sess.get('auth', None)
    req.scope['auth'] = auth
    if not auth: 
        return RedirectResponse(login_path, status_code=303)

# %% ../nbs/00_auth.ipynb 39
def get_user_from_session(sess                           # The FastHTML Session object
                          ) -> Optional[Dict[str, Any]]: # The user data dict or None if not authenticated
    """Extract user data dictionary from session.
    """
    if sess.get('auth') and 'user' in sess:
        return sess['user']
    return None

# %% ../nbs/00_auth.ipynb 44
def create_auth_token(user_id: int # The user ID
                      ) -> str:    # The authentication token
    """Create a secure authentication token for a user.
    """
    token = secrets.token_urlsafe(32)
    # In a real app, you'd store: token -> user_id mapping in database
    return f"{user_id}:{token}"

# %% ../nbs/00_auth.ipynb 46
def verify_auth_token(token: str # The authentication token
                      ) -> Optional[int]: # The user ID or None if invalid
    """Verify an authentication token and return the user ID.
    """
    try:
        # Simple parsing for demo - in production, look up in database
        parts = token.split(':', 1)
        if len(parts) == 2:
            user_id = int(parts[0])
            # In real app: verify token exists in DB and not expired
            return user_id
    except (ValueError, TypeError):
        pass
    return None
