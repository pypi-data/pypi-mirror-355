"""Simple, composable admin utilities following FastHTML patterns"""

# AUTOGENERATED! DO NOT EDIT! File to edit: ../nbs/03_admin.ipynb.

# %% auto 0
__all__ = ['setup_admin_routes', 'admin_list_view', 'admin_table', 'admin_form', 'get_field_input', 'clean_form_data']

# %% ../nbs/03_admin.ipynb 2
from typing import Optional, Dict, Any, List, Union, Callable, Set, Type
from dataclasses import dataclass, field, fields
from datetime import datetime, date
from fasthtml.common import *
from fastlite import *
from monsterui.all import *
from .permissions import require_role
from apswutils.db import NotFoundError
import math

# %% ../nbs/03_admin.ipynb 6
def setup_admin_routes(rt, # FastHTML router instance
                      name: str, # Model name (e.g., 'products')
                      table, # MiniDataAPI table
                      model_class: Type, # Dataclass model
                      path_prefix: str = '/admin', # URL prefix
                      auth_check: Optional[Callable] = None, # Auth function
                      per_page: int = 25 # Items per page
                      ):
    """Setup admin routes for a model using standard FastHTML patterns.
    
    This creates all CRUD routes following FastHTML conventions.
    """
    auth_check = auth_check or (lambda r, s: require_role('admin', r, s))
    base_path = f"{path_prefix}/{name}"
    
    # List view
    @rt(f"{base_path}/")
    def list_view(req, sess):
        if not auth_check(req, sess):
            return RedirectResponse('/login', status_code=303)
        
        # Get query params
        page = int(req.query_params.get('page', 1))
        search = req.query_params.get('search', '')
        
        # Simple pagination
        offset = (page - 1) * per_page
        
        # Query with search
        if search:
            # Simple search across string fields
            items = _search_items(table, model_class, search, per_page, offset)
        else:
            items = table(limit=per_page, offset=offset, order_by='id DESC')
        
        total = len(table())
        total_pages = math.ceil(total / per_page)
        
        return admin_list_view(name, items, page, total_pages, search, base_path)
    
    # Create form (GET)
    @rt(f"{base_path}/new")
    def create_form(req, sess):
        if not auth_check(req, sess):
            return RedirectResponse('/login', status_code=303)
        return admin_form(model_class, None, f"{base_path}/new", f"New {name.title()}")
    
    # Create handler (POST)
    @rt(f"{base_path}/new")
    async def create_handler(req, sess):
        if not auth_check(req, sess):
            return RedirectResponse('/login', status_code=303)
        
        form_data = await req.form()
        try:
            cleaned = clean_form_data(model_class, dict(form_data))
            instance = model_class(**cleaned)
            table.insert(instance)
            return RedirectResponse(f"{base_path}/", status_code=303)
        except Exception as e:
            return admin_form(model_class, dict(form_data), f"{base_path}/new", 
                            f"New {name.title()}", error=str(e))
    
    # Edit form (GET)
    @rt(f"{base_path}/{{id}}/edit")
    def edit_form(req, sess, id: int):
        if not auth_check(req, sess):
            return RedirectResponse('/login', status_code=303)
        
        try:
            item = table[id]
            item_dict = vars(item) if hasattr(item, '__dict__') else item
            return admin_form(model_class, item_dict, f"{base_path}/{id}/edit", 
                            f"Edit {name.title()}")
        except NotFoundError:
            return HTMLResponse("Item not found", status_code=404)
    
    # Edit handler (POST)
    @rt(f"{base_path}/{{id}}/edit")
    async def edit_handler(req, sess, id: int):
        if not auth_check(req, sess):
            return RedirectResponse('/login', status_code=303)
        
        form_data = await req.form()
        try:
            item = table[id]
            item_dict = vars(item) if hasattr(item, '__dict__') else item
            
            cleaned = clean_form_data(model_class, dict(form_data))
            updated = {**item_dict, **cleaned}
            
            if 'updated_at' in model_class.__dataclass_fields__:
                updated['updated_at'] = datetime.utcnow()
            
            table.update(updated)
            return RedirectResponse(f"{base_path}/", status_code=303)
        except Exception as e:
            return admin_form(model_class, dict(form_data), f"{base_path}/{id}/edit", 
                            f"Edit {name.title()}", error=str(e))
    
    # Delete handler (POST)
    @rt(f"{base_path}/{{id}}/delete")
    def delete_handler(req, sess, id: int):
        if not auth_check(req, sess):
            return RedirectResponse('/login', status_code=303)
        
        try:
            table.delete(id)
            if req.headers.get('HX-Request'):
                return ""
        except NotFoundError:
            pass
        
        return RedirectResponse(f"{base_path}/", status_code=303)

# %% ../nbs/03_admin.ipynb 7
def admin_list_view(name: str, # Model name
                   items: List, # List of items
                   page: int, # Current page
                   total_pages: int, # Total pages
                   search: str = '', # Search query
                   base_path: str = '' # Base URL path
                   ) -> FT:
    """Generate admin list view with table and pagination.
    
    Simple, reusable component following FastHTML patterns.
    """
    return Container(
        # Header with title and new button
        Div(
            H1(f"{name.title()} List", cls="text-3xl font-bold"),
            A(f"+ New {name.title()}", href=f"{base_path}/new", 
              cls="btn btn-primary"),
            cls="flex justify-between items-center mb-6"
        ),
        
        # Search form
        Form(
            Input(name="search", value=search, placeholder="Search...", cls="mr-2"),
            Button("Search", type="submit"),
            method="get",
            cls="mb-4"
        ),
        
        # Table
        admin_table(items, base_path),
        
        # Pagination
        _pagination(page, total_pages, base_path, search)
    )

# %% ../nbs/03_admin.ipynb 8
def admin_table(items: List, # List of items to display
               base_path: str = '' # Base URL path for actions
               ) -> FT:
    """Generate admin table component.
    
    Simple table component that works with any list of dict-like objects.
    """
    if not items:
        return Card(P("No items found", cls="text-center py-8"))
    
    # Get first item to determine columns
    first_item = items[0]
    if hasattr(first_item, '__dict__'):
        first_dict = vars(first_item)
    else:
        first_dict = first_item
    
    # Column names (exclude id from display)
    columns = [k for k in first_dict.keys() if k != 'id']
    
    # Headers
    headers = [Th(col.replace('_', ' ').title()) for col in columns]
    headers.append(Th("Actions", cls="text-right"))
    
    # Rows
    rows = []
    for item in items:
        item_dict = vars(item) if hasattr(item, '__dict__') else item
        
        # Data cells
        cells = []
        for col in columns:
            value = item_dict.get(col, '')
            # Format common types
            if isinstance(value, bool):
                value = "✓" if value else "✗"
            elif isinstance(value, datetime):
                value = value.strftime('%Y-%m-%d %H:%M')
            cells.append(Td(str(value)))
        
        # Action buttons
        actions = Td(
            A("Edit", href=f"{base_path}/{item_dict['id']}/edit",
              cls="text-primary hover:underline mr-3"),
            Button("Delete", 
                   hx_post=f"{base_path}/{item_dict['id']}/delete",
                   hx_confirm="Are you sure?",
                   hx_target="closest tr",
                   hx_swap="outerHTML",
                   cls="text-destructive hover:underline"),
            cls="text-right"
        )
        cells.append(actions)
        
        rows.append(Tr(*cells))
    
    return Card(
        Table(
            Thead(Tr(*headers)),
            Tbody(*rows),
            cls="w-full"
        )
    )

# %% ../nbs/03_admin.ipynb 9
def admin_form(model_class: Type, # Dataclass model
              data: Optional[Dict] = None, # Current data (for editing)
              action: str = '', # Form action URL
              title: str = 'Form', # Form title
              error: Optional[str] = None # Error message
              ) -> FT:
    """Generate admin form from dataclass.
    
    Simple form generator that creates appropriate inputs for each field type.
    """
    data = data or {}
    
    # Generate form fields
    form_fields = []
    for field in fields(model_class):
        if field.name == 'id':  # Skip primary key
            continue
        
        value = data.get(field.name, field.default if field.default != field.default_factory else '')
        input_component = get_field_input(field.name, field.type, value)
        form_fields.append(input_component)
    
    return Container(
        H1(title, cls="text-3xl font-bold mb-6"),
        Card(
            Form(
                Alert(error, variant="destructive", cls="mb-4") if error else None,
                *form_fields,
                Div(
                    Button("Save", type="submit", cls="btn btn-primary mr-2"),
                    A("Cancel", href="javascript:history.back()", 
                      cls="btn btn-outline"),
                    cls="mt-4"
                ),
                method="post",
                action=action,
                cls="space-y-4"
            ),
            cls="max-w-2xl"
        )
    )

# %% ../nbs/03_admin.ipynb 10
def get_field_input(name: str, # Field name
                   field_type: Type, # Field type
                   value: Any = '' # Current value
                   ) -> FT:
    """Get appropriate input component for field type.
    
    Simple function that maps Python types to HTML input types.
    """
    label = name.replace('_', ' ').title()
    
    # Handle Optional types
    if hasattr(field_type, '__origin__') and field_type.__origin__ is Union:
        args = field_type.__args__
        field_type = next((t for t in args if t != type(None)), str)
    
    # Boolean -> Checkbox
    if field_type is bool:
        return Div(
            Label(
                Input(type="checkbox", name=name, value="true", checked=bool(value)),
                label,
                cls="flex items-center space-x-2"
            )
        )
    
    # Numbers
    elif field_type in (int, float):
        return LabelInput(label, name=name, type="number", 
                         value=str(value) if value is not None else '',
                         step="0.01" if field_type is float else "1")
    
    # Date/DateTime
    elif field_type is datetime:
        if isinstance(value, datetime):
            value = value.strftime('%Y-%m-%dT%H:%M')
        return LabelInput(label, name=name, type="datetime-local", value=value or '')
    
    elif field_type is date:
        if isinstance(value, date):
            value = value.strftime('%Y-%m-%d')
        return LabelInput(label, name=name, type="date", value=value or '')
    
    # Large text fields
    elif any(word in name.lower() for word in ['description', 'content', 'body', 'notes']):
        return Div(
            Label(label, htmlFor=name),
            Textarea(value or '', name=name, id=name, rows=4, cls="textarea")
        )
    
    # Default to text input
    else:
        return LabelInput(label, name=name, type="text", value=value or '')

# %% ../nbs/03_admin.ipynb 11
def clean_form_data(model_class: Type, # Dataclass model
                   form_data: Dict # Raw form data
                   ) -> Dict:
    """Clean and convert form data to appropriate types.
    
    Simple type conversion from HTML form strings to Python types.
    """
    cleaned = {}
    
    for field in fields(model_class):
        if field.name == 'id':  # Skip primary key
            continue
            
        value = form_data.get(field.name)
        
        # Handle empty strings
        if value == '':
            if field.default != field.default_factory:
                value = field.default
            else:
                value = None
        
        # Type conversion
        if value is not None and value != '':
            field_type = field.type
            
            # Handle Optional types
            if hasattr(field_type, '__origin__') and field_type.__origin__ is Union:
                args = field_type.__args__
                field_type = next((t for t in args if t != type(None)), str)
            
            # Convert based on type
            if field_type is bool:
                value = value in ('true', 'on', '1', True)
            elif field_type is int:
                value = int(value)
            elif field_type is float:
                value = float(value)
            elif field_type is datetime:
                value = datetime.fromisoformat(value)
            elif field_type is date:
                value = datetime.strptime(value, '%Y-%m-%d').date()
        
        # Only include non-None values or required fields
        if value is not None or field.default == field.default_factory:
            cleaned[field.name] = value
    
    return cleaned

# %% ../nbs/03_admin.ipynb 13
def _search_items(table, model_class: Type, search: str, limit: int, offset: int):
    """Simple search across string fields."""
    # Get string fields from dataclass
    string_fields = [f.name for f in fields(model_class) 
                    if f.type is str and f.name != 'id']
    
    if not string_fields:
        return table(limit=limit, offset=offset)
    
    # Build search query
    search_conditions = ' OR '.join([f"{field} LIKE ?" for field in string_fields])
    search_args = [f"%{search}%" for _ in string_fields]
    
    return table(
        where=search_conditions,
        where_args=search_args,
        limit=limit,
        offset=offset,
        order_by='id DESC'
    )

def _pagination(page: int, total_pages: int, base_path: str, search: str = '') -> FT:
    """Simple pagination component."""
    if total_pages <= 1:
        return Div()
    
    links = []
    
    # Previous
    if page > 1:
        prev_query = f"?page={page-1}&search={search}" if search else f"?page={page-1}"
        links.append(A("← Previous", href=f"{base_path}/{prev_query}", cls="btn btn-outline mr-2"))
    
    # Pages
    for p in range(max(1, page-2), min(total_pages+1, page+3)):
        if p == page:
            links.append(Span(str(p), cls="btn btn-primary mr-2"))
        else:
            page_query = f"?page={p}&search={search}" if search else f"?page={p}"
            links.append(A(str(p), href=f"{base_path}/{page_query}", cls="btn btn-outline mr-2"))
    
    # Next
    if page < total_pages:
        next_query = f"?page={page+1}&search={search}" if search else f"?page={page+1}"
        links.append(A("Next →", href=f"{base_path}/{next_query}", cls="btn btn-outline"))
    
    return Div(*links, cls="mt-4 flex items-center")
