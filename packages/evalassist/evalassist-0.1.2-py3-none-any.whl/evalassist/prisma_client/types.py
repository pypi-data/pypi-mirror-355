# -*- coding: utf-8 -*-
# code generated by Prisma. DO NOT EDIT.
# pyright: reportUnusedImport=false
# fmt: off

# global imports for type checking
from builtins import bool as _bool
from builtins import int as _int
from builtins import float as _float
from builtins import str as _str
import sys
import decimal
import datetime
from typing import (
    TYPE_CHECKING,
    Optional,
    Iterable,
    Iterator,
    Sequence,
    Callable,
    ClassVar,
    NoReturn,
    TypeVar,
    Generic,
    Mapping,
    Tuple,
    Union,
    List,
    Dict,
    Type,
    Any,
    Set,
    overload,
    cast,
)
from typing_extensions import TypedDict, Literal


LiteralString = str
# -- template types.py.jinja --
from typing import TypeVar

import httpx
from . import _types
from .utils import _NoneType



# TODO: filters with aggregates should have their own recursive fields
# TODO: cleanup whitespace control
# TODO: add an argument to signify that the last iteration should be skipped


SortMode = _types.SortMode
SortOrder = _types.SortOrder

MetricsFormat = _types.MetricsFormat

DatasourceOverride = _types.DatasourceOverride
HttpConfig = _types.HttpConfig


# types that can be serialized to json by our query builder
Serializable = Union[
    None,
    bool,
    float,
    int,
    str,
    datetime.datetime,
    List[Any],
    Dict[None, Any],
    Dict[bool, Any],
    Dict[float, Any],
    Dict[int, Any],
    Dict[str, Any],
]


    

StringFilter = TypedDict(
    'StringFilter',
    {
        'equals': str,
        'not_in': List[str],
        'lt': str,
        'lte': str,
        'gt': str,
        'gte': str,
        'contains': str,
        'startswith': str,
        'endswith': str,
        'in': List[str],
        'not': Union[str, 'StringFilterRecursive1'],
                    },
    total=False,
)


StringFilterRecursive1 = TypedDict(
    'StringFilterRecursive1',
    {
        'equals': str,
        'not_in': List[str],
        'lt': str,
        'lte': str,
        'gt': str,
        'gte': str,
        'contains': str,
        'startswith': str,
        'endswith': str,
        'in': List[str],
        'not': Union[str, 'StringFilterRecursive2'],
                    },
    total=False,
)


StringFilterRecursive2 = TypedDict(
    'StringFilterRecursive2',
    {
        'equals': str,
        'not_in': List[str],
        'lt': str,
        'lte': str,
        'gt': str,
        'gte': str,
        'contains': str,
        'startswith': str,
        'endswith': str,
        'in': List[str],
        'not': Union[str, 'StringFilterRecursive3'],
                    },
    total=False,
)


StringFilterRecursive3 = TypedDict(
    'StringFilterRecursive3',
    {
        'equals': str,
        'not_in': List[str],
        'lt': str,
        'lte': str,
        'gt': str,
        'gte': str,
        'contains': str,
        'startswith': str,
        'endswith': str,
        'in': List[str],
        'not': Union[str, 'StringFilterRecursive4'],
                    },
    total=False,
)


StringFilterRecursive4 = TypedDict(
    'StringFilterRecursive4',
    {
        'equals': str,
        'not_in': List[str],
        'lt': str,
        'lte': str,
        'gt': str,
        'gte': str,
        'contains': str,
        'startswith': str,
        'endswith': str,
        'in': List[str],
                            },
    total=False,
)


class StringWithAggregatesFilter(StringFilter, total=False):
    _max: 'StringFilter'
    _min: 'StringFilter'
    _sum: 'StringFilter'
    _avg: 'StringFilter'
    _count: 'IntFilter'


    

DateTimeFilter = TypedDict(
    'DateTimeFilter',
    {
        'equals': datetime.datetime,
        'not_in': List[datetime.datetime],
        'lt': datetime.datetime,
        'lte': datetime.datetime,
        'gt': datetime.datetime,
        'gte': datetime.datetime,
        'in': List[datetime.datetime],
        'not': Union[datetime.datetime, 'DateTimeFilterRecursive1'],
    },
    total=False,
)


DateTimeFilterRecursive1 = TypedDict(
    'DateTimeFilterRecursive1',
    {
        'equals': datetime.datetime,
        'not_in': List[datetime.datetime],
        'lt': datetime.datetime,
        'lte': datetime.datetime,
        'gt': datetime.datetime,
        'gte': datetime.datetime,
        'in': List[datetime.datetime],
        'not': Union[datetime.datetime, 'DateTimeFilterRecursive2'],
    },
    total=False,
)


DateTimeFilterRecursive2 = TypedDict(
    'DateTimeFilterRecursive2',
    {
        'equals': datetime.datetime,
        'not_in': List[datetime.datetime],
        'lt': datetime.datetime,
        'lte': datetime.datetime,
        'gt': datetime.datetime,
        'gte': datetime.datetime,
        'in': List[datetime.datetime],
        'not': Union[datetime.datetime, 'DateTimeFilterRecursive3'],
    },
    total=False,
)


DateTimeFilterRecursive3 = TypedDict(
    'DateTimeFilterRecursive3',
    {
        'equals': datetime.datetime,
        'not_in': List[datetime.datetime],
        'lt': datetime.datetime,
        'lte': datetime.datetime,
        'gt': datetime.datetime,
        'gte': datetime.datetime,
        'in': List[datetime.datetime],
        'not': Union[datetime.datetime, 'DateTimeFilterRecursive4'],
    },
    total=False,
)


DateTimeFilterRecursive4 = TypedDict(
    'DateTimeFilterRecursive4',
    {
        'equals': datetime.datetime,
        'not_in': List[datetime.datetime],
        'lt': datetime.datetime,
        'lte': datetime.datetime,
        'gt': datetime.datetime,
        'gte': datetime.datetime,
        'in': List[datetime.datetime],
            },
    total=False,
)


class DateTimeWithAggregatesFilter(DateTimeFilter, total=False):
    _max: 'DateTimeFilter'
    _min: 'DateTimeFilter'
    _sum: 'DateTimeFilter'
    _avg: 'DateTimeFilter'
    _count: 'IntFilter'


    

BooleanFilter = TypedDict(
    'BooleanFilter',
    {
        'equals': bool,
        'not': Union[bool, 'BooleanFilterRecursive1'],
    },
    total=False,
)


BooleanFilterRecursive1 = TypedDict(
    'BooleanFilterRecursive1',
    {
        'equals': bool,
        'not': Union[bool, 'BooleanFilterRecursive2'],
    },
    total=False,
)


BooleanFilterRecursive2 = TypedDict(
    'BooleanFilterRecursive2',
    {
        'equals': bool,
        'not': Union[bool, 'BooleanFilterRecursive3'],
    },
    total=False,
)


BooleanFilterRecursive3 = TypedDict(
    'BooleanFilterRecursive3',
    {
        'equals': bool,
        'not': Union[bool, 'BooleanFilterRecursive4'],
    },
    total=False,
)


BooleanFilterRecursive4 = TypedDict(
    'BooleanFilterRecursive4',
    {
        'equals': bool,
            },
    total=False,
)


class BooleanWithAggregatesFilter(BooleanFilter, total=False):
    _max: 'BooleanFilter'
    _min: 'BooleanFilter'
    _sum: 'BooleanFilter'
    _avg: 'BooleanFilter'
    _count: 'IntFilter'


    

IntFilter = TypedDict(
    'IntFilter',
    {
        'equals': int,
        'not_in': List[int],
        'lt': int,
        'lte': int,
        'gt': int,
        'gte': int,
        'in': List[int],
        'not': Union[int, 'IntFilterRecursive1'],
    },
    total=False,
)


IntFilterRecursive1 = TypedDict(
    'IntFilterRecursive1',
    {
        'equals': int,
        'not_in': List[int],
        'lt': int,
        'lte': int,
        'gt': int,
        'gte': int,
        'in': List[int],
        'not': Union[int, 'IntFilterRecursive2'],
    },
    total=False,
)


IntFilterRecursive2 = TypedDict(
    'IntFilterRecursive2',
    {
        'equals': int,
        'not_in': List[int],
        'lt': int,
        'lte': int,
        'gt': int,
        'gte': int,
        'in': List[int],
        'not': Union[int, 'IntFilterRecursive3'],
    },
    total=False,
)


IntFilterRecursive3 = TypedDict(
    'IntFilterRecursive3',
    {
        'equals': int,
        'not_in': List[int],
        'lt': int,
        'lte': int,
        'gt': int,
        'gte': int,
        'in': List[int],
        'not': Union[int, 'IntFilterRecursive4'],
    },
    total=False,
)


IntFilterRecursive4 = TypedDict(
    'IntFilterRecursive4',
    {
        'equals': int,
        'not_in': List[int],
        'lt': int,
        'lte': int,
        'gt': int,
        'gte': int,
        'in': List[int],
            },
    total=False,
)


class IntWithAggregatesFilter(IntFilter, total=False):
    _max: 'IntFilter'
    _min: 'IntFilter'
    _sum: 'IntFilter'
    _avg: 'IntFilter'
    _count: 'IntFilter'


BigIntFilter = IntFilter
BigIntWithAggregatesFilter = IntWithAggregatesFilter
    

FloatFilter = TypedDict(
    'FloatFilter',
    {
        'equals': float,
        'not_in': List[float],
        'lt': float,
        'lte': float,
        'gt': float,
        'gte': float,
        'in': List[float],
        'not': Union[float, 'FloatFilterRecursive1'],
    },
    total=False,
)


FloatFilterRecursive1 = TypedDict(
    'FloatFilterRecursive1',
    {
        'equals': float,
        'not_in': List[float],
        'lt': float,
        'lte': float,
        'gt': float,
        'gte': float,
        'in': List[float],
        'not': Union[float, 'FloatFilterRecursive2'],
    },
    total=False,
)


FloatFilterRecursive2 = TypedDict(
    'FloatFilterRecursive2',
    {
        'equals': float,
        'not_in': List[float],
        'lt': float,
        'lte': float,
        'gt': float,
        'gte': float,
        'in': List[float],
        'not': Union[float, 'FloatFilterRecursive3'],
    },
    total=False,
)


FloatFilterRecursive3 = TypedDict(
    'FloatFilterRecursive3',
    {
        'equals': float,
        'not_in': List[float],
        'lt': float,
        'lte': float,
        'gt': float,
        'gte': float,
        'in': List[float],
        'not': Union[float, 'FloatFilterRecursive4'],
    },
    total=False,
)


FloatFilterRecursive4 = TypedDict(
    'FloatFilterRecursive4',
    {
        'equals': float,
        'not_in': List[float],
        'lt': float,
        'lte': float,
        'gt': float,
        'gte': float,
        'in': List[float],
            },
    total=False,
)


class FloatWithAggregatesFilter(FloatFilter, total=False):
    _max: 'FloatFilter'
    _min: 'FloatFilter'
    _sum: 'FloatFilter'
    _avg: 'FloatFilter'
    _count: 'IntFilter'


    

BytesFilter = TypedDict(
    'BytesFilter',
    {
        'equals': 'fields.Base64',
        'in': List['fields.Base64'],
        'not_in': List['fields.Base64'],
        'not': Union['fields.Base64', 'BytesFilterRecursive1'],
    },
    total=False,
)


BytesFilterRecursive1 = TypedDict(
    'BytesFilterRecursive1',
    {
        'equals': 'fields.Base64',
        'in': List['fields.Base64'],
        'not_in': List['fields.Base64'],
        'not': Union['fields.Base64', 'BytesFilterRecursive2'],
    },
    total=False,
)


BytesFilterRecursive2 = TypedDict(
    'BytesFilterRecursive2',
    {
        'equals': 'fields.Base64',
        'in': List['fields.Base64'],
        'not_in': List['fields.Base64'],
        'not': Union['fields.Base64', 'BytesFilterRecursive3'],
    },
    total=False,
)


BytesFilterRecursive3 = TypedDict(
    'BytesFilterRecursive3',
    {
        'equals': 'fields.Base64',
        'in': List['fields.Base64'],
        'not_in': List['fields.Base64'],
        'not': Union['fields.Base64', 'BytesFilterRecursive4'],
    },
    total=False,
)


BytesFilterRecursive4 = TypedDict(
    'BytesFilterRecursive4',
    {
        'equals': 'fields.Base64',
        'in': List['fields.Base64'],
        'not_in': List['fields.Base64'],
            },
    total=False,
)


class BytesWithAggregatesFilter(BytesFilter, total=False):
    _max: 'BytesFilter'
    _min: 'BytesFilter'
    _sum: 'BytesFilter'
    _avg: 'BytesFilter'
    _count: 'IntFilter'


# TODO: preview feature for improving JSON filtering
JsonFilter = TypedDict(
    'JsonFilter',
    {
        'equals': 'fields.Json',
        'not': 'fields.Json',
    },
    total=False,
)


class JsonWithAggregatesFilter(JsonFilter, total=False):
    _max: 'JsonFilter'
    _min: 'JsonFilter'
    _sum: 'JsonFilter'
    _avg: 'JsonFilter'
    _count: 'IntFilter'


    

DecimalFilter = TypedDict(
    'DecimalFilter',
    {
        'equals': decimal.Decimal,
        'not_in': List[decimal.Decimal],
        'lt': decimal.Decimal,
        'lte': decimal.Decimal,
        'gt': decimal.Decimal,
        'gte': decimal.Decimal,
        'in': List[decimal.Decimal],
        'not': Union[decimal.Decimal, 'DecimalFilterRecursive1'],
    },
    total=False,
)


DecimalFilterRecursive1 = TypedDict(
    'DecimalFilterRecursive1',
    {
        'equals': decimal.Decimal,
        'not_in': List[decimal.Decimal],
        'lt': decimal.Decimal,
        'lte': decimal.Decimal,
        'gt': decimal.Decimal,
        'gte': decimal.Decimal,
        'in': List[decimal.Decimal],
        'not': Union[decimal.Decimal, 'DecimalFilterRecursive2'],
    },
    total=False,
)


DecimalFilterRecursive2 = TypedDict(
    'DecimalFilterRecursive2',
    {
        'equals': decimal.Decimal,
        'not_in': List[decimal.Decimal],
        'lt': decimal.Decimal,
        'lte': decimal.Decimal,
        'gt': decimal.Decimal,
        'gte': decimal.Decimal,
        'in': List[decimal.Decimal],
        'not': Union[decimal.Decimal, 'DecimalFilterRecursive3'],
    },
    total=False,
)


DecimalFilterRecursive3 = TypedDict(
    'DecimalFilterRecursive3',
    {
        'equals': decimal.Decimal,
        'not_in': List[decimal.Decimal],
        'lt': decimal.Decimal,
        'lte': decimal.Decimal,
        'gt': decimal.Decimal,
        'gte': decimal.Decimal,
        'in': List[decimal.Decimal],
        'not': Union[decimal.Decimal, 'DecimalFilterRecursive4'],
    },
    total=False,
)


DecimalFilterRecursive4 = TypedDict(
    'DecimalFilterRecursive4',
    {
        'equals': decimal.Decimal,
        'not_in': List[decimal.Decimal],
        'lt': decimal.Decimal,
        'lte': decimal.Decimal,
        'gt': decimal.Decimal,
        'gte': decimal.Decimal,
        'in': List[decimal.Decimal],
            },
    total=False,
)


class DecimalWithAggregatesFilter(StringFilter, total=False):
    _max: 'DecimalFilter'
    _min: 'DecimalFilter'
    _sum: 'DecimalFilter'
    _avg: 'DecimalFilter'
    _count: 'IntFilter'


class _FloatSetInput(TypedDict):
    set: float


class _FloatDivideInput(TypedDict):
    divide: float


class _FloatMultiplyInput(TypedDict):
    multiply: float


class _FloatIncrementInput(TypedDict):
    increment: float


class _FloatDecrementInput(TypedDict):
    decrement: float


class _IntSetInput(TypedDict):
    set: int


class _IntDivideInput(TypedDict):
    divide: int


class _IntMultiplyInput(TypedDict):
    multiply: int


class _IntIncrementInput(TypedDict):
    increment: int


class _IntDecrementInput(TypedDict):
    decrement: int


AtomicFloatInput = Union[
    _FloatSetInput,
    _FloatDivideInput,
    _FloatMultiplyInput,
    _FloatIncrementInput,
    _FloatDecrementInput,
]
AtomicIntInput = Union[
    _IntSetInput,
    _IntDivideInput,
    _IntMultiplyInput,
    _IntIncrementInput,
    _IntDecrementInput,
]
AtomicBigIntInput = AtomicIntInput

class _StringListFilterEqualsInput(TypedDict):
    equals: Optional[List[_str]]


class _StringListFilterHasInput(TypedDict):
    has: _str


class _StringListFilterHasEveryInput(TypedDict):
    has_every: List[_str]


class _StringListFilterHasSomeInput(TypedDict):
    has_some: List[_str]


class _StringListFilterIsEmptyInput(TypedDict):
    is_empty: bool


StringListFilter = Union[
    _StringListFilterHasInput,
    _StringListFilterEqualsInput,
    _StringListFilterHasSomeInput,
    _StringListFilterIsEmptyInput,
    _StringListFilterHasEveryInput,
]


class _StringListUpdateSet(TypedDict):
    set: List[_str]


class _StringListUpdatePush(TypedDict):
    push: List[_str]


StringListUpdate = Union[
    List[_str],
    _StringListUpdateSet,
    _StringListUpdatePush,
]

class _BytesListFilterEqualsInput(TypedDict):
    equals: Optional[List['fields.Base64']]


class _BytesListFilterHasInput(TypedDict):
    has: 'fields.Base64'


class _BytesListFilterHasEveryInput(TypedDict):
    has_every: List['fields.Base64']


class _BytesListFilterHasSomeInput(TypedDict):
    has_some: List['fields.Base64']


class _BytesListFilterIsEmptyInput(TypedDict):
    is_empty: bool


BytesListFilter = Union[
    _BytesListFilterHasInput,
    _BytesListFilterEqualsInput,
    _BytesListFilterHasSomeInput,
    _BytesListFilterIsEmptyInput,
    _BytesListFilterHasEveryInput,
]


class _BytesListUpdateSet(TypedDict):
    set: List['fields.Base64']


class _BytesListUpdatePush(TypedDict):
    push: List['fields.Base64']


BytesListUpdate = Union[
    List['fields.Base64'],
    _BytesListUpdateSet,
    _BytesListUpdatePush,
]

class _DateTimeListFilterEqualsInput(TypedDict):
    equals: Optional[List[datetime.datetime]]


class _DateTimeListFilterHasInput(TypedDict):
    has: datetime.datetime


class _DateTimeListFilterHasEveryInput(TypedDict):
    has_every: List[datetime.datetime]


class _DateTimeListFilterHasSomeInput(TypedDict):
    has_some: List[datetime.datetime]


class _DateTimeListFilterIsEmptyInput(TypedDict):
    is_empty: bool


DateTimeListFilter = Union[
    _DateTimeListFilterHasInput,
    _DateTimeListFilterEqualsInput,
    _DateTimeListFilterHasSomeInput,
    _DateTimeListFilterIsEmptyInput,
    _DateTimeListFilterHasEveryInput,
]


class _DateTimeListUpdateSet(TypedDict):
    set: List[datetime.datetime]


class _DateTimeListUpdatePush(TypedDict):
    push: List[datetime.datetime]


DateTimeListUpdate = Union[
    List[datetime.datetime],
    _DateTimeListUpdateSet,
    _DateTimeListUpdatePush,
]

class _BooleanListFilterEqualsInput(TypedDict):
    equals: Optional[List[_bool]]


class _BooleanListFilterHasInput(TypedDict):
    has: _bool


class _BooleanListFilterHasEveryInput(TypedDict):
    has_every: List[_bool]


class _BooleanListFilterHasSomeInput(TypedDict):
    has_some: List[_bool]


class _BooleanListFilterIsEmptyInput(TypedDict):
    is_empty: bool


BooleanListFilter = Union[
    _BooleanListFilterHasInput,
    _BooleanListFilterEqualsInput,
    _BooleanListFilterHasSomeInput,
    _BooleanListFilterIsEmptyInput,
    _BooleanListFilterHasEveryInput,
]


class _BooleanListUpdateSet(TypedDict):
    set: List[_bool]


class _BooleanListUpdatePush(TypedDict):
    push: List[_bool]


BooleanListUpdate = Union[
    List[_bool],
    _BooleanListUpdateSet,
    _BooleanListUpdatePush,
]

class _IntListFilterEqualsInput(TypedDict):
    equals: Optional[List[_int]]


class _IntListFilterHasInput(TypedDict):
    has: _int


class _IntListFilterHasEveryInput(TypedDict):
    has_every: List[_int]


class _IntListFilterHasSomeInput(TypedDict):
    has_some: List[_int]


class _IntListFilterIsEmptyInput(TypedDict):
    is_empty: bool


IntListFilter = Union[
    _IntListFilterHasInput,
    _IntListFilterEqualsInput,
    _IntListFilterHasSomeInput,
    _IntListFilterIsEmptyInput,
    _IntListFilterHasEveryInput,
]


class _IntListUpdateSet(TypedDict):
    set: List[_int]


class _IntListUpdatePush(TypedDict):
    push: List[_int]


IntListUpdate = Union[
    List[_int],
    _IntListUpdateSet,
    _IntListUpdatePush,
]

class _BigIntListFilterEqualsInput(TypedDict):
    equals: Optional[List[_int]]


class _BigIntListFilterHasInput(TypedDict):
    has: _int


class _BigIntListFilterHasEveryInput(TypedDict):
    has_every: List[_int]


class _BigIntListFilterHasSomeInput(TypedDict):
    has_some: List[_int]


class _BigIntListFilterIsEmptyInput(TypedDict):
    is_empty: bool


BigIntListFilter = Union[
    _BigIntListFilterHasInput,
    _BigIntListFilterEqualsInput,
    _BigIntListFilterHasSomeInput,
    _BigIntListFilterIsEmptyInput,
    _BigIntListFilterHasEveryInput,
]


class _BigIntListUpdateSet(TypedDict):
    set: List[_int]


class _BigIntListUpdatePush(TypedDict):
    push: List[_int]


BigIntListUpdate = Union[
    List[_int],
    _BigIntListUpdateSet,
    _BigIntListUpdatePush,
]

class _FloatListFilterEqualsInput(TypedDict):
    equals: Optional[List[_float]]


class _FloatListFilterHasInput(TypedDict):
    has: _float


class _FloatListFilterHasEveryInput(TypedDict):
    has_every: List[_float]


class _FloatListFilterHasSomeInput(TypedDict):
    has_some: List[_float]


class _FloatListFilterIsEmptyInput(TypedDict):
    is_empty: bool


FloatListFilter = Union[
    _FloatListFilterHasInput,
    _FloatListFilterEqualsInput,
    _FloatListFilterHasSomeInput,
    _FloatListFilterIsEmptyInput,
    _FloatListFilterHasEveryInput,
]


class _FloatListUpdateSet(TypedDict):
    set: List[_float]


class _FloatListUpdatePush(TypedDict):
    push: List[_float]


FloatListUpdate = Union[
    List[_float],
    _FloatListUpdateSet,
    _FloatListUpdatePush,
]

class _JsonListFilterEqualsInput(TypedDict):
    equals: Optional[List['fields.Json']]


class _JsonListFilterHasInput(TypedDict):
    has: 'fields.Json'


class _JsonListFilterHasEveryInput(TypedDict):
    has_every: List['fields.Json']


class _JsonListFilterHasSomeInput(TypedDict):
    has_some: List['fields.Json']


class _JsonListFilterIsEmptyInput(TypedDict):
    is_empty: bool


JsonListFilter = Union[
    _JsonListFilterHasInput,
    _JsonListFilterEqualsInput,
    _JsonListFilterHasSomeInput,
    _JsonListFilterIsEmptyInput,
    _JsonListFilterHasEveryInput,
]


class _JsonListUpdateSet(TypedDict):
    set: List['fields.Json']


class _JsonListUpdatePush(TypedDict):
    push: List['fields.Json']


JsonListUpdate = Union[
    List['fields.Json'],
    _JsonListUpdateSet,
    _JsonListUpdatePush,
]

class _DecimalListFilterEqualsInput(TypedDict):
    equals: Optional[List[decimal.Decimal]]


class _DecimalListFilterHasInput(TypedDict):
    has: decimal.Decimal


class _DecimalListFilterHasEveryInput(TypedDict):
    has_every: List[decimal.Decimal]


class _DecimalListFilterHasSomeInput(TypedDict):
    has_some: List[decimal.Decimal]


class _DecimalListFilterIsEmptyInput(TypedDict):
    is_empty: bool


DecimalListFilter = Union[
    _DecimalListFilterHasInput,
    _DecimalListFilterEqualsInput,
    _DecimalListFilterHasSomeInput,
    _DecimalListFilterIsEmptyInput,
    _DecimalListFilterHasEveryInput,
]


class _DecimalListUpdateSet(TypedDict):
    set: List[decimal.Decimal]


class _DecimalListUpdatePush(TypedDict):
    push: List[decimal.Decimal]


DecimalListUpdate = Union[
    List[decimal.Decimal],
    _DecimalListUpdateSet,
    _DecimalListUpdatePush,
]


# StoredTestCase types

class StoredTestCaseOptionalCreateInput(TypedDict, total=False):
    """Optional arguments to the StoredTestCase create method"""
    id: _int
    user_id: _int
    app_user: 'AppUserCreateNestedWithoutRelationsInput'


class StoredTestCaseCreateInput(StoredTestCaseOptionalCreateInput):
    """Required arguments to the StoredTestCase create method"""
    content: _str
    name: _str


# TODO: remove this in favour of without explicit relations
# e.g. PostCreateWithoutAuthorInput

class StoredTestCaseOptionalCreateWithoutRelationsInput(TypedDict, total=False):
    """Optional arguments to the StoredTestCase create method, without relations"""
    id: _int
    user_id: _int


class StoredTestCaseCreateWithoutRelationsInput(StoredTestCaseOptionalCreateWithoutRelationsInput):
    """Required arguments to the StoredTestCase create method, without relations"""
    content: _str
    name: _str

class StoredTestCaseConnectOrCreateWithoutRelationsInput(TypedDict):
    create: 'StoredTestCaseCreateWithoutRelationsInput'
    where: 'StoredTestCaseWhereUniqueInput'

class StoredTestCaseCreateNestedWithoutRelationsInput(TypedDict, total=False):
    create: 'StoredTestCaseCreateWithoutRelationsInput'
    connect: 'StoredTestCaseWhereUniqueInput'
    connect_or_create: 'StoredTestCaseConnectOrCreateWithoutRelationsInput'


class StoredTestCaseCreateManyNestedWithoutRelationsInput(TypedDict, total=False):
    create: Union['StoredTestCaseCreateWithoutRelationsInput', List['StoredTestCaseCreateWithoutRelationsInput']]
    connect: Union['StoredTestCaseWhereUniqueInput', List['StoredTestCaseWhereUniqueInput']]
    connect_or_create: Union['StoredTestCaseConnectOrCreateWithoutRelationsInput', List['StoredTestCaseConnectOrCreateWithoutRelationsInput']]

_StoredTestCaseWhereUnique_id_Input = TypedDict(
    '_StoredTestCaseWhereUnique_id_Input',
    {
        'id': '_int',
    },
    total=True
)

_StoredTestCaseCompounduser_id_nameKeyInner = TypedDict(
    '_StoredTestCaseCompounduser_id_nameKeyInner',
    {
        'user_id': '_int',
        'name': '_str',
    },
    total=True
)

_StoredTestCaseCompounduser_id_nameKey = TypedDict(
    '_StoredTestCaseCompounduser_id_nameKey',
    {
        'user_id_name': '_StoredTestCaseCompounduser_id_nameKeyInner',
    },
    total=True
)

StoredTestCaseWhereUniqueInput = Union[
    '_StoredTestCaseWhereUnique_id_Input',
    '_StoredTestCaseCompounduser_id_nameKey',
]


class StoredTestCaseUpdateInput(TypedDict, total=False):
    """Optional arguments for updating a record"""
    id: Union[AtomicIntInput, _int]
    content: _str
    name: _str
    app_user: 'AppUserUpdateOneWithoutRelationsInput'


class StoredTestCaseUpdateManyMutationInput(TypedDict, total=False):
    """Arguments for updating many records"""
    id: Union[AtomicIntInput, _int]
    content: _str
    name: _str


class StoredTestCaseUpdateManyWithoutRelationsInput(TypedDict, total=False):
    create: List['StoredTestCaseCreateWithoutRelationsInput']
    connect: List['StoredTestCaseWhereUniqueInput']
    connect_or_create: List['StoredTestCaseConnectOrCreateWithoutRelationsInput']
    set: List['StoredTestCaseWhereUniqueInput']
    disconnect: List['StoredTestCaseWhereUniqueInput']
    delete: List['StoredTestCaseWhereUniqueInput']

    # TODO
    # update: List['StoredTestCaseUpdateWithWhereUniqueWithoutRelationsInput']
    # updateMany: List['StoredTestCaseUpdateManyWithWhereUniqueWithoutRelationsInput']
    # deleteMany: List['StoredTestCaseScalarWhereInput']
    # upsert: List['StoredTestCaseUpserteWithWhereUniqueWithoutRelationsInput']


class StoredTestCaseUpdateOneWithoutRelationsInput(TypedDict, total=False):
    create: 'StoredTestCaseCreateWithoutRelationsInput'
    connect: 'StoredTestCaseWhereUniqueInput'
    connect_or_create: 'StoredTestCaseConnectOrCreateWithoutRelationsInput'
    disconnect: bool
    delete: bool

    # TODO
    # update: 'StoredTestCaseUpdateInput'
    # upsert: 'StoredTestCaseUpsertWithoutRelationsInput'


class StoredTestCaseUpsertInput(TypedDict):
    create: 'StoredTestCaseCreateInput'
    update: 'StoredTestCaseUpdateInput'  # pyright: ignore[reportIncompatibleMethodOverride]


_StoredTestCase_id_OrderByInput = TypedDict(
    '_StoredTestCase_id_OrderByInput',
    {
        'id': 'SortOrder',
    },
    total=True
)

_StoredTestCase_user_id_OrderByInput = TypedDict(
    '_StoredTestCase_user_id_OrderByInput',
    {
        'user_id': 'SortOrder',
    },
    total=True
)

_StoredTestCase_content_OrderByInput = TypedDict(
    '_StoredTestCase_content_OrderByInput',
    {
        'content': 'SortOrder',
    },
    total=True
)

_StoredTestCase_name_OrderByInput = TypedDict(
    '_StoredTestCase_name_OrderByInput',
    {
        'name': 'SortOrder',
    },
    total=True
)

StoredTestCaseOrderByInput = Union[
    '_StoredTestCase_id_OrderByInput',
    '_StoredTestCase_user_id_OrderByInput',
    '_StoredTestCase_content_OrderByInput',
    '_StoredTestCase_name_OrderByInput',
]



# recursive StoredTestCase types
# TODO: cleanup these types


# Dict[str, Any] is a mypy limitation
# see https://github.com/RobertCraigie/prisma-client-py/issues/45
# switch to pyright for improved types, see https://prisma-client-py.readthedocs.io/en/stable/reference/limitations/

StoredTestCaseRelationFilter = TypedDict(
    'StoredTestCaseRelationFilter',
    {
        'is': 'Dict[str, Any]',
        'is_not': 'Dict[str, Any]',
    },
    total=False,
)


class StoredTestCaseListRelationFilter(TypedDict, total=False):
    some: 'Dict[str, Any]'
    none: 'Dict[str, Any]'
    every: 'Dict[str, Any]'


class StoredTestCaseInclude(TypedDict, total=False):
    """StoredTestCase relational arguments"""
    app_user: Union[bool, 'AppUserArgsFromStoredTestCase']


    

class StoredTestCaseIncludeFromStoredTestCase(TypedDict, total=False):
    """Relational arguments for StoredTestCase"""
    app_user: Union[bool, 'AppUserArgsFromStoredTestCaseRecursive1']


class StoredTestCaseIncludeFromStoredTestCaseRecursive1(TypedDict, total=False):
    """Relational arguments for StoredTestCase"""
    app_user: Union[bool, 'AppUserArgsFromStoredTestCaseRecursive2']


class StoredTestCaseIncludeFromStoredTestCaseRecursive2(TypedDict, total=False):
    """Relational arguments for StoredTestCase"""
    app_user: Union[bool, 'AppUserArgsFromStoredTestCaseRecursive3']


class StoredTestCaseIncludeFromStoredTestCaseRecursive3(TypedDict, total=False):
    """Relational arguments for StoredTestCase"""
    app_user: Union[bool, 'AppUserArgsFromStoredTestCaseRecursive4']


class StoredTestCaseIncludeFromStoredTestCaseRecursive4(TypedDict, total=False):
    """Relational arguments for StoredTestCase"""

    

class StoredTestCaseArgsFromStoredTestCase(TypedDict, total=False):
    """Arguments for StoredTestCase"""
    include: 'StoredTestCaseIncludeFromStoredTestCaseRecursive1'


class StoredTestCaseArgsFromStoredTestCaseRecursive1(TypedDict, total=False):
    """Arguments for StoredTestCase"""
    include: 'StoredTestCaseIncludeFromStoredTestCaseRecursive2'


class StoredTestCaseArgsFromStoredTestCaseRecursive2(TypedDict, total=False):
    """Arguments for StoredTestCase"""
    include: 'StoredTestCaseIncludeFromStoredTestCaseRecursive3'


class StoredTestCaseArgsFromStoredTestCaseRecursive3(TypedDict, total=False):
    """Arguments for StoredTestCase"""
    include: 'StoredTestCaseIncludeFromStoredTestCaseRecursive4'


class StoredTestCaseArgsFromStoredTestCaseRecursive4(TypedDict, total=False):
    """Arguments for StoredTestCase"""
    
    

class FindManyStoredTestCaseArgsFromStoredTestCase(TypedDict, total=False):
    """Arguments for StoredTestCase"""
    take: int
    skip: int
    order_by: Union['StoredTestCaseOrderByInput', List['StoredTestCaseOrderByInput']]
    where: 'StoredTestCaseWhereInput'
    cursor: 'StoredTestCaseWhereUniqueInput'
    distinct: List['StoredTestCaseScalarFieldKeys']
    include: 'StoredTestCaseIncludeFromStoredTestCaseRecursive1'


class FindManyStoredTestCaseArgsFromStoredTestCaseRecursive1(TypedDict, total=False):
    """Arguments for StoredTestCase"""
    take: int
    skip: int
    order_by: Union['StoredTestCaseOrderByInput', List['StoredTestCaseOrderByInput']]
    where: 'StoredTestCaseWhereInput'
    cursor: 'StoredTestCaseWhereUniqueInput'
    distinct: List['StoredTestCaseScalarFieldKeys']
    include: 'StoredTestCaseIncludeFromStoredTestCaseRecursive2'


class FindManyStoredTestCaseArgsFromStoredTestCaseRecursive2(TypedDict, total=False):
    """Arguments for StoredTestCase"""
    take: int
    skip: int
    order_by: Union['StoredTestCaseOrderByInput', List['StoredTestCaseOrderByInput']]
    where: 'StoredTestCaseWhereInput'
    cursor: 'StoredTestCaseWhereUniqueInput'
    distinct: List['StoredTestCaseScalarFieldKeys']
    include: 'StoredTestCaseIncludeFromStoredTestCaseRecursive3'


class FindManyStoredTestCaseArgsFromStoredTestCaseRecursive3(TypedDict, total=False):
    """Arguments for StoredTestCase"""
    take: int
    skip: int
    order_by: Union['StoredTestCaseOrderByInput', List['StoredTestCaseOrderByInput']]
    where: 'StoredTestCaseWhereInput'
    cursor: 'StoredTestCaseWhereUniqueInput'
    distinct: List['StoredTestCaseScalarFieldKeys']
    include: 'StoredTestCaseIncludeFromStoredTestCaseRecursive4'


class FindManyStoredTestCaseArgsFromStoredTestCaseRecursive4(TypedDict, total=False):
    """Arguments for StoredTestCase"""
    take: int
    skip: int
    order_by: Union['StoredTestCaseOrderByInput', List['StoredTestCaseOrderByInput']]
    where: 'StoredTestCaseWhereInput'
    cursor: 'StoredTestCaseWhereUniqueInput'
    distinct: List['StoredTestCaseScalarFieldKeys']
    
    

class AppUserIncludeFromStoredTestCase(TypedDict, total=False):
    """Relational arguments for StoredTestCase"""
    stored_test_cases: Union[bool, 'FindManyStoredTestCaseArgsFromStoredTestCaseRecursive1']


class AppUserIncludeFromStoredTestCaseRecursive1(TypedDict, total=False):
    """Relational arguments for StoredTestCase"""
    stored_test_cases: Union[bool, 'FindManyStoredTestCaseArgsFromStoredTestCaseRecursive2']


class AppUserIncludeFromStoredTestCaseRecursive2(TypedDict, total=False):
    """Relational arguments for StoredTestCase"""
    stored_test_cases: Union[bool, 'FindManyStoredTestCaseArgsFromStoredTestCaseRecursive3']


class AppUserIncludeFromStoredTestCaseRecursive3(TypedDict, total=False):
    """Relational arguments for StoredTestCase"""
    stored_test_cases: Union[bool, 'FindManyStoredTestCaseArgsFromStoredTestCaseRecursive4']


class AppUserIncludeFromStoredTestCaseRecursive4(TypedDict, total=False):
    """Relational arguments for StoredTestCase"""

    

class AppUserArgsFromStoredTestCase(TypedDict, total=False):
    """Arguments for StoredTestCase"""
    include: 'AppUserIncludeFromAppUserRecursive1'


class AppUserArgsFromStoredTestCaseRecursive1(TypedDict, total=False):
    """Arguments for StoredTestCase"""
    include: 'AppUserIncludeFromAppUserRecursive2'


class AppUserArgsFromStoredTestCaseRecursive2(TypedDict, total=False):
    """Arguments for StoredTestCase"""
    include: 'AppUserIncludeFromAppUserRecursive3'


class AppUserArgsFromStoredTestCaseRecursive3(TypedDict, total=False):
    """Arguments for StoredTestCase"""
    include: 'AppUserIncludeFromAppUserRecursive4'


class AppUserArgsFromStoredTestCaseRecursive4(TypedDict, total=False):
    """Arguments for StoredTestCase"""
    
    

class FindManyAppUserArgsFromStoredTestCase(TypedDict, total=False):
    """Arguments for StoredTestCase"""
    take: int
    skip: int
    order_by: Union['AppUserOrderByInput', List['AppUserOrderByInput']]
    where: 'AppUserWhereInput'
    cursor: 'AppUserWhereUniqueInput'
    distinct: List['AppUserScalarFieldKeys']
    include: 'AppUserIncludeFromAppUserRecursive1'


class FindManyAppUserArgsFromStoredTestCaseRecursive1(TypedDict, total=False):
    """Arguments for StoredTestCase"""
    take: int
    skip: int
    order_by: Union['AppUserOrderByInput', List['AppUserOrderByInput']]
    where: 'AppUserWhereInput'
    cursor: 'AppUserWhereUniqueInput'
    distinct: List['AppUserScalarFieldKeys']
    include: 'AppUserIncludeFromAppUserRecursive2'


class FindManyAppUserArgsFromStoredTestCaseRecursive2(TypedDict, total=False):
    """Arguments for StoredTestCase"""
    take: int
    skip: int
    order_by: Union['AppUserOrderByInput', List['AppUserOrderByInput']]
    where: 'AppUserWhereInput'
    cursor: 'AppUserWhereUniqueInput'
    distinct: List['AppUserScalarFieldKeys']
    include: 'AppUserIncludeFromAppUserRecursive3'


class FindManyAppUserArgsFromStoredTestCaseRecursive3(TypedDict, total=False):
    """Arguments for StoredTestCase"""
    take: int
    skip: int
    order_by: Union['AppUserOrderByInput', List['AppUserOrderByInput']]
    where: 'AppUserWhereInput'
    cursor: 'AppUserWhereUniqueInput'
    distinct: List['AppUserScalarFieldKeys']
    include: 'AppUserIncludeFromAppUserRecursive4'


class FindManyAppUserArgsFromStoredTestCaseRecursive4(TypedDict, total=False):
    """Arguments for StoredTestCase"""
    take: int
    skip: int
    order_by: Union['AppUserOrderByInput', List['AppUserOrderByInput']]
    where: 'AppUserWhereInput'
    cursor: 'AppUserWhereUniqueInput'
    distinct: List['AppUserScalarFieldKeys']
    
    

class LogRecordIncludeFromStoredTestCase(TypedDict, total=False):
    """Relational arguments for StoredTestCase"""


class LogRecordIncludeFromStoredTestCaseRecursive1(TypedDict, total=False):
    """Relational arguments for StoredTestCase"""


class LogRecordIncludeFromStoredTestCaseRecursive2(TypedDict, total=False):
    """Relational arguments for StoredTestCase"""


class LogRecordIncludeFromStoredTestCaseRecursive3(TypedDict, total=False):
    """Relational arguments for StoredTestCase"""


class LogRecordIncludeFromStoredTestCaseRecursive4(TypedDict, total=False):
    """Relational arguments for StoredTestCase"""

    

class LogRecordArgsFromStoredTestCase(TypedDict, total=False):
    """Arguments for StoredTestCase"""
    include: 'LogRecordIncludeFromLogRecordRecursive1'


class LogRecordArgsFromStoredTestCaseRecursive1(TypedDict, total=False):
    """Arguments for StoredTestCase"""
    include: 'LogRecordIncludeFromLogRecordRecursive2'


class LogRecordArgsFromStoredTestCaseRecursive2(TypedDict, total=False):
    """Arguments for StoredTestCase"""
    include: 'LogRecordIncludeFromLogRecordRecursive3'


class LogRecordArgsFromStoredTestCaseRecursive3(TypedDict, total=False):
    """Arguments for StoredTestCase"""
    include: 'LogRecordIncludeFromLogRecordRecursive4'


class LogRecordArgsFromStoredTestCaseRecursive4(TypedDict, total=False):
    """Arguments for StoredTestCase"""
    
    

class FindManyLogRecordArgsFromStoredTestCase(TypedDict, total=False):
    """Arguments for StoredTestCase"""
    take: int
    skip: int
    order_by: Union['LogRecordOrderByInput', List['LogRecordOrderByInput']]
    where: 'LogRecordWhereInput'
    cursor: 'LogRecordWhereUniqueInput'
    distinct: List['LogRecordScalarFieldKeys']
    include: 'LogRecordIncludeFromLogRecordRecursive1'


class FindManyLogRecordArgsFromStoredTestCaseRecursive1(TypedDict, total=False):
    """Arguments for StoredTestCase"""
    take: int
    skip: int
    order_by: Union['LogRecordOrderByInput', List['LogRecordOrderByInput']]
    where: 'LogRecordWhereInput'
    cursor: 'LogRecordWhereUniqueInput'
    distinct: List['LogRecordScalarFieldKeys']
    include: 'LogRecordIncludeFromLogRecordRecursive2'


class FindManyLogRecordArgsFromStoredTestCaseRecursive2(TypedDict, total=False):
    """Arguments for StoredTestCase"""
    take: int
    skip: int
    order_by: Union['LogRecordOrderByInput', List['LogRecordOrderByInput']]
    where: 'LogRecordWhereInput'
    cursor: 'LogRecordWhereUniqueInput'
    distinct: List['LogRecordScalarFieldKeys']
    include: 'LogRecordIncludeFromLogRecordRecursive3'


class FindManyLogRecordArgsFromStoredTestCaseRecursive3(TypedDict, total=False):
    """Arguments for StoredTestCase"""
    take: int
    skip: int
    order_by: Union['LogRecordOrderByInput', List['LogRecordOrderByInput']]
    where: 'LogRecordWhereInput'
    cursor: 'LogRecordWhereUniqueInput'
    distinct: List['LogRecordScalarFieldKeys']
    include: 'LogRecordIncludeFromLogRecordRecursive4'


class FindManyLogRecordArgsFromStoredTestCaseRecursive4(TypedDict, total=False):
    """Arguments for StoredTestCase"""
    take: int
    skip: int
    order_by: Union['LogRecordOrderByInput', List['LogRecordOrderByInput']]
    where: 'LogRecordWhereInput'
    cursor: 'LogRecordWhereUniqueInput'
    distinct: List['LogRecordScalarFieldKeys']
    


FindManyStoredTestCaseArgs = FindManyStoredTestCaseArgsFromStoredTestCase
FindFirstStoredTestCaseArgs = FindManyStoredTestCaseArgsFromStoredTestCase


    

class StoredTestCaseWhereInput(TypedDict, total=False):
    """StoredTestCase arguments for searching"""
    id: Union[_int, 'types.IntFilter']
    user_id: Union[_int, 'types.IntFilter']
    content: Union[_str, 'types.StringFilter']
    name: Union[_str, 'types.StringFilter']
    app_user: 'AppUserRelationFilter'

    # should be noted that AND and NOT should be Union['StoredTestCaseWhereInputRecursive1', List['StoredTestCaseWhereInputRecursive1']]
    # but this causes mypy to hang :/
    AND: List['StoredTestCaseWhereInputRecursive1']
    OR: List['StoredTestCaseWhereInputRecursive1']
    NOT: List['StoredTestCaseWhereInputRecursive1']


class StoredTestCaseWhereInputRecursive1(TypedDict, total=False):
    """StoredTestCase arguments for searching"""
    id: Union[_int, 'types.IntFilter']
    user_id: Union[_int, 'types.IntFilter']
    content: Union[_str, 'types.StringFilter']
    name: Union[_str, 'types.StringFilter']
    app_user: 'AppUserRelationFilter'

    # should be noted that AND and NOT should be Union['StoredTestCaseWhereInputRecursive2', List['StoredTestCaseWhereInputRecursive2']]
    # but this causes mypy to hang :/
    AND: List['StoredTestCaseWhereInputRecursive2']
    OR: List['StoredTestCaseWhereInputRecursive2']
    NOT: List['StoredTestCaseWhereInputRecursive2']


class StoredTestCaseWhereInputRecursive2(TypedDict, total=False):
    """StoredTestCase arguments for searching"""
    id: Union[_int, 'types.IntFilter']
    user_id: Union[_int, 'types.IntFilter']
    content: Union[_str, 'types.StringFilter']
    name: Union[_str, 'types.StringFilter']
    app_user: 'AppUserRelationFilter'

    # should be noted that AND and NOT should be Union['StoredTestCaseWhereInputRecursive3', List['StoredTestCaseWhereInputRecursive3']]
    # but this causes mypy to hang :/
    AND: List['StoredTestCaseWhereInputRecursive3']
    OR: List['StoredTestCaseWhereInputRecursive3']
    NOT: List['StoredTestCaseWhereInputRecursive3']


class StoredTestCaseWhereInputRecursive3(TypedDict, total=False):
    """StoredTestCase arguments for searching"""
    id: Union[_int, 'types.IntFilter']
    user_id: Union[_int, 'types.IntFilter']
    content: Union[_str, 'types.StringFilter']
    name: Union[_str, 'types.StringFilter']
    app_user: 'AppUserRelationFilter'

    # should be noted that AND and NOT should be Union['StoredTestCaseWhereInputRecursive4', List['StoredTestCaseWhereInputRecursive4']]
    # but this causes mypy to hang :/
    AND: List['StoredTestCaseWhereInputRecursive4']
    OR: List['StoredTestCaseWhereInputRecursive4']
    NOT: List['StoredTestCaseWhereInputRecursive4']


class StoredTestCaseWhereInputRecursive4(TypedDict, total=False):
    """StoredTestCase arguments for searching"""
    id: Union[_int, 'types.IntFilter']
    user_id: Union[_int, 'types.IntFilter']
    content: Union[_str, 'types.StringFilter']
    name: Union[_str, 'types.StringFilter']
    app_user: 'AppUserRelationFilter'



# aggregate StoredTestCase types


    

class StoredTestCaseScalarWhereWithAggregatesInput(TypedDict, total=False):
    """StoredTestCase arguments for searching"""
    id: Union[_int, 'types.IntWithAggregatesFilter']
    user_id: Union[_int, 'types.IntWithAggregatesFilter']
    content: Union[_str, 'types.StringWithAggregatesFilter']
    name: Union[_str, 'types.StringWithAggregatesFilter']

    AND: List['StoredTestCaseScalarWhereWithAggregatesInputRecursive1']
    OR: List['StoredTestCaseScalarWhereWithAggregatesInputRecursive1']
    NOT: List['StoredTestCaseScalarWhereWithAggregatesInputRecursive1']


class StoredTestCaseScalarWhereWithAggregatesInputRecursive1(TypedDict, total=False):
    """StoredTestCase arguments for searching"""
    id: Union[_int, 'types.IntWithAggregatesFilter']
    user_id: Union[_int, 'types.IntWithAggregatesFilter']
    content: Union[_str, 'types.StringWithAggregatesFilter']
    name: Union[_str, 'types.StringWithAggregatesFilter']

    AND: List['StoredTestCaseScalarWhereWithAggregatesInputRecursive2']
    OR: List['StoredTestCaseScalarWhereWithAggregatesInputRecursive2']
    NOT: List['StoredTestCaseScalarWhereWithAggregatesInputRecursive2']


class StoredTestCaseScalarWhereWithAggregatesInputRecursive2(TypedDict, total=False):
    """StoredTestCase arguments for searching"""
    id: Union[_int, 'types.IntWithAggregatesFilter']
    user_id: Union[_int, 'types.IntWithAggregatesFilter']
    content: Union[_str, 'types.StringWithAggregatesFilter']
    name: Union[_str, 'types.StringWithAggregatesFilter']

    AND: List['StoredTestCaseScalarWhereWithAggregatesInputRecursive3']
    OR: List['StoredTestCaseScalarWhereWithAggregatesInputRecursive3']
    NOT: List['StoredTestCaseScalarWhereWithAggregatesInputRecursive3']


class StoredTestCaseScalarWhereWithAggregatesInputRecursive3(TypedDict, total=False):
    """StoredTestCase arguments for searching"""
    id: Union[_int, 'types.IntWithAggregatesFilter']
    user_id: Union[_int, 'types.IntWithAggregatesFilter']
    content: Union[_str, 'types.StringWithAggregatesFilter']
    name: Union[_str, 'types.StringWithAggregatesFilter']

    AND: List['StoredTestCaseScalarWhereWithAggregatesInputRecursive4']
    OR: List['StoredTestCaseScalarWhereWithAggregatesInputRecursive4']
    NOT: List['StoredTestCaseScalarWhereWithAggregatesInputRecursive4']


class StoredTestCaseScalarWhereWithAggregatesInputRecursive4(TypedDict, total=False):
    """StoredTestCase arguments for searching"""
    id: Union[_int, 'types.IntWithAggregatesFilter']
    user_id: Union[_int, 'types.IntWithAggregatesFilter']
    content: Union[_str, 'types.StringWithAggregatesFilter']
    name: Union[_str, 'types.StringWithAggregatesFilter']



class StoredTestCaseGroupByOutput(TypedDict, total=False):
    id: _int
    user_id: _int
    content: _str
    name: _str
    _sum: 'StoredTestCaseSumAggregateOutput'
    _avg: 'StoredTestCaseAvgAggregateOutput'
    _min: 'StoredTestCaseMinAggregateOutput'
    _max: 'StoredTestCaseMaxAggregateOutput'
    _count: 'StoredTestCaseCountAggregateOutput'


class StoredTestCaseAvgAggregateOutput(TypedDict, total=False):
    """StoredTestCase output for aggregating averages"""
    id: float
    user_id: float


class StoredTestCaseSumAggregateOutput(TypedDict, total=False):
    """StoredTestCase output for aggregating sums"""
    id: _int
    user_id: _int


class StoredTestCaseScalarAggregateOutput(TypedDict, total=False):
    """StoredTestCase output including scalar fields"""
    id: _int
    user_id: _int
    content: _str
    name: _str


StoredTestCaseMinAggregateOutput = StoredTestCaseScalarAggregateOutput
StoredTestCaseMaxAggregateOutput = StoredTestCaseScalarAggregateOutput


class StoredTestCaseMaxAggregateInput(TypedDict, total=False):
    """StoredTestCase input for aggregating by max"""
    id: bool
    user_id: bool
    content: bool
    name: bool


class StoredTestCaseMinAggregateInput(TypedDict, total=False):
    """StoredTestCase input for aggregating by min"""
    id: bool
    user_id: bool
    content: bool
    name: bool


class StoredTestCaseNumberAggregateInput(TypedDict, total=False):
    """StoredTestCase input for aggregating numbers"""
    id: bool
    user_id: bool


StoredTestCaseAvgAggregateInput = StoredTestCaseNumberAggregateInput
StoredTestCaseSumAggregateInput = StoredTestCaseNumberAggregateInput


StoredTestCaseCountAggregateInput = TypedDict(
    'StoredTestCaseCountAggregateInput',
    {
        'id': bool,
        'user_id': bool,
        'content': bool,
        'name': bool,
        '_all': bool,
    },
    total=False,
)

StoredTestCaseCountAggregateOutput = TypedDict(
    'StoredTestCaseCountAggregateOutput',
    {
        'id': int,
        'user_id': int,
        'content': int,
        'name': int,
        '_all': int,
    },
    total=False,
)


StoredTestCaseKeys = Literal[
    'id',
    'user_id',
    'content',
    'name',
    'app_user',
]
StoredTestCaseScalarFieldKeys = Literal[
    'id',
    'user_id',
    'content',
    'name',
]
StoredTestCaseScalarFieldKeysT = TypeVar('StoredTestCaseScalarFieldKeysT', bound=StoredTestCaseScalarFieldKeys)

StoredTestCaseRelationalFieldKeys = Literal[
        'app_user',
    ]

# AppUser types

class AppUserOptionalCreateInput(TypedDict, total=False):
    """Optional arguments to the AppUser create method"""
    id: _int
    created_at: datetime.datetime
    stored_test_cases: 'StoredTestCaseCreateManyNestedWithoutRelationsInput'


class AppUserCreateInput(AppUserOptionalCreateInput):
    """Required arguments to the AppUser create method"""
    email: _str
    name: _str


# TODO: remove this in favour of without explicit relations
# e.g. PostCreateWithoutAuthorInput

class AppUserOptionalCreateWithoutRelationsInput(TypedDict, total=False):
    """Optional arguments to the AppUser create method, without relations"""
    id: _int
    created_at: datetime.datetime


class AppUserCreateWithoutRelationsInput(AppUserOptionalCreateWithoutRelationsInput):
    """Required arguments to the AppUser create method, without relations"""
    email: _str
    name: _str

class AppUserConnectOrCreateWithoutRelationsInput(TypedDict):
    create: 'AppUserCreateWithoutRelationsInput'
    where: 'AppUserWhereUniqueInput'

class AppUserCreateNestedWithoutRelationsInput(TypedDict, total=False):
    create: 'AppUserCreateWithoutRelationsInput'
    connect: 'AppUserWhereUniqueInput'
    connect_or_create: 'AppUserConnectOrCreateWithoutRelationsInput'


class AppUserCreateManyNestedWithoutRelationsInput(TypedDict, total=False):
    create: Union['AppUserCreateWithoutRelationsInput', List['AppUserCreateWithoutRelationsInput']]
    connect: Union['AppUserWhereUniqueInput', List['AppUserWhereUniqueInput']]
    connect_or_create: Union['AppUserConnectOrCreateWithoutRelationsInput', List['AppUserConnectOrCreateWithoutRelationsInput']]

_AppUserWhereUnique_id_Input = TypedDict(
    '_AppUserWhereUnique_id_Input',
    {
        'id': '_int',
    },
    total=True
)

_AppUserWhereUnique_email_Input = TypedDict(
    '_AppUserWhereUnique_email_Input',
    {
        'email': '_str',
    },
    total=True
)

AppUserWhereUniqueInput = Union[
    '_AppUserWhereUnique_id_Input',
    '_AppUserWhereUnique_email_Input',
]


class AppUserUpdateInput(TypedDict, total=False):
    """Optional arguments for updating a record"""
    id: Union[AtomicIntInput, _int]
    email: _str
    name: _str
    created_at: datetime.datetime
    stored_test_cases: 'StoredTestCaseUpdateManyWithoutRelationsInput'


class AppUserUpdateManyMutationInput(TypedDict, total=False):
    """Arguments for updating many records"""
    id: Union[AtomicIntInput, _int]
    email: _str
    name: _str
    created_at: datetime.datetime


class AppUserUpdateManyWithoutRelationsInput(TypedDict, total=False):
    create: List['AppUserCreateWithoutRelationsInput']
    connect: List['AppUserWhereUniqueInput']
    connect_or_create: List['AppUserConnectOrCreateWithoutRelationsInput']
    set: List['AppUserWhereUniqueInput']
    disconnect: List['AppUserWhereUniqueInput']
    delete: List['AppUserWhereUniqueInput']

    # TODO
    # update: List['AppUserUpdateWithWhereUniqueWithoutRelationsInput']
    # updateMany: List['AppUserUpdateManyWithWhereUniqueWithoutRelationsInput']
    # deleteMany: List['AppUserScalarWhereInput']
    # upsert: List['AppUserUpserteWithWhereUniqueWithoutRelationsInput']


class AppUserUpdateOneWithoutRelationsInput(TypedDict, total=False):
    create: 'AppUserCreateWithoutRelationsInput'
    connect: 'AppUserWhereUniqueInput'
    connect_or_create: 'AppUserConnectOrCreateWithoutRelationsInput'
    disconnect: bool
    delete: bool

    # TODO
    # update: 'AppUserUpdateInput'
    # upsert: 'AppUserUpsertWithoutRelationsInput'


class AppUserUpsertInput(TypedDict):
    create: 'AppUserCreateInput'
    update: 'AppUserUpdateInput'  # pyright: ignore[reportIncompatibleMethodOverride]


_AppUser_id_OrderByInput = TypedDict(
    '_AppUser_id_OrderByInput',
    {
        'id': 'SortOrder',
    },
    total=True
)

_AppUser_email_OrderByInput = TypedDict(
    '_AppUser_email_OrderByInput',
    {
        'email': 'SortOrder',
    },
    total=True
)

_AppUser_name_OrderByInput = TypedDict(
    '_AppUser_name_OrderByInput',
    {
        'name': 'SortOrder',
    },
    total=True
)

_AppUser_created_at_OrderByInput = TypedDict(
    '_AppUser_created_at_OrderByInput',
    {
        'created_at': 'SortOrder',
    },
    total=True
)

AppUserOrderByInput = Union[
    '_AppUser_id_OrderByInput',
    '_AppUser_email_OrderByInput',
    '_AppUser_name_OrderByInput',
    '_AppUser_created_at_OrderByInput',
]



# recursive AppUser types
# TODO: cleanup these types


# Dict[str, Any] is a mypy limitation
# see https://github.com/RobertCraigie/prisma-client-py/issues/45
# switch to pyright for improved types, see https://prisma-client-py.readthedocs.io/en/stable/reference/limitations/

AppUserRelationFilter = TypedDict(
    'AppUserRelationFilter',
    {
        'is': 'Dict[str, Any]',
        'is_not': 'Dict[str, Any]',
    },
    total=False,
)


class AppUserListRelationFilter(TypedDict, total=False):
    some: 'Dict[str, Any]'
    none: 'Dict[str, Any]'
    every: 'Dict[str, Any]'


class AppUserInclude(TypedDict, total=False):
    """AppUser relational arguments"""
    stored_test_cases: Union[bool, 'FindManyStoredTestCaseArgsFromAppUser']


    

class StoredTestCaseIncludeFromAppUser(TypedDict, total=False):
    """Relational arguments for AppUser"""
    app_user: Union[bool, 'AppUserArgsFromAppUserRecursive1']


class StoredTestCaseIncludeFromAppUserRecursive1(TypedDict, total=False):
    """Relational arguments for AppUser"""
    app_user: Union[bool, 'AppUserArgsFromAppUserRecursive2']


class StoredTestCaseIncludeFromAppUserRecursive2(TypedDict, total=False):
    """Relational arguments for AppUser"""
    app_user: Union[bool, 'AppUserArgsFromAppUserRecursive3']


class StoredTestCaseIncludeFromAppUserRecursive3(TypedDict, total=False):
    """Relational arguments for AppUser"""
    app_user: Union[bool, 'AppUserArgsFromAppUserRecursive4']


class StoredTestCaseIncludeFromAppUserRecursive4(TypedDict, total=False):
    """Relational arguments for AppUser"""

    

class StoredTestCaseArgsFromAppUser(TypedDict, total=False):
    """Arguments for AppUser"""
    include: 'StoredTestCaseIncludeFromStoredTestCaseRecursive1'


class StoredTestCaseArgsFromAppUserRecursive1(TypedDict, total=False):
    """Arguments for AppUser"""
    include: 'StoredTestCaseIncludeFromStoredTestCaseRecursive2'


class StoredTestCaseArgsFromAppUserRecursive2(TypedDict, total=False):
    """Arguments for AppUser"""
    include: 'StoredTestCaseIncludeFromStoredTestCaseRecursive3'


class StoredTestCaseArgsFromAppUserRecursive3(TypedDict, total=False):
    """Arguments for AppUser"""
    include: 'StoredTestCaseIncludeFromStoredTestCaseRecursive4'


class StoredTestCaseArgsFromAppUserRecursive4(TypedDict, total=False):
    """Arguments for AppUser"""
    
    

class FindManyStoredTestCaseArgsFromAppUser(TypedDict, total=False):
    """Arguments for AppUser"""
    take: int
    skip: int
    order_by: Union['StoredTestCaseOrderByInput', List['StoredTestCaseOrderByInput']]
    where: 'StoredTestCaseWhereInput'
    cursor: 'StoredTestCaseWhereUniqueInput'
    distinct: List['StoredTestCaseScalarFieldKeys']
    include: 'StoredTestCaseIncludeFromStoredTestCaseRecursive1'


class FindManyStoredTestCaseArgsFromAppUserRecursive1(TypedDict, total=False):
    """Arguments for AppUser"""
    take: int
    skip: int
    order_by: Union['StoredTestCaseOrderByInput', List['StoredTestCaseOrderByInput']]
    where: 'StoredTestCaseWhereInput'
    cursor: 'StoredTestCaseWhereUniqueInput'
    distinct: List['StoredTestCaseScalarFieldKeys']
    include: 'StoredTestCaseIncludeFromStoredTestCaseRecursive2'


class FindManyStoredTestCaseArgsFromAppUserRecursive2(TypedDict, total=False):
    """Arguments for AppUser"""
    take: int
    skip: int
    order_by: Union['StoredTestCaseOrderByInput', List['StoredTestCaseOrderByInput']]
    where: 'StoredTestCaseWhereInput'
    cursor: 'StoredTestCaseWhereUniqueInput'
    distinct: List['StoredTestCaseScalarFieldKeys']
    include: 'StoredTestCaseIncludeFromStoredTestCaseRecursive3'


class FindManyStoredTestCaseArgsFromAppUserRecursive3(TypedDict, total=False):
    """Arguments for AppUser"""
    take: int
    skip: int
    order_by: Union['StoredTestCaseOrderByInput', List['StoredTestCaseOrderByInput']]
    where: 'StoredTestCaseWhereInput'
    cursor: 'StoredTestCaseWhereUniqueInput'
    distinct: List['StoredTestCaseScalarFieldKeys']
    include: 'StoredTestCaseIncludeFromStoredTestCaseRecursive4'


class FindManyStoredTestCaseArgsFromAppUserRecursive4(TypedDict, total=False):
    """Arguments for AppUser"""
    take: int
    skip: int
    order_by: Union['StoredTestCaseOrderByInput', List['StoredTestCaseOrderByInput']]
    where: 'StoredTestCaseWhereInput'
    cursor: 'StoredTestCaseWhereUniqueInput'
    distinct: List['StoredTestCaseScalarFieldKeys']
    
    

class AppUserIncludeFromAppUser(TypedDict, total=False):
    """Relational arguments for AppUser"""
    stored_test_cases: Union[bool, 'FindManyStoredTestCaseArgsFromAppUserRecursive1']


class AppUserIncludeFromAppUserRecursive1(TypedDict, total=False):
    """Relational arguments for AppUser"""
    stored_test_cases: Union[bool, 'FindManyStoredTestCaseArgsFromAppUserRecursive2']


class AppUserIncludeFromAppUserRecursive2(TypedDict, total=False):
    """Relational arguments for AppUser"""
    stored_test_cases: Union[bool, 'FindManyStoredTestCaseArgsFromAppUserRecursive3']


class AppUserIncludeFromAppUserRecursive3(TypedDict, total=False):
    """Relational arguments for AppUser"""
    stored_test_cases: Union[bool, 'FindManyStoredTestCaseArgsFromAppUserRecursive4']


class AppUserIncludeFromAppUserRecursive4(TypedDict, total=False):
    """Relational arguments for AppUser"""

    

class AppUserArgsFromAppUser(TypedDict, total=False):
    """Arguments for AppUser"""
    include: 'AppUserIncludeFromAppUserRecursive1'


class AppUserArgsFromAppUserRecursive1(TypedDict, total=False):
    """Arguments for AppUser"""
    include: 'AppUserIncludeFromAppUserRecursive2'


class AppUserArgsFromAppUserRecursive2(TypedDict, total=False):
    """Arguments for AppUser"""
    include: 'AppUserIncludeFromAppUserRecursive3'


class AppUserArgsFromAppUserRecursive3(TypedDict, total=False):
    """Arguments for AppUser"""
    include: 'AppUserIncludeFromAppUserRecursive4'


class AppUserArgsFromAppUserRecursive4(TypedDict, total=False):
    """Arguments for AppUser"""
    
    

class FindManyAppUserArgsFromAppUser(TypedDict, total=False):
    """Arguments for AppUser"""
    take: int
    skip: int
    order_by: Union['AppUserOrderByInput', List['AppUserOrderByInput']]
    where: 'AppUserWhereInput'
    cursor: 'AppUserWhereUniqueInput'
    distinct: List['AppUserScalarFieldKeys']
    include: 'AppUserIncludeFromAppUserRecursive1'


class FindManyAppUserArgsFromAppUserRecursive1(TypedDict, total=False):
    """Arguments for AppUser"""
    take: int
    skip: int
    order_by: Union['AppUserOrderByInput', List['AppUserOrderByInput']]
    where: 'AppUserWhereInput'
    cursor: 'AppUserWhereUniqueInput'
    distinct: List['AppUserScalarFieldKeys']
    include: 'AppUserIncludeFromAppUserRecursive2'


class FindManyAppUserArgsFromAppUserRecursive2(TypedDict, total=False):
    """Arguments for AppUser"""
    take: int
    skip: int
    order_by: Union['AppUserOrderByInput', List['AppUserOrderByInput']]
    where: 'AppUserWhereInput'
    cursor: 'AppUserWhereUniqueInput'
    distinct: List['AppUserScalarFieldKeys']
    include: 'AppUserIncludeFromAppUserRecursive3'


class FindManyAppUserArgsFromAppUserRecursive3(TypedDict, total=False):
    """Arguments for AppUser"""
    take: int
    skip: int
    order_by: Union['AppUserOrderByInput', List['AppUserOrderByInput']]
    where: 'AppUserWhereInput'
    cursor: 'AppUserWhereUniqueInput'
    distinct: List['AppUserScalarFieldKeys']
    include: 'AppUserIncludeFromAppUserRecursive4'


class FindManyAppUserArgsFromAppUserRecursive4(TypedDict, total=False):
    """Arguments for AppUser"""
    take: int
    skip: int
    order_by: Union['AppUserOrderByInput', List['AppUserOrderByInput']]
    where: 'AppUserWhereInput'
    cursor: 'AppUserWhereUniqueInput'
    distinct: List['AppUserScalarFieldKeys']
    
    

class LogRecordIncludeFromAppUser(TypedDict, total=False):
    """Relational arguments for AppUser"""


class LogRecordIncludeFromAppUserRecursive1(TypedDict, total=False):
    """Relational arguments for AppUser"""


class LogRecordIncludeFromAppUserRecursive2(TypedDict, total=False):
    """Relational arguments for AppUser"""


class LogRecordIncludeFromAppUserRecursive3(TypedDict, total=False):
    """Relational arguments for AppUser"""


class LogRecordIncludeFromAppUserRecursive4(TypedDict, total=False):
    """Relational arguments for AppUser"""

    

class LogRecordArgsFromAppUser(TypedDict, total=False):
    """Arguments for AppUser"""
    include: 'LogRecordIncludeFromLogRecordRecursive1'


class LogRecordArgsFromAppUserRecursive1(TypedDict, total=False):
    """Arguments for AppUser"""
    include: 'LogRecordIncludeFromLogRecordRecursive2'


class LogRecordArgsFromAppUserRecursive2(TypedDict, total=False):
    """Arguments for AppUser"""
    include: 'LogRecordIncludeFromLogRecordRecursive3'


class LogRecordArgsFromAppUserRecursive3(TypedDict, total=False):
    """Arguments for AppUser"""
    include: 'LogRecordIncludeFromLogRecordRecursive4'


class LogRecordArgsFromAppUserRecursive4(TypedDict, total=False):
    """Arguments for AppUser"""
    
    

class FindManyLogRecordArgsFromAppUser(TypedDict, total=False):
    """Arguments for AppUser"""
    take: int
    skip: int
    order_by: Union['LogRecordOrderByInput', List['LogRecordOrderByInput']]
    where: 'LogRecordWhereInput'
    cursor: 'LogRecordWhereUniqueInput'
    distinct: List['LogRecordScalarFieldKeys']
    include: 'LogRecordIncludeFromLogRecordRecursive1'


class FindManyLogRecordArgsFromAppUserRecursive1(TypedDict, total=False):
    """Arguments for AppUser"""
    take: int
    skip: int
    order_by: Union['LogRecordOrderByInput', List['LogRecordOrderByInput']]
    where: 'LogRecordWhereInput'
    cursor: 'LogRecordWhereUniqueInput'
    distinct: List['LogRecordScalarFieldKeys']
    include: 'LogRecordIncludeFromLogRecordRecursive2'


class FindManyLogRecordArgsFromAppUserRecursive2(TypedDict, total=False):
    """Arguments for AppUser"""
    take: int
    skip: int
    order_by: Union['LogRecordOrderByInput', List['LogRecordOrderByInput']]
    where: 'LogRecordWhereInput'
    cursor: 'LogRecordWhereUniqueInput'
    distinct: List['LogRecordScalarFieldKeys']
    include: 'LogRecordIncludeFromLogRecordRecursive3'


class FindManyLogRecordArgsFromAppUserRecursive3(TypedDict, total=False):
    """Arguments for AppUser"""
    take: int
    skip: int
    order_by: Union['LogRecordOrderByInput', List['LogRecordOrderByInput']]
    where: 'LogRecordWhereInput'
    cursor: 'LogRecordWhereUniqueInput'
    distinct: List['LogRecordScalarFieldKeys']
    include: 'LogRecordIncludeFromLogRecordRecursive4'


class FindManyLogRecordArgsFromAppUserRecursive4(TypedDict, total=False):
    """Arguments for AppUser"""
    take: int
    skip: int
    order_by: Union['LogRecordOrderByInput', List['LogRecordOrderByInput']]
    where: 'LogRecordWhereInput'
    cursor: 'LogRecordWhereUniqueInput'
    distinct: List['LogRecordScalarFieldKeys']
    


FindManyAppUserArgs = FindManyAppUserArgsFromAppUser
FindFirstAppUserArgs = FindManyAppUserArgsFromAppUser


    

class AppUserWhereInput(TypedDict, total=False):
    """AppUser arguments for searching"""
    id: Union[_int, 'types.IntFilter']
    email: Union[_str, 'types.StringFilter']
    name: Union[_str, 'types.StringFilter']
    created_at: Union[datetime.datetime, 'types.DateTimeFilter']
    stored_test_cases: 'StoredTestCaseListRelationFilter'

    # should be noted that AND and NOT should be Union['AppUserWhereInputRecursive1', List['AppUserWhereInputRecursive1']]
    # but this causes mypy to hang :/
    AND: List['AppUserWhereInputRecursive1']
    OR: List['AppUserWhereInputRecursive1']
    NOT: List['AppUserWhereInputRecursive1']


class AppUserWhereInputRecursive1(TypedDict, total=False):
    """AppUser arguments for searching"""
    id: Union[_int, 'types.IntFilter']
    email: Union[_str, 'types.StringFilter']
    name: Union[_str, 'types.StringFilter']
    created_at: Union[datetime.datetime, 'types.DateTimeFilter']
    stored_test_cases: 'StoredTestCaseListRelationFilter'

    # should be noted that AND and NOT should be Union['AppUserWhereInputRecursive2', List['AppUserWhereInputRecursive2']]
    # but this causes mypy to hang :/
    AND: List['AppUserWhereInputRecursive2']
    OR: List['AppUserWhereInputRecursive2']
    NOT: List['AppUserWhereInputRecursive2']


class AppUserWhereInputRecursive2(TypedDict, total=False):
    """AppUser arguments for searching"""
    id: Union[_int, 'types.IntFilter']
    email: Union[_str, 'types.StringFilter']
    name: Union[_str, 'types.StringFilter']
    created_at: Union[datetime.datetime, 'types.DateTimeFilter']
    stored_test_cases: 'StoredTestCaseListRelationFilter'

    # should be noted that AND and NOT should be Union['AppUserWhereInputRecursive3', List['AppUserWhereInputRecursive3']]
    # but this causes mypy to hang :/
    AND: List['AppUserWhereInputRecursive3']
    OR: List['AppUserWhereInputRecursive3']
    NOT: List['AppUserWhereInputRecursive3']


class AppUserWhereInputRecursive3(TypedDict, total=False):
    """AppUser arguments for searching"""
    id: Union[_int, 'types.IntFilter']
    email: Union[_str, 'types.StringFilter']
    name: Union[_str, 'types.StringFilter']
    created_at: Union[datetime.datetime, 'types.DateTimeFilter']
    stored_test_cases: 'StoredTestCaseListRelationFilter'

    # should be noted that AND and NOT should be Union['AppUserWhereInputRecursive4', List['AppUserWhereInputRecursive4']]
    # but this causes mypy to hang :/
    AND: List['AppUserWhereInputRecursive4']
    OR: List['AppUserWhereInputRecursive4']
    NOT: List['AppUserWhereInputRecursive4']


class AppUserWhereInputRecursive4(TypedDict, total=False):
    """AppUser arguments for searching"""
    id: Union[_int, 'types.IntFilter']
    email: Union[_str, 'types.StringFilter']
    name: Union[_str, 'types.StringFilter']
    created_at: Union[datetime.datetime, 'types.DateTimeFilter']
    stored_test_cases: 'StoredTestCaseListRelationFilter'



# aggregate AppUser types


    

class AppUserScalarWhereWithAggregatesInput(TypedDict, total=False):
    """AppUser arguments for searching"""
    id: Union[_int, 'types.IntWithAggregatesFilter']
    email: Union[_str, 'types.StringWithAggregatesFilter']
    name: Union[_str, 'types.StringWithAggregatesFilter']
    created_at: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']

    AND: List['AppUserScalarWhereWithAggregatesInputRecursive1']
    OR: List['AppUserScalarWhereWithAggregatesInputRecursive1']
    NOT: List['AppUserScalarWhereWithAggregatesInputRecursive1']


class AppUserScalarWhereWithAggregatesInputRecursive1(TypedDict, total=False):
    """AppUser arguments for searching"""
    id: Union[_int, 'types.IntWithAggregatesFilter']
    email: Union[_str, 'types.StringWithAggregatesFilter']
    name: Union[_str, 'types.StringWithAggregatesFilter']
    created_at: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']

    AND: List['AppUserScalarWhereWithAggregatesInputRecursive2']
    OR: List['AppUserScalarWhereWithAggregatesInputRecursive2']
    NOT: List['AppUserScalarWhereWithAggregatesInputRecursive2']


class AppUserScalarWhereWithAggregatesInputRecursive2(TypedDict, total=False):
    """AppUser arguments for searching"""
    id: Union[_int, 'types.IntWithAggregatesFilter']
    email: Union[_str, 'types.StringWithAggregatesFilter']
    name: Union[_str, 'types.StringWithAggregatesFilter']
    created_at: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']

    AND: List['AppUserScalarWhereWithAggregatesInputRecursive3']
    OR: List['AppUserScalarWhereWithAggregatesInputRecursive3']
    NOT: List['AppUserScalarWhereWithAggregatesInputRecursive3']


class AppUserScalarWhereWithAggregatesInputRecursive3(TypedDict, total=False):
    """AppUser arguments for searching"""
    id: Union[_int, 'types.IntWithAggregatesFilter']
    email: Union[_str, 'types.StringWithAggregatesFilter']
    name: Union[_str, 'types.StringWithAggregatesFilter']
    created_at: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']

    AND: List['AppUserScalarWhereWithAggregatesInputRecursive4']
    OR: List['AppUserScalarWhereWithAggregatesInputRecursive4']
    NOT: List['AppUserScalarWhereWithAggregatesInputRecursive4']


class AppUserScalarWhereWithAggregatesInputRecursive4(TypedDict, total=False):
    """AppUser arguments for searching"""
    id: Union[_int, 'types.IntWithAggregatesFilter']
    email: Union[_str, 'types.StringWithAggregatesFilter']
    name: Union[_str, 'types.StringWithAggregatesFilter']
    created_at: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']



class AppUserGroupByOutput(TypedDict, total=False):
    id: _int
    email: _str
    name: _str
    created_at: datetime.datetime
    _sum: 'AppUserSumAggregateOutput'
    _avg: 'AppUserAvgAggregateOutput'
    _min: 'AppUserMinAggregateOutput'
    _max: 'AppUserMaxAggregateOutput'
    _count: 'AppUserCountAggregateOutput'


class AppUserAvgAggregateOutput(TypedDict, total=False):
    """AppUser output for aggregating averages"""
    id: float


class AppUserSumAggregateOutput(TypedDict, total=False):
    """AppUser output for aggregating sums"""
    id: _int


class AppUserScalarAggregateOutput(TypedDict, total=False):
    """AppUser output including scalar fields"""
    id: _int
    email: _str
    name: _str
    created_at: datetime.datetime


AppUserMinAggregateOutput = AppUserScalarAggregateOutput
AppUserMaxAggregateOutput = AppUserScalarAggregateOutput


class AppUserMaxAggregateInput(TypedDict, total=False):
    """AppUser input for aggregating by max"""
    id: bool
    email: bool
    name: bool
    created_at: bool


class AppUserMinAggregateInput(TypedDict, total=False):
    """AppUser input for aggregating by min"""
    id: bool
    email: bool
    name: bool
    created_at: bool


class AppUserNumberAggregateInput(TypedDict, total=False):
    """AppUser input for aggregating numbers"""
    id: bool


AppUserAvgAggregateInput = AppUserNumberAggregateInput
AppUserSumAggregateInput = AppUserNumberAggregateInput


AppUserCountAggregateInput = TypedDict(
    'AppUserCountAggregateInput',
    {
        'id': bool,
        'email': bool,
        'name': bool,
        'created_at': bool,
        '_all': bool,
    },
    total=False,
)

AppUserCountAggregateOutput = TypedDict(
    'AppUserCountAggregateOutput',
    {
        'id': int,
        'email': int,
        'name': int,
        'created_at': int,
        '_all': int,
    },
    total=False,
)


AppUserKeys = Literal[
    'id',
    'email',
    'name',
    'created_at',
    'stored_test_cases',
]
AppUserScalarFieldKeys = Literal[
    'id',
    'email',
    'name',
    'created_at',
]
AppUserScalarFieldKeysT = TypeVar('AppUserScalarFieldKeysT', bound=AppUserScalarFieldKeys)

AppUserRelationalFieldKeys = Literal[
        'stored_test_cases',
    ]

# LogRecord types

class LogRecordOptionalCreateInput(TypedDict, total=False):
    """Optional arguments to the LogRecord create method"""
    id: _int


class LogRecordCreateInput(LogRecordOptionalCreateInput):
    """Required arguments to the LogRecord create method"""
    data: _str


# TODO: remove this in favour of without explicit relations
# e.g. PostCreateWithoutAuthorInput

class LogRecordOptionalCreateWithoutRelationsInput(TypedDict, total=False):
    """Optional arguments to the LogRecord create method, without relations"""
    id: _int


class LogRecordCreateWithoutRelationsInput(LogRecordOptionalCreateWithoutRelationsInput):
    """Required arguments to the LogRecord create method, without relations"""
    data: _str

class LogRecordConnectOrCreateWithoutRelationsInput(TypedDict):
    create: 'LogRecordCreateWithoutRelationsInput'
    where: 'LogRecordWhereUniqueInput'

class LogRecordCreateNestedWithoutRelationsInput(TypedDict, total=False):
    create: 'LogRecordCreateWithoutRelationsInput'
    connect: 'LogRecordWhereUniqueInput'
    connect_or_create: 'LogRecordConnectOrCreateWithoutRelationsInput'


class LogRecordCreateManyNestedWithoutRelationsInput(TypedDict, total=False):
    create: Union['LogRecordCreateWithoutRelationsInput', List['LogRecordCreateWithoutRelationsInput']]
    connect: Union['LogRecordWhereUniqueInput', List['LogRecordWhereUniqueInput']]
    connect_or_create: Union['LogRecordConnectOrCreateWithoutRelationsInput', List['LogRecordConnectOrCreateWithoutRelationsInput']]

_LogRecordWhereUnique_id_Input = TypedDict(
    '_LogRecordWhereUnique_id_Input',
    {
        'id': '_int',
    },
    total=True
)

LogRecordWhereUniqueInput = _LogRecordWhereUnique_id_Input


class LogRecordUpdateInput(TypedDict, total=False):
    """Optional arguments for updating a record"""
    id: Union[AtomicIntInput, _int]
    data: _str


class LogRecordUpdateManyMutationInput(TypedDict, total=False):
    """Arguments for updating many records"""
    id: Union[AtomicIntInput, _int]
    data: _str


class LogRecordUpdateManyWithoutRelationsInput(TypedDict, total=False):
    create: List['LogRecordCreateWithoutRelationsInput']
    connect: List['LogRecordWhereUniqueInput']
    connect_or_create: List['LogRecordConnectOrCreateWithoutRelationsInput']
    set: List['LogRecordWhereUniqueInput']
    disconnect: List['LogRecordWhereUniqueInput']
    delete: List['LogRecordWhereUniqueInput']

    # TODO
    # update: List['LogRecordUpdateWithWhereUniqueWithoutRelationsInput']
    # updateMany: List['LogRecordUpdateManyWithWhereUniqueWithoutRelationsInput']
    # deleteMany: List['LogRecordScalarWhereInput']
    # upsert: List['LogRecordUpserteWithWhereUniqueWithoutRelationsInput']


class LogRecordUpdateOneWithoutRelationsInput(TypedDict, total=False):
    create: 'LogRecordCreateWithoutRelationsInput'
    connect: 'LogRecordWhereUniqueInput'
    connect_or_create: 'LogRecordConnectOrCreateWithoutRelationsInput'
    disconnect: bool
    delete: bool

    # TODO
    # update: 'LogRecordUpdateInput'
    # upsert: 'LogRecordUpsertWithoutRelationsInput'


class LogRecordUpsertInput(TypedDict):
    create: 'LogRecordCreateInput'
    update: 'LogRecordUpdateInput'  # pyright: ignore[reportIncompatibleMethodOverride]


_LogRecord_id_OrderByInput = TypedDict(
    '_LogRecord_id_OrderByInput',
    {
        'id': 'SortOrder',
    },
    total=True
)

_LogRecord_data_OrderByInput = TypedDict(
    '_LogRecord_data_OrderByInput',
    {
        'data': 'SortOrder',
    },
    total=True
)

LogRecordOrderByInput = Union[
    '_LogRecord_id_OrderByInput',
    '_LogRecord_data_OrderByInput',
]



# recursive LogRecord types
# TODO: cleanup these types


# Dict[str, Any] is a mypy limitation
# see https://github.com/RobertCraigie/prisma-client-py/issues/45
# switch to pyright for improved types, see https://prisma-client-py.readthedocs.io/en/stable/reference/limitations/

LogRecordRelationFilter = TypedDict(
    'LogRecordRelationFilter',
    {
        'is': 'Dict[str, Any]',
        'is_not': 'Dict[str, Any]',
    },
    total=False,
)


class LogRecordListRelationFilter(TypedDict, total=False):
    some: 'Dict[str, Any]'
    none: 'Dict[str, Any]'
    every: 'Dict[str, Any]'


class LogRecordInclude(TypedDict, total=False):
    """LogRecord relational arguments"""


    

class StoredTestCaseIncludeFromLogRecord(TypedDict, total=False):
    """Relational arguments for LogRecord"""
    app_user: Union[bool, 'AppUserArgsFromLogRecordRecursive1']


class StoredTestCaseIncludeFromLogRecordRecursive1(TypedDict, total=False):
    """Relational arguments for LogRecord"""
    app_user: Union[bool, 'AppUserArgsFromLogRecordRecursive2']


class StoredTestCaseIncludeFromLogRecordRecursive2(TypedDict, total=False):
    """Relational arguments for LogRecord"""
    app_user: Union[bool, 'AppUserArgsFromLogRecordRecursive3']


class StoredTestCaseIncludeFromLogRecordRecursive3(TypedDict, total=False):
    """Relational arguments for LogRecord"""
    app_user: Union[bool, 'AppUserArgsFromLogRecordRecursive4']


class StoredTestCaseIncludeFromLogRecordRecursive4(TypedDict, total=False):
    """Relational arguments for LogRecord"""

    

class StoredTestCaseArgsFromLogRecord(TypedDict, total=False):
    """Arguments for LogRecord"""
    include: 'StoredTestCaseIncludeFromStoredTestCaseRecursive1'


class StoredTestCaseArgsFromLogRecordRecursive1(TypedDict, total=False):
    """Arguments for LogRecord"""
    include: 'StoredTestCaseIncludeFromStoredTestCaseRecursive2'


class StoredTestCaseArgsFromLogRecordRecursive2(TypedDict, total=False):
    """Arguments for LogRecord"""
    include: 'StoredTestCaseIncludeFromStoredTestCaseRecursive3'


class StoredTestCaseArgsFromLogRecordRecursive3(TypedDict, total=False):
    """Arguments for LogRecord"""
    include: 'StoredTestCaseIncludeFromStoredTestCaseRecursive4'


class StoredTestCaseArgsFromLogRecordRecursive4(TypedDict, total=False):
    """Arguments for LogRecord"""
    
    

class FindManyStoredTestCaseArgsFromLogRecord(TypedDict, total=False):
    """Arguments for LogRecord"""
    take: int
    skip: int
    order_by: Union['StoredTestCaseOrderByInput', List['StoredTestCaseOrderByInput']]
    where: 'StoredTestCaseWhereInput'
    cursor: 'StoredTestCaseWhereUniqueInput'
    distinct: List['StoredTestCaseScalarFieldKeys']
    include: 'StoredTestCaseIncludeFromStoredTestCaseRecursive1'


class FindManyStoredTestCaseArgsFromLogRecordRecursive1(TypedDict, total=False):
    """Arguments for LogRecord"""
    take: int
    skip: int
    order_by: Union['StoredTestCaseOrderByInput', List['StoredTestCaseOrderByInput']]
    where: 'StoredTestCaseWhereInput'
    cursor: 'StoredTestCaseWhereUniqueInput'
    distinct: List['StoredTestCaseScalarFieldKeys']
    include: 'StoredTestCaseIncludeFromStoredTestCaseRecursive2'


class FindManyStoredTestCaseArgsFromLogRecordRecursive2(TypedDict, total=False):
    """Arguments for LogRecord"""
    take: int
    skip: int
    order_by: Union['StoredTestCaseOrderByInput', List['StoredTestCaseOrderByInput']]
    where: 'StoredTestCaseWhereInput'
    cursor: 'StoredTestCaseWhereUniqueInput'
    distinct: List['StoredTestCaseScalarFieldKeys']
    include: 'StoredTestCaseIncludeFromStoredTestCaseRecursive3'


class FindManyStoredTestCaseArgsFromLogRecordRecursive3(TypedDict, total=False):
    """Arguments for LogRecord"""
    take: int
    skip: int
    order_by: Union['StoredTestCaseOrderByInput', List['StoredTestCaseOrderByInput']]
    where: 'StoredTestCaseWhereInput'
    cursor: 'StoredTestCaseWhereUniqueInput'
    distinct: List['StoredTestCaseScalarFieldKeys']
    include: 'StoredTestCaseIncludeFromStoredTestCaseRecursive4'


class FindManyStoredTestCaseArgsFromLogRecordRecursive4(TypedDict, total=False):
    """Arguments for LogRecord"""
    take: int
    skip: int
    order_by: Union['StoredTestCaseOrderByInput', List['StoredTestCaseOrderByInput']]
    where: 'StoredTestCaseWhereInput'
    cursor: 'StoredTestCaseWhereUniqueInput'
    distinct: List['StoredTestCaseScalarFieldKeys']
    
    

class AppUserIncludeFromLogRecord(TypedDict, total=False):
    """Relational arguments for LogRecord"""
    stored_test_cases: Union[bool, 'FindManyStoredTestCaseArgsFromLogRecordRecursive1']


class AppUserIncludeFromLogRecordRecursive1(TypedDict, total=False):
    """Relational arguments for LogRecord"""
    stored_test_cases: Union[bool, 'FindManyStoredTestCaseArgsFromLogRecordRecursive2']


class AppUserIncludeFromLogRecordRecursive2(TypedDict, total=False):
    """Relational arguments for LogRecord"""
    stored_test_cases: Union[bool, 'FindManyStoredTestCaseArgsFromLogRecordRecursive3']


class AppUserIncludeFromLogRecordRecursive3(TypedDict, total=False):
    """Relational arguments for LogRecord"""
    stored_test_cases: Union[bool, 'FindManyStoredTestCaseArgsFromLogRecordRecursive4']


class AppUserIncludeFromLogRecordRecursive4(TypedDict, total=False):
    """Relational arguments for LogRecord"""

    

class AppUserArgsFromLogRecord(TypedDict, total=False):
    """Arguments for LogRecord"""
    include: 'AppUserIncludeFromAppUserRecursive1'


class AppUserArgsFromLogRecordRecursive1(TypedDict, total=False):
    """Arguments for LogRecord"""
    include: 'AppUserIncludeFromAppUserRecursive2'


class AppUserArgsFromLogRecordRecursive2(TypedDict, total=False):
    """Arguments for LogRecord"""
    include: 'AppUserIncludeFromAppUserRecursive3'


class AppUserArgsFromLogRecordRecursive3(TypedDict, total=False):
    """Arguments for LogRecord"""
    include: 'AppUserIncludeFromAppUserRecursive4'


class AppUserArgsFromLogRecordRecursive4(TypedDict, total=False):
    """Arguments for LogRecord"""
    
    

class FindManyAppUserArgsFromLogRecord(TypedDict, total=False):
    """Arguments for LogRecord"""
    take: int
    skip: int
    order_by: Union['AppUserOrderByInput', List['AppUserOrderByInput']]
    where: 'AppUserWhereInput'
    cursor: 'AppUserWhereUniqueInput'
    distinct: List['AppUserScalarFieldKeys']
    include: 'AppUserIncludeFromAppUserRecursive1'


class FindManyAppUserArgsFromLogRecordRecursive1(TypedDict, total=False):
    """Arguments for LogRecord"""
    take: int
    skip: int
    order_by: Union['AppUserOrderByInput', List['AppUserOrderByInput']]
    where: 'AppUserWhereInput'
    cursor: 'AppUserWhereUniqueInput'
    distinct: List['AppUserScalarFieldKeys']
    include: 'AppUserIncludeFromAppUserRecursive2'


class FindManyAppUserArgsFromLogRecordRecursive2(TypedDict, total=False):
    """Arguments for LogRecord"""
    take: int
    skip: int
    order_by: Union['AppUserOrderByInput', List['AppUserOrderByInput']]
    where: 'AppUserWhereInput'
    cursor: 'AppUserWhereUniqueInput'
    distinct: List['AppUserScalarFieldKeys']
    include: 'AppUserIncludeFromAppUserRecursive3'


class FindManyAppUserArgsFromLogRecordRecursive3(TypedDict, total=False):
    """Arguments for LogRecord"""
    take: int
    skip: int
    order_by: Union['AppUserOrderByInput', List['AppUserOrderByInput']]
    where: 'AppUserWhereInput'
    cursor: 'AppUserWhereUniqueInput'
    distinct: List['AppUserScalarFieldKeys']
    include: 'AppUserIncludeFromAppUserRecursive4'


class FindManyAppUserArgsFromLogRecordRecursive4(TypedDict, total=False):
    """Arguments for LogRecord"""
    take: int
    skip: int
    order_by: Union['AppUserOrderByInput', List['AppUserOrderByInput']]
    where: 'AppUserWhereInput'
    cursor: 'AppUserWhereUniqueInput'
    distinct: List['AppUserScalarFieldKeys']
    
    

class LogRecordIncludeFromLogRecord(TypedDict, total=False):
    """Relational arguments for LogRecord"""


class LogRecordIncludeFromLogRecordRecursive1(TypedDict, total=False):
    """Relational arguments for LogRecord"""


class LogRecordIncludeFromLogRecordRecursive2(TypedDict, total=False):
    """Relational arguments for LogRecord"""


class LogRecordIncludeFromLogRecordRecursive3(TypedDict, total=False):
    """Relational arguments for LogRecord"""


class LogRecordIncludeFromLogRecordRecursive4(TypedDict, total=False):
    """Relational arguments for LogRecord"""

    

class LogRecordArgsFromLogRecord(TypedDict, total=False):
    """Arguments for LogRecord"""
    include: 'LogRecordIncludeFromLogRecordRecursive1'


class LogRecordArgsFromLogRecordRecursive1(TypedDict, total=False):
    """Arguments for LogRecord"""
    include: 'LogRecordIncludeFromLogRecordRecursive2'


class LogRecordArgsFromLogRecordRecursive2(TypedDict, total=False):
    """Arguments for LogRecord"""
    include: 'LogRecordIncludeFromLogRecordRecursive3'


class LogRecordArgsFromLogRecordRecursive3(TypedDict, total=False):
    """Arguments for LogRecord"""
    include: 'LogRecordIncludeFromLogRecordRecursive4'


class LogRecordArgsFromLogRecordRecursive4(TypedDict, total=False):
    """Arguments for LogRecord"""
    
    

class FindManyLogRecordArgsFromLogRecord(TypedDict, total=False):
    """Arguments for LogRecord"""
    take: int
    skip: int
    order_by: Union['LogRecordOrderByInput', List['LogRecordOrderByInput']]
    where: 'LogRecordWhereInput'
    cursor: 'LogRecordWhereUniqueInput'
    distinct: List['LogRecordScalarFieldKeys']
    include: 'LogRecordIncludeFromLogRecordRecursive1'


class FindManyLogRecordArgsFromLogRecordRecursive1(TypedDict, total=False):
    """Arguments for LogRecord"""
    take: int
    skip: int
    order_by: Union['LogRecordOrderByInput', List['LogRecordOrderByInput']]
    where: 'LogRecordWhereInput'
    cursor: 'LogRecordWhereUniqueInput'
    distinct: List['LogRecordScalarFieldKeys']
    include: 'LogRecordIncludeFromLogRecordRecursive2'


class FindManyLogRecordArgsFromLogRecordRecursive2(TypedDict, total=False):
    """Arguments for LogRecord"""
    take: int
    skip: int
    order_by: Union['LogRecordOrderByInput', List['LogRecordOrderByInput']]
    where: 'LogRecordWhereInput'
    cursor: 'LogRecordWhereUniqueInput'
    distinct: List['LogRecordScalarFieldKeys']
    include: 'LogRecordIncludeFromLogRecordRecursive3'


class FindManyLogRecordArgsFromLogRecordRecursive3(TypedDict, total=False):
    """Arguments for LogRecord"""
    take: int
    skip: int
    order_by: Union['LogRecordOrderByInput', List['LogRecordOrderByInput']]
    where: 'LogRecordWhereInput'
    cursor: 'LogRecordWhereUniqueInput'
    distinct: List['LogRecordScalarFieldKeys']
    include: 'LogRecordIncludeFromLogRecordRecursive4'


class FindManyLogRecordArgsFromLogRecordRecursive4(TypedDict, total=False):
    """Arguments for LogRecord"""
    take: int
    skip: int
    order_by: Union['LogRecordOrderByInput', List['LogRecordOrderByInput']]
    where: 'LogRecordWhereInput'
    cursor: 'LogRecordWhereUniqueInput'
    distinct: List['LogRecordScalarFieldKeys']
    


FindManyLogRecordArgs = FindManyLogRecordArgsFromLogRecord
FindFirstLogRecordArgs = FindManyLogRecordArgsFromLogRecord


    

class LogRecordWhereInput(TypedDict, total=False):
    """LogRecord arguments for searching"""
    id: Union[_int, 'types.IntFilter']
    data: Union[_str, 'types.StringFilter']

    # should be noted that AND and NOT should be Union['LogRecordWhereInputRecursive1', List['LogRecordWhereInputRecursive1']]
    # but this causes mypy to hang :/
    AND: List['LogRecordWhereInputRecursive1']
    OR: List['LogRecordWhereInputRecursive1']
    NOT: List['LogRecordWhereInputRecursive1']


class LogRecordWhereInputRecursive1(TypedDict, total=False):
    """LogRecord arguments for searching"""
    id: Union[_int, 'types.IntFilter']
    data: Union[_str, 'types.StringFilter']

    # should be noted that AND and NOT should be Union['LogRecordWhereInputRecursive2', List['LogRecordWhereInputRecursive2']]
    # but this causes mypy to hang :/
    AND: List['LogRecordWhereInputRecursive2']
    OR: List['LogRecordWhereInputRecursive2']
    NOT: List['LogRecordWhereInputRecursive2']


class LogRecordWhereInputRecursive2(TypedDict, total=False):
    """LogRecord arguments for searching"""
    id: Union[_int, 'types.IntFilter']
    data: Union[_str, 'types.StringFilter']

    # should be noted that AND and NOT should be Union['LogRecordWhereInputRecursive3', List['LogRecordWhereInputRecursive3']]
    # but this causes mypy to hang :/
    AND: List['LogRecordWhereInputRecursive3']
    OR: List['LogRecordWhereInputRecursive3']
    NOT: List['LogRecordWhereInputRecursive3']


class LogRecordWhereInputRecursive3(TypedDict, total=False):
    """LogRecord arguments for searching"""
    id: Union[_int, 'types.IntFilter']
    data: Union[_str, 'types.StringFilter']

    # should be noted that AND and NOT should be Union['LogRecordWhereInputRecursive4', List['LogRecordWhereInputRecursive4']]
    # but this causes mypy to hang :/
    AND: List['LogRecordWhereInputRecursive4']
    OR: List['LogRecordWhereInputRecursive4']
    NOT: List['LogRecordWhereInputRecursive4']


class LogRecordWhereInputRecursive4(TypedDict, total=False):
    """LogRecord arguments for searching"""
    id: Union[_int, 'types.IntFilter']
    data: Union[_str, 'types.StringFilter']



# aggregate LogRecord types


    

class LogRecordScalarWhereWithAggregatesInput(TypedDict, total=False):
    """LogRecord arguments for searching"""
    id: Union[_int, 'types.IntWithAggregatesFilter']
    data: Union[_str, 'types.StringWithAggregatesFilter']

    AND: List['LogRecordScalarWhereWithAggregatesInputRecursive1']
    OR: List['LogRecordScalarWhereWithAggregatesInputRecursive1']
    NOT: List['LogRecordScalarWhereWithAggregatesInputRecursive1']


class LogRecordScalarWhereWithAggregatesInputRecursive1(TypedDict, total=False):
    """LogRecord arguments for searching"""
    id: Union[_int, 'types.IntWithAggregatesFilter']
    data: Union[_str, 'types.StringWithAggregatesFilter']

    AND: List['LogRecordScalarWhereWithAggregatesInputRecursive2']
    OR: List['LogRecordScalarWhereWithAggregatesInputRecursive2']
    NOT: List['LogRecordScalarWhereWithAggregatesInputRecursive2']


class LogRecordScalarWhereWithAggregatesInputRecursive2(TypedDict, total=False):
    """LogRecord arguments for searching"""
    id: Union[_int, 'types.IntWithAggregatesFilter']
    data: Union[_str, 'types.StringWithAggregatesFilter']

    AND: List['LogRecordScalarWhereWithAggregatesInputRecursive3']
    OR: List['LogRecordScalarWhereWithAggregatesInputRecursive3']
    NOT: List['LogRecordScalarWhereWithAggregatesInputRecursive3']


class LogRecordScalarWhereWithAggregatesInputRecursive3(TypedDict, total=False):
    """LogRecord arguments for searching"""
    id: Union[_int, 'types.IntWithAggregatesFilter']
    data: Union[_str, 'types.StringWithAggregatesFilter']

    AND: List['LogRecordScalarWhereWithAggregatesInputRecursive4']
    OR: List['LogRecordScalarWhereWithAggregatesInputRecursive4']
    NOT: List['LogRecordScalarWhereWithAggregatesInputRecursive4']


class LogRecordScalarWhereWithAggregatesInputRecursive4(TypedDict, total=False):
    """LogRecord arguments for searching"""
    id: Union[_int, 'types.IntWithAggregatesFilter']
    data: Union[_str, 'types.StringWithAggregatesFilter']



class LogRecordGroupByOutput(TypedDict, total=False):
    id: _int
    data: _str
    _sum: 'LogRecordSumAggregateOutput'
    _avg: 'LogRecordAvgAggregateOutput'
    _min: 'LogRecordMinAggregateOutput'
    _max: 'LogRecordMaxAggregateOutput'
    _count: 'LogRecordCountAggregateOutput'


class LogRecordAvgAggregateOutput(TypedDict, total=False):
    """LogRecord output for aggregating averages"""
    id: float


class LogRecordSumAggregateOutput(TypedDict, total=False):
    """LogRecord output for aggregating sums"""
    id: _int


class LogRecordScalarAggregateOutput(TypedDict, total=False):
    """LogRecord output including scalar fields"""
    id: _int
    data: _str


LogRecordMinAggregateOutput = LogRecordScalarAggregateOutput
LogRecordMaxAggregateOutput = LogRecordScalarAggregateOutput


class LogRecordMaxAggregateInput(TypedDict, total=False):
    """LogRecord input for aggregating by max"""
    id: bool
    data: bool


class LogRecordMinAggregateInput(TypedDict, total=False):
    """LogRecord input for aggregating by min"""
    id: bool
    data: bool


class LogRecordNumberAggregateInput(TypedDict, total=False):
    """LogRecord input for aggregating numbers"""
    id: bool


LogRecordAvgAggregateInput = LogRecordNumberAggregateInput
LogRecordSumAggregateInput = LogRecordNumberAggregateInput


LogRecordCountAggregateInput = TypedDict(
    'LogRecordCountAggregateInput',
    {
        'id': bool,
        'data': bool,
        '_all': bool,
    },
    total=False,
)

LogRecordCountAggregateOutput = TypedDict(
    'LogRecordCountAggregateOutput',
    {
        'id': int,
        'data': int,
        '_all': int,
    },
    total=False,
)


LogRecordKeys = Literal[
    'id',
    'data',
]
LogRecordScalarFieldKeys = Literal[
    'id',
    'data',
]
LogRecordScalarFieldKeysT = TypeVar('LogRecordScalarFieldKeysT', bound=LogRecordScalarFieldKeys)

LogRecordRelationalFieldKeys = _NoneType



# we have to import ourselves as types can be namespaced to types
from . import types, enums, models, fields