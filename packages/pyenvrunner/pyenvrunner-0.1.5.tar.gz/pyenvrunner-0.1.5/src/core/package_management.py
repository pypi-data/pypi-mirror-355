import os
import sys
import subprocess

from .exceptions import RequirementsFileError, PackageInstallationError, ScriptExecutionError
from .config import DEFAULT_REQUIREMENTS_FILE


def append_requirement(
    module_name: str,
    save_reqs_flag: bool = False,
    requirements_file_name: str = DEFAULT_REQUIREMENTS_FILE,
    venv_python_executable: str = sys.executable
) -> None:
    if not save_reqs_flag:
        return

    normalized_name: str = module_name.split("==")[0].split(">=")[0].split("<=")[0].split(">")[0].split("<")[0].split("~=")[0].split(" @")[0].strip()
    requirement_line: str = normalized_name

    try:
        show_result: subprocess.CompletedProcess[str] = subprocess.run(
            [venv_python_executable, "-m", "pip", "show", normalized_name],
            capture_output=True, text=True, check=True
        )
        version: str = ""
        for line in show_result.stdout.strip().splitlines():
            if line.startswith("Version:"):
                version = line.split(":", 1)[1].strip()
                break
        if version:
            requirement_line = f"{normalized_name}=={version}"
    except subprocess.CalledProcessError:
        pass

    if not os.path.exists(requirements_file_name):
        with open(requirements_file_name, "w") as f:
            f.write("# Auto-generated by pyenvrunner\n")

    with open(requirements_file_name, "r") as f:
        existing_lines: list[str] = [line.strip() for line in f.readlines()]
        existing_modules: set[str] = {
            line.split("==")[0].strip() for line in existing_lines
            if line and not line.startswith("#")
        }

    if normalized_name not in existing_modules:
        with open(requirements_file_name, "a") as f:
            f.write(f"{requirement_line}\n")

def install_missing_packages(
    script_path: str,
    import_to_package_map: dict[str, str],
    venv_python_executable: str,
    venv_pip_command_list: list[str],
    save_requirements_flag: bool,
    requirements_file_name: str = DEFAULT_REQUIREMENTS_FILE
) -> None:
    while True:
        print(f"\n--- Running script: {script_path} using {venv_python_executable} ---")

        try:
            process: subprocess.Popen = subprocess.Popen(
                [venv_python_executable, "-u", script_path],
                stdout=subprocess.PIPE,
                stderr=subprocess.PIPE,
                text=True,
                bufsize=1
            )
        except FileNotFoundError:
            raise ScriptExecutionError(
                f"Script not found: {script_path} or Python executable not found: {venv_python_executable}"
            )

        missing_module: str | None = None
        script_started: bool = False
        script_stdout_lines: list[str] = []
        stderr_output: str = ""

        if process.stdout:
            for line in iter(process.stdout.readline, ""):
                script_started = True
                print(line, end="")
                script_stdout_lines.append(line)

        if process.stderr:
            stderr_output = process.stderr.read()
            if stderr_output:
                print("--- Script STDERR ---")
                print(stderr_output.strip())
                print("---------------------")

            if "ModuleNotFoundError: No module named" in stderr_output:
                try:
                    missing_module_token: str = "ModuleNotFoundError: No module named"
                    missing_module_part: str = stderr_output.split(missing_module_token)[-1]
                    missing_module = missing_module_part.strip().split()[0].strip("'\"")
                except IndexError:
                    raise ScriptExecutionError("Could not parse missing module name from stderr.")

        process.wait()

        if process.returncode != 0 and missing_module:
            install_module: str = import_to_package_map.get(missing_module, missing_module)
            print(f"\n>>> Detected missing module: '{missing_module}'. Attempting to install '{install_module}'...")

            try:
                pip_command_to_run: list[str] = venv_pip_command_list + ["install", install_module]
                install_result: subprocess.CompletedProcess[str] = subprocess.run(
                    pip_command_to_run, check=True, capture_output=True, text=True
                )
                print(f"--- pip install STDOUT for {install_module} ---")
                print(install_result.stdout.strip())
                if install_result.stderr:
                    print(f"--- pip install STDERR for {install_module} ---")
                    print(install_result.stderr.strip())

                append_requirement(install_module, save_requirements_flag, requirements_file_name)
                print(f">>> Installation of {install_module} successful. Retrying script...")

            except subprocess.CalledProcessError as e:
                stderr_msg: str = f"\nStderr: {e.stderr.strip()}" if e.stderr else ""
                pip_cmd_str: str = ' '.join(venv_pip_command_list)
                raise PackageInstallationError(
                    f"Error installing module {install_module} using '{pip_cmd_str}': {e}{stderr_msg}"
                )
            continue

        elif process.returncode != 0:
            if script_started:
                print(f"\n--- Script {script_path} started but failed with exit code {process.returncode} ---")
                if script_stdout_lines:
                    print("--- Script STDOUT before failure ---")
                    print(''.join(script_stdout_lines).strip())
                    print("------------------------------------")
                raise ScriptExecutionError(f"Script failed with exit code {process.returncode}")
            else:
                raise ScriptExecutionError(f"Script failed to start or exited early with code {process.returncode}")

        else:
            print(f"\n--- Script {script_path} completed successfully ---")
            break

def clear_environment_packages(
    pip_command_list: list[str]
) -> None:
    pip_cmd_str: str = ' '.join(pip_command_list)
    print(f"Attempting to clear packages from environment using pip: {pip_cmd_str}")
    try:
        freeze_command: list[str] = pip_command_list + ["freeze"]
        freeze_result: subprocess.CompletedProcess[str] = subprocess.run(
            freeze_command,
            capture_output=True, text=True, check=True
        )

        installed_packages_lines: list[str] = freeze_result.stdout.strip().splitlines()
        installed_packages: list[str] = []

        for line in installed_packages_lines:
            line = line.strip()
            if not line or line.startswith('#') or line.startswith('-e '):
                continue
            if '==' in line:
                pkg_name: str = line.split('==')[0]
            elif ' @ ' in line:
                pkg_name = line.split(' @ ')[0]
            else:
                continue
            if pkg_name != 'pyenvrunner':
                installed_packages.append(pkg_name)

        if not installed_packages:
            print("No packages to remove from this environment (or only editable installs found).")
            return

        print(f"Found packages to remove: {', '.join(installed_packages)}")

        try:
            user_confirmation: str = input("Are you sure you want to uninstall these packages? (y/N): ")
        except EOFError:
            print("Non-interactive environment detected, cannot confirm. Aborting package clearing.")
            return
        if user_confirmation.lower() != 'y':
            print("Package clearing cancelled by user.")
            return

        uninstall_command: list[str] = pip_command_list + ["uninstall", "-y"] + installed_packages

        print(f"Running: {' '.join(uninstall_command)}")
        uninstall_result: subprocess.CompletedProcess[str] = subprocess.run(
            uninstall_command,
            capture_output=True, text=True, check=False
        )
        print("--- pip uninstall STDOUT ---")
        print(uninstall_result.stdout.strip())
        print("----------------------------")
        if uninstall_result.stderr:
            print("--- pip uninstall STDERR ---")
            print(uninstall_result.stderr.strip())
            print("----------------------------")

        if uninstall_result.returncode == 0:
            print("Environment packages cleared successfully.")
        else:
            print("Error or partial success during package clearing. Check output above.")

    except subprocess.CalledProcessError as e:
        stderr_msg: str = f"\nStderr: {e.stderr.strip()}" if e.stderr else ""
        stdout_msg: str = f"\nStdout: {e.stdout.strip()}" if e.stdout else ""
        raise PackageInstallationError(
            f"Error during environment clearing: {e}. Command: {' '.join(e.cmd)}{stdout_msg}{stderr_msg}"
        )
    except FileNotFoundError:
        raise PackageInstallationError(
            f"pip command '{pip_cmd_str}' or its components not found for clearing environment."
        )