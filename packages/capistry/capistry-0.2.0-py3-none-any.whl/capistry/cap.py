"""
Keycap shapes with customizable profiles and geometry.

This module defines classes for modeling mechanical keyboard keycaps with four
main profile types: trapezoidal, slanted, skewed, and rectangular. It supports
detailed configuration of dimensions, tapers, surface textures, and stem types.
The module leverages build123d for precise 3D geometry construction and includes
tools for creating, modifying, and analyzing keycap shapes.

Classes
-------
Cap : ABC
    Abstract base class for all keycap types with common properties and methods.
TrapezoidCap : Cap
    Keycap with trapezoidal profile defined by an angle parameter.
SlantedCap : Cap
    Keycap with slanted profile that can be mirrored by inverting the angle.
SkewedCap : Cap
    Keycap with skewed profile supporting both width and length skewing.
RectangularCap : Cap
    Basic rectangular keycap with no angular modifications.

Examples
--------
Basic rectangular cap:
>>> cap = RectangularCap(width=18, length=18, height=4)

Trapezoid shaped keycap with 15 degree angle:
>>> trapezoid = TrapezoidCap(width=18, length=18, angle=15)

Slanted keycap for thumb keys:
>>> cap = SlantedCap(width=18, length=18, angle=10)
>>> mirrored_cap = cap.mirrored()  # Create mirrored variant

Notes
-----
The `Cap` class inherits from Comparable, enabling comparing properties
of different keycaps easily. See `capistry.Comparer`.
"""

import logging
from abc import ABC, abstractmethod
from copy import copy, deepcopy
from dataclasses import dataclass, field
from functools import cached_property
from math import cos, radians, tan
from typing import Self, override

from build123d import (
    Axis,
    BoundBox,
    BuildLine,
    BuildPart,
    BuildSketch,
    Compound,
    Edge,
    Keep,
    LengthMode,
    Line,
    Location,
    Mode,
    Part,
    Plane,
    PolarLine,
    Pos,
    RigidJoint,
    Rot,
    Sketch,
    Vector,
    add,
    extrude,
    make_face,
    offset,
    split,
)

from capistry.compare import Comparable, Metric, MetricGroup, MetricLayout

from .fillet import FilletStrategy, FilletUniform
from .stem import CAP_STEM_JOINT, MXStem, Stem
from .surface import Surface
from .taper import Taper

logger = logging.getLogger(__name__)


@dataclass
class Cap(Comparable, ABC):
    """
    Abstract base class for all keycap types.

    Provides common functionality for building 3D keycap geometry including
    shell construction, inner cavity creation, stem attachment, tapering, filleting,
    and surface mapping. This class serves as the foundation for all specific
    keycap implementations.

    Parameters
    ----------
    width : float, default=18
        Width of the keycap in millimeters.
    length : float, default=18
        Length of the keycap in millimeters.
    height : float, default=4
        Total height of the keycap in millimeters. Includes roof thickness.
    wall : float, default=1
        Thickness of the keycap walls in millimeters.
    roof : float, default=1
        Thickness of the keycap top surface in millimeters (assuming no surface mapping).
    taper : Taper, default=Taper()
        Taper configuration for the keycap sides.
    surface : Surface or None, default=None
        Optional surface mapping for the keycap top.
    stem : Stem, default=MXStem()
        Stem which will be attached to the the keycap's body.
    fillet_strategy : FilletStrategy, default=FilletUniform()
        Strategy for applying fillets to the keycap geometry.

    Attributes
    ----------
    compound : Compound
        The complete 3D geometry including shell and stem as a compound object.
        Automatically built and cached when accessed.
    outline : Sketch
        2D outline sketch of the keycap base defining the footprint shape.
        Generated by subclass implementation of _draw_outline().
    top : Edge
        The top edge of the keycap outline (+Y direction).
    right : Edge
        The right edge of the keycap outline (+X direction).
    bottom : Edge
        The bottom edge of the keycap outline (-Y direction).
    left : Edge
        The left edge of the keycap outline (-X direction).
    top_left : Location
        Location of the top-left corner of the keycap outline.
    top_right : Location
        Location of the top-right corner of the keycap outline.
    bottom_left : Location
        Location of the bottom-left corner of the keycap outline.
    bottom_right : Location
        Location of the bottom-right corner of the keycap outline.
    bbox : BoundBox
        Bounding box of the complete compound including stem.
    size : Vector
        Dimensions of the bounding box as a 3D vector (width, length, height).
    metrics : MetricLayout[Self]
        Structured metrics for the keycap including dimensions and component
        properties, used for comparison.

    Examples
    --------
    Create and manipulate a basic keycap:

    >>> taper = Taper(front=1.5, back=1.0, left=1.2, right=1.2)
    >>> cap = RectangularCap(
    ...     width=18,
    ...     length=18,
    ...     height=7,
    ...     taper=taper
    ... )
    >>>
    >>> # Transform the keycap
    >>> cap.move(Pos(19, 0, 0))  # Move to the right
    >>> cap.rotate(Axis.Z, 5)    # Slight rotation
    >>>
    >>> # Create taller variant
    >>> taller_cap = cap.clone()
    >>> taller_cap.height = 9.0
    >>> taller_cap.build()
    >>>
    >>> # Move taller keycap next to the first one
    >>> taller_cap.locate(Rot(0, 0, 5) * cap.top_right) # Rotate then move

    Notes
    -----
    This is an abstract base class and cannot be instantiated directly.
    Use concrete implementations like RectangularCap, TrapezoidCap, etc.

    The geometry building process is triggered automatically in the __post_init__ method,
    but can be manually triggered with the build() method if parameters are changed.
    """

    width: float = 18
    length: float = 18
    height: float = 4
    wall: float = 1
    roof: float = 1

    taper: Taper = field(default_factory=Taper)
    surface: Surface | None = None

    stem: Stem = field(default_factory=MXStem)
    fillet_strategy: FilletStrategy = field(default_factory=FilletUniform)

    def __post_init__(self) -> None:
        """
        Build the keycap after dataclass construction.

        This method is automatically called after the dataclass is initialized.
        It creates a copy of the stem to avoid sharing location references and
        triggers the initial build process.
        """
        self.stem = copy(self.stem)
        _ = self.build()

    @abstractmethod
    def _draw_outline(self) -> Sketch:
        """
        Draw the 2D outline of the keycap base shape.

        This abstract method must be implemented by subclasses to define
        the specific shape profile of the keycap. The outline defines the
        base footprint that will be extruded to create the 3D geometry.

        Returns
        -------
        Sketch
            2D sketch defining the keycap's base outline. The sketch should
            be oriented with the top edge in the +Y direction and right edge
            in the +X direction.

        Notes
        -----
        The outline should be a closed profile suitable for extrusion.
        The coordinate system assumes (0,0) as the top-left corner.
        """

    def build(self) -> Self:
        """
        Build the complete keycap geometry.

        Clears cached properties and triggers geometry construction by accessing
        the compound property. This is a convenience method for manual rebuilds
        after parameter changes.

        Returns
        -------
        Self
            The keycap instance with built geometry for method chaining.

        Notes
        -----
        This method clears all cached properties to ensure fresh geometry
        construction. It's automatically called during initialization but
        should be called manually if parameters are modified after creation.
        The actual geometry construction and error handling occurs in the
        compound property.
        """
        self._clear_cache()
        _ = self.compound
        logger.debug("Successfully built %s", type(self).__name__)
        return self

    def _clear_cache(self):
        """Clear cached geometry properties."""
        for attr in ("compound", "outline"):
            if attr in self.__dict__:
                delattr(self, attr)

    @cached_property
    def compound(self) -> Compound:
        """
        Build and return the complete 3D keycap geometry.

        This cached property constructs the full keycap including shell,
        inner cavity, fillets, and attached stem as a compound object.
        The compound is built once and cached until it's been cleared
        by _clear_cache() via build().

        Returns
        -------
        Compound
            Complete keycap geometry with shell and stem components.

        Raises
        ------
        Exception
            If geometry construction fails during any stage of the build process.
            The original exception is re-raised with additional context about
            which keycap type failed to build.

        Notes
        -----
        A manual rebuild of this property can be triggered by calling `capistry.Cap.build`.
        """
        logger.info(
            "Creating part geometry for %s",
            type(self).__name__,
            extra={"dimensions": {"w": self.width, "l": self.length, "h": self.height}},
        )

        try:
            with BuildPart() as cap:
                self._build_shell(cap)
                self._build_inner(cap)
                self.fillet_strategy.apply_skirt(cap)
                self._attach_stem(cap)

            cap.part.label = "Shell"
            logger.debug("Finished building part geometry")

            return Compound(label=str(self), children=[cap.part, self.stem])

        except Exception as e:
            logger.exception(
                "Failed to build %s geometry",
                type(self).__name__,
                exc_info=e,
            )
            raise

    @cached_property
    def outline(self) -> Sketch:
        """
        Get the 2D outline sketch of the keycap.

        This cached property returns the 2D outline defining the keycap's
        base shape. The outline is built once and cached until it's been cleared
        by _clear_cache() via build().

        Returns
        -------
        Sketch
            2D outline defining the keycap's base shape. The sketch is
            oriented with the top edge in the +Y direction and right edge
            in the +X direction.

        Notes
        -----
        The outline computation is delegated to the abstract _draw_outline()
        method which must be implemented by subclasses to define the specific
        keycap shape profile.

        A manual rebuild of this property can be triggered by calling `capistry.Cap.build`.
        """
        return self._draw_outline()

    @property
    def top(self) -> Edge:
        """
        Get the top edge of the keycap outline.

        Returns
        -------
        Edge
            Top edge in the +Y direction, transformed by the compound location.
        """
        return self.compound.location * self.outline.edges()[0]

    @property
    def right(self) -> Edge:
        """
        Get the right edge of the keycap outline.

        Returns
        -------
        Edge
            Right edge in the +X direction, transformed by the compound location.
        """
        return self.compound.location * self.outline.edges()[1]

    @property
    def bottom(self) -> Edge:
        """
        Get the bottom edge of the keycap outline.

        Returns
        -------
        Edge
            Bottom edge in the -Y direction, transformed by the compound location.
        """
        return self.compound.location * self.outline.edges()[2]

    @property
    def left(self) -> Edge:
        """
        Get the left edge of the keycap outline.

        Returns
        -------
        Edge
            Left edge in the -X direction, transformed by the compound location.
        """
        return self.compound.location * self.outline.edges()[3]

    @property
    def top_left(self) -> Location:
        """
        Get the top-left corner location of the keycap outline.

        Returns
        -------
        Location
            Location of the top-left corner.
        """
        return Pos(self.top @ 0)

    @property
    def top_right(self) -> Location:
        """
        Get the top-right corner location of the keycap outline.

        Returns
        -------
        Location
            Location of the top-right corner.
        """
        return Pos(self.top @ 1)

    @property
    def bottom_right(self) -> Location:
        """
        Get the bottom-right corner location of the keycap outline.

        Returns
        -------
        Location
            Location of the bottom-right corner.
        """
        return Pos(self.bottom @ 0)

    @property
    def bottom_left(self) -> Location:
        """
        Get the bottom-left corner location of the keycap outline.

        Returns
        -------
        Location
            Location of the bottom-left corner.
        """
        return Pos(self.bottom @ 1)

    @property
    def bbox(self) -> BoundBox:
        """
        Get the bounding box of the complete keycap geometry.

        Returns
        -------
        BoundBox
            Bounding box encompassing the entire compound including stem.
        """
        return self.compound.bounding_box()

    @property
    def size(self) -> Vector:
        """
        Get the dimensions of the keycap bounding box.

        Returns
        -------
        Vector
            Size vector containing width, length, and height dimensions.
        """
        return self.bbox.size

    def _build_inner(self, p: BuildPart) -> None:
        """
        Build the inner cavity of the keycap.

        Creates the hollow interior by subtracting a smaller version of the
        keycap shape from the solid shell. The cavity size is determined by
        the wall thickness parameter.

        Parameters
        ----------
        p : BuildPart
            The build context for part construction operations.

        Notes
        -----
        The cavity height is calculated as total height minus roof thickness.
        The cavity walls are inset by the wall thickness parameter.
        """
        height = self.height - self.roof
        off = -self.wall

        logger.debug("Subtracting inner cavity")
        self._build_skeleton(height, off=off, mode=Mode.SUBTRACT)

        self.fillet_strategy.apply_inner(p)

    def _build_skeleton(
        self,
        height: float,
        off: float = 0,
        mode: Mode = Mode.PRIVATE,
    ) -> Part:
        """
        Build the basic skeleton shape with optional offset.

        Creates the fundamental extruded shape of the keycap with optional
        outline offset and taper application. This method is used for both
        the outer shell and inner cavity construction.

        Parameters
        ----------
        height : float
            Height of the extruded shape in millimeters.
        off : float, default=0
            Offset amount for the outline in millimeters. Positive values
            expand the outline, negative values contract it.
        mode : Mode, default=Mode.PRIVATE
            Build mode for the operation (ADD, SUBTRACT, or PRIVATE).

        Returns
        -------
        Part
            The constructed extruded and tapered part.

        Notes
        -----
        The taper is applied to each face according to the taper configuration.
        Faces are automatically identified and sorted by their orientations.
        Zero or negative taper values are skipped.
        """
        logger.debug("Building skeleton", extra={"h": height, "offset": off})

        with BuildPart() as p:
            offset(objects=self.outline, amount=off, mode=Mode.ADD)
            extrude(amount=height)

            faces = p.part.faces().filter_by(Axis.Z, reverse=True)
            front, back = faces.sort_by(Axis.X)[1:3].sort_by(Axis.Y)
            left, right = faces.sort_by(Axis.Y)[1:3].sort_by(Axis.X)

            taper_by_face = {
                front: self.taper.front,
                back: self.taper.back,
                left: self.taper.left,
                right: self.taper.right,
            }

            logger.debug("Applying taper", extra={"taper": self.taper})

            for f, taper in taper_by_face.items():
                if taper <= 0:
                    continue

                edge = f.edges().sort_by()[0]
                cut = f.rotate(Axis(origin=edge @ 1, direction=edge % 1), taper)
                split(p.part, bisect_by=Plane(cut), keep=Keep.BOTTOM)

        add(p, mode=mode)
        return p.part

    def _build_shell(self, p: BuildPart) -> None:
        """
        Build the outer shell of the keycap.

        Creates the main solid body of the keycap by extruding the outline
        to the full height and applying any surface mapping if configured.

        Parameters
        ----------
        p : BuildPart
            The build context for part construction operations.
        """
        logger.debug("Building outer shell")
        outer = self._build_skeleton(self.height)

        if self.surface is not None:
            outer = self._apply_surface_map(p)

        add(outer)
        self.fillet_strategy.apply_outer(p)

    def _attach_stem(self, p: BuildPart) -> None:
        """
        Attach the stem to the keycap.

        Positions and connects the stem component to the bottom center of
        the keycap using a rigid joint connection. The stem is oriented
        upward into the keycap cavity.

        Parameters
        ----------
        p : BuildPart
            The build context containing the keycap shell geometry.

        Notes
        -----
        The stem position is calculated based on the outline center and
        the inner cavity face of the keycap. The connection uses a rigid joint
        with 180-degree X rotation to orient the stem correctly.
        """
        logger.info("Attaching %s to %s", type(self.stem).__name__, type(self).__name__)

        bottomf = self.outline.faces()[0]
        topf = p.faces().filter_by(Axis.Z).sort_by(Axis.Z)[1]

        loc = bottomf.center(self.stem.center_at)
        loc.Z += topf.distance_to(loc)

        joint = RigidJoint(
            label=CAP_STEM_JOINT,
            joint_location=Pos(loc) * Rot(X=180) * self.stem.offset,
        )

        joint.connect_to(self.stem.joint)

    def _apply_surface_map(self, _: BuildPart) -> Part:
        """
        Apply surface mapping to the keycap top.

        Modifies the top surface of the keycap according to the configured
        surface mapping.

        Parameters
        ----------
        _ : BuildPart
            The build context (unused in current implementation).

        Returns
        -------
        Part
            The part with applied surface mapping modifications.

        Raises
        ------
        TypeError
            If the split operation doesn't return a Part object as expected.

        Notes
        -----
        The surface mapping process involves creating an extended geometry
        and splitting it with the surface shape to achieve the desired
        top surface profile.
        """
        logger.debug("Applying surface map to %s", type(self).__name__)

        bottom = self._build_skeleton(self.height - self.roof)
        bottomf = bottom.faces().sort_by(Axis.Z)[-1]

        surfacef = -self.surface.form_face(bottomf.vertices())

        height = surfacef.bounding_box().max.Z + self.roof + 10
        extended_part = self._build_skeleton(height)

        res = split(
            extended_part,
            bisect_by=Pos(0, 0, self.roof) * surfacef,
            keep=Keep.TOP,
            mode=Mode.PRIVATE,
        )

        if not isinstance(res, Part):
            raise TypeError(f"Expected Part from split operation, got {type(res)}")
        return res

    def clone(self) -> Self:
        """
        Create a deep copy of the keycap.

        Returns
        -------
        Self
            A new keycap instance with identical parameters but independent
            geometry that can be modified without affecting the original.
        """
        cloned = deepcopy(self)
        logger.debug("Created clone of %s", type(self).__name__)
        return cloned

    def mirrored(self) -> Self:
        """
        Create a mirrored (XY-axis) version of the keycap.

        Produces a mirror-image copy of the keycap, useful for creating
        left/right pairs or opposite-handed versions of asymmetric keycaps.

        Returns
        -------
        Self
            A new mirrored keycap instance with geometry rebuilt.

        Notes
        -----
        The mirroring behavior is implemented by subclasses in the _mirror()
        method. Some keycap types may not change when mirrored (e.g., symmetric
        rectangular caps), while others will have their angles or skews inverted.
        """
        m = self.clone()
        m._mirror()
        if m.surface is not None:
            m.surface = m.surface.mirrored()
        m.build()
        logger.debug("Created mirrored clone of %s", type(self).__name__)
        return m

    def _mirror(self) -> Self:
        """
        Apply mirroring transformation to the keycap.

        Base implementation does nothing since rectangular caps are symmetric.
        Subclasses should override this method to implement specific mirroring
        behavior such as inverting angles or skew parameters.

        Returns
        -------
        Self
            The keycap instance after applying mirroring transformations.

        Notes
        -----
        This method modifies the keycap parameters in-place. It is called
        by the mirrored() method as part of the cloning process.
        """
        logger.debug("Mirroring %s with no changes", type(self).__name__)
        return self

    def locate(self, loc: Location) -> Self:
        """
        Set the absolute location of the keycap.

        Moves the keycap to the specified absolute position and orientation
        in 3D space, replacing any previous transformations.

        Parameters
        ----------
        loc : Location
            The target absolute location including position and rotation.

        Returns
        -------
        Self
            The keycap instance at the new location for method chaining.

        Examples
        --------
        >>> cap.locate(Pos(10, 20, 5) * Rot(0, 0, 45))
        """
        logger.debug(
            "Applying absolute location to %s",
            type(self).__name__,
            extra={"location": loc},
        )
        self.compound.locate(loc)
        return self

    def rotate(self, axis: Axis, angle: float) -> Self:
        """
        Rotate the keycap around an axis.

        Applies a rotation transformation around the specified axis by the
        given angle. This is a relative transformation that combines with
        existing rotations.

        Parameters
        ----------
        axis : Axis
            The rotation axis (e.g., Axis.X, Axis.Y, Axis.Z).
        angle : float
            Rotation angle in degrees. Positive values follow right-hand rule.

        Returns
        -------
        Self
            The rotated keycap instance for method chaining.

        Examples
        --------
        >>> cap.rotate(Axis.Z, 10)  # Rotate 10 degrees around Z-axis
        """
        logger.debug("Rotating %s", type(self).__name__, extra={"axis": axis, "angle": angle})
        self.compound.rotate(axis, angle)
        return self

    def move(self, loc: Location) -> Self:
        """
        Apply relative movement to the keycap.

        Moves the keycap by the specified relative offset, adding to any
        existing position. This is useful for incremental positioning.

        Parameters
        ----------
        loc : Location
            The relative movement location.

        Returns
        -------
        Self
            The moved keycap instance for method chaining.

        Examples
        --------
        >>> cap.move(Pos(5, 0, 0))  # Move 5mm in X direction
        >>> cap.move(Pos(0, 0, -2) * Rot(Y=10))  # Move down and tilt
        """
        logger.debug(
            "Applying relative location to %s",
            type(self).__name__,
            extra={"location": loc},
        )
        self.compound.move(loc)
        return self

    @override
    def __str__(self) -> str:
        """
        Return string representation of the keycap.

        Returns
        -------
        str
            Human-readable string with class name and dimensions.
        """
        return f"{type(self).__name__} ({self.width:.2f}x{self.length:.2f})"

    def __copy__(self) -> Self:
        """Create a shallow copy of the keycap."""
        cls = type(self)
        result = cls.__new__(cls)

        for k, v in self.__dict__.items():
            result.__dict__[k] = copy(v)

        return result

    def __deepcopy__(self, memo: dict) -> Self:
        """Create a deep copy of the keycap."""
        cls = type(self)
        obj = cls.__new__(cls)
        memo[id(self)] = obj

        for k, v in self.__dict__.items():
            setattr(obj, k, deepcopy(v, memo))

        return obj

    @property
    def metrics(self) -> MetricLayout[Self]:
        """
        Expose keycap dimensions through the `capistry.Comparable` system for comparison.

        Metrics include keycap dimensions combined with those from comparable
        class fields such as taper, surface, fillet_strategy, and stem.

        Returns
        -------
        MetricLayout[Self]
            Organized metrics including dimensions and component properties
            for comparison.
        """
        return MetricLayout(
            owner=self,
            groups=(
                MetricGroup(
                    "Dimensions",
                    (
                        Metric("Width", lambda: self.width, "mm"),
                        Metric("Length", lambda: self.length, "mm"),
                        Metric("Height", lambda: self.height, "mm"),
                        Metric("Wall", lambda: self.wall, "mm"),
                        Metric("Roof", lambda: self.roof, "mm"),
                    ),
                    order=-2,
                ),
                *MetricGroup.from_comparables(
                    self.taper, self.surface, self.fillet_strategy, self.stem
                ),
            ),
        )


@dataclass
class TrapezoidCap(Cap):
    """
    Keycap with trapezoidal profile.

    A symmetric keycap where the top surface is wider than the base, with the width
    expansion determined by the angle parameter.

    Parameters
    ----------
    angle : float, default=0
        Angle in degrees defining the trapezoid slope. Positive values
        create wider tops, zero creates rectangular profile. The angle
        determines how much the top edge expands beyond the base width.

    Attributes
    ----------
    All attributes inherited from Cap, plus:

    angle : float
        The trapezoid angle in degrees.
    metrics : MetricLayout[Self]
        Extended metrics including the trapezoid angle parameter.
    """

    angle: float = 0

    def __post_init__(self) -> None:
        """Initialize the trapezoid keycap with logging."""
        logger.info("Creating %s", type(self).__name__, extra={"angle": self.angle})
        return super().__post_init__()

    @override
    def _draw_outline(self) -> Sketch:
        """
        Draw the trapezoidal outline.

        Creates a symmetric trapezoid where the top edge is wider than the
        bottom edge by an amount determined by the angle parameter.

        Returns
        -------
        Sketch
            2D sketch of the trapezoidal outline.

        Notes
        -----
        The trapezoid is constructed with the bottom edge as the base and
        the top edge expanded symmetrically on both sides.
        """
        logger.debug("Drawing outline of %s", type(self).__name__)

        width_top = 2 * self.length * tan(radians(self.angle)) + self.width

        with BuildSketch():
            with BuildLine():
                l1 = Line((0, 0), (width_top, 0))
                l2 = PolarLine(
                    start=l1 @ 1,
                    length=-self.length,
                    angle=90 - self.angle,
                    length_mode=LengthMode.VERTICAL,
                )
                l3 = Line(l2 @ 1, ((l2 @ 1) - Vector(self.width)))
                Line(l3 @ 1, l1 @ 0)
            return make_face()

    @property
    @override
    def metrics(self) -> MetricLayout[Self]:
        """
        Expose metrics including trapezoid angle.

        Returns
        -------
        MetricLayout[Self]
            Metrics with trapezoid-specific parameters.
        """
        return MetricLayout(
            owner=self,
            groups=(
                MetricGroup(
                    "Trapezoid", metrics=(Metric("Angle", lambda: self.angle, "°"),), order=-1
                ),
                *super().metrics.groups,
            ),
        )

    @override
    def __str__(self) -> str:
        """Return string representation including angle."""
        return f"{super().__str__()} ({self.angle}°)"


@dataclass
class SlantedCap(Cap):
    """
    Keycap with slanted profile.

    A keycap where one side is angled relative to the other, creating an
    asymmetric profile. This design is commonly used for thumb keys or
    ergonomic layouts where the key needs to match the natural arc of the thumbs.

    Parameters
    ----------
    angle : float, default=0
        Angle in degrees defining the slant direction and magnitude.
        Positive values slant toward the bottom-right, negative values
        slant toward the bottom-left. Zero creates a rectangular profile.

    Attributes
    ----------
    All attributes inherited from Cap, plus:

    angle : float
        The slant angle in degrees.
    metrics : MetricLayout[Self]
        Extended metrics including the slant angle parameter.

    Examples
    --------
    Create slanted thumb caps:

    >>> left_thumb = SlantedCap(width=18, length=18, angle=-10)
    >>> right_thumb = left_thumb.mirrored()  # Creates +10° angle

    Create a set of slanted caps:

    >>> angles = [-5, -2.5, 0, 2.5, 5]
    >>> caps = [SlantedCap(angle=a) for a in angles]

    Notes
    -----
    The slant affects the top width calculation and creates an asymmetric
    profile. Mirroring inverts the angle sign to create opposite-handed versions.
    """

    angle: float = 0

    def __post_init__(self) -> None:
        """Initialize the slanted keycap."""
        super().__post_init__()

    @override
    def _draw_outline(self) -> Sketch:
        """
        Draw the slanted outline.

        Creates an asymmetric quadrilateral where one side is angled
        relative to the vertical, creating the slanted profile.

        Returns
        -------
        Sketch
            2D sketch of the slanted outline.

        Notes
        -----
        The slant is applied by modifying the top edge position and
        adjusting the side angles accordingly. Positive angles create
        a rightward slant, negative angles create a leftward slant.
        """
        logger.debug("Drawing outline of %s", type(self).__name__, extra={"angle": self.angle})

        width_top = (
            self.width / cos(radians(self.angle)) + tan(radians(abs(self.angle))) * self.length
        )

        with BuildSketch() as sk:
            with BuildLine():
                l1 = Line((0, 0), (width_top, 0))

                _l2 = Line(l1 @ 1, (width_top, -self.length), mode=Mode.PRIVATE)
                _l3 = PolarLine(
                    start=_l2 @ 1,
                    length=self.width,
                    angle=180 + abs(self.angle),
                    mode=Mode.PRIVATE,
                )

                l2, l3 = _l2, _l3

                if self.angle <= 0:
                    add([l2, l3])
                else:
                    l2 = Line(l1 @ 1, (width_top - (_l3 @ 1).X, (_l3 @ 1).Y))
                    l3 = Line(l2 @ 1, (width_top - (_l2 @ 1).X, (_l2 @ 1).Y))

                Line(l3 @ 1, l1 @ 0)
            make_face()

        return sk.sketch

    @override
    def _mirror(self) -> Self:
        """
        Apply mirroring by inverting the slant angle.

        Returns
        -------
        Self
            The keycap with inverted angle for mirroring effect.

        Notes
        -----
        Mirroring a slanted cap simply inverts the angle sign,
        creating the opposite-handed version.
        """
        logger.debug(
            "Mirroring %s by inverting angle",
            type(self).__name__,
            extra={"angle": self.angle, "new_angle": -self.angle},
        )
        self.angle *= -1
        return self

    @override
    def __str__(self) -> str:
        """Return string representation including angle."""
        return f"{super().__str__()} ({self.angle}°)"

    @property
    @override
    def metrics(self) -> MetricLayout[Self]:
        """
        Expose metrics including slant angle.

        Returns
        -------
        MetricLayout[Self]
            Metrics with slant-specific parameters.
        """
        return MetricLayout(
            owner=self,
            groups=(
                MetricGroup("Slant", metrics=(Metric("Angle", lambda: self.angle, "°"),), order=-1),
                *super().metrics.groups,
            ),
        )


@dataclass
class SkewedCap(Cap):
    """
    Keycap with skewed profile.

    A keycap where the outline is skewed at an angle, creating
    a parallelogram-like profile. The skew can be applied while maintaining
    a width based on the length of the bottom/top edge, or by basing the width
    on the perpendicular length between the two vertical sides.

    Parameters
    ----------
    skew : float, default=0
        Skew angle in degrees. Positive values skew toward the right,
        negative values skew toward the left. Zero creates rectangular profile.
    skew_width : bool, default=True
        If True, the width is kept as the length of the bottom/top edge.
        If False, the width is the perpendicular distance between left and right edges.

    Attributes
    ----------
    All attributes inherited from Cap, plus:

    skew : float
        The skew angle in degrees.
    skew_width : bool
        Whether width is maintained during skewing.
    metrics : MetricLayout[Self]
        Extended metrics including skew parameters.

    Examples
    --------
    Create skewed key with width compensation:

    >>> compensated = SkewedCap(skew=20, skew_width=False)
    """

    skew: float = 0
    skew_width: bool = True

    def __post_init__(self) -> None:
        """
        Initialize the skewed keycap with width adjustment if needed.

        Notes
        -----
        If skew_width is False, the width is divided by cos(skew) to
        compensate for the skewing transformation.
        """
        if not self.skew_width:
            self.width /= cos(radians(self.skew))

        return super().__post_init__()

    @override
    def _draw_outline(self) -> Sketch:
        """
        Draw the skewed outline.

        Creates a parallelogram where the vertical edges are skewed
        at the specified angle while maintaining parallel relationships.

        Returns
        -------
        Sketch
            2D sketch of the skewed outline.
        """
        logger.debug("Drawing outline of %s", type(self).__name__, extra={"skew": self.skew})

        with BuildSketch():
            with BuildLine():
                l1 = PolarLine(
                    start=(0, 0),
                    length=self.width,
                    angle=-self.skew,
                    length_mode=LengthMode.HORIZONTAL,
                )
                l2 = Line(l1 @ 1, l1 @ 1 - (0, self.length))
                l3 = Line(l2 @ 1, l1 @ 0 - (0, self.length))
                Line(l3 @ 1, l1 @ 0)
            return make_face()

    @override
    def _mirror(self) -> Self:
        """
        Apply mirroring by inverting the skew angle.

        Returns
        -------
        Self
            The keycap with inverted skew for mirroring effect.

        Notes
        -----
        Mirroring a skewed cap inverts the skew angle sign,
        creating the opposite-handed version.
        """
        logger.debug(
            "Mirroring %s by inverting",
            type(self).__name__,
            extra={"skew": self.skew, "new_skew": -self.skew},
        )
        self.skew *= -1
        return self

    @property
    @override
    def metrics(self) -> MetricLayout[Self]:
        """
        Expose metrics including skew parameters.

        Returns
        -------
        MetricLayout[Self]
            Metrics with skew-specific parameters.
        """
        return MetricLayout(
            owner=self,
            groups=(
                MetricGroup(
                    "Skew",
                    metrics=(
                        Metric("Angle", lambda: self.skew, "°"),
                        Metric("Skewed Width", lambda: self.skew_width, ""),
                    ),
                    order=-1,
                ),
                *super().metrics.groups,
            ),
        )

    def __str__(self) -> str:
        """Return string representation including skew angle."""
        return f"{super().__str__()} ({self.skew}°)"


@dataclass
class RectangularCap(Cap):
    """
    Basic rectangular keycap with no angular modifications.

    The simplest keycap implementation with a standard rectangular profile.
    The shape is completely symmetric with straight vertical sides and no
    angular modifications.

    Examples
    --------
    Create a standard keycap:

    >>> cap = RectangularCap()  # Uses default 18x18x4mm dimensions

    Create a larger keycap for special keys:

    >>> spacebar = RectangularCap(width=18 * 6.25  - 1)
    """

    def __post_init__(self) -> None:
        """Initialize the rectangular keycap."""
        return super().__post_init__()

    def _draw_outline(self) -> Sketch:
        """
        Draw a simple rectangular outline.

        Creates a basic rectangle with the specified width and length
        dimensions, with the top-left corner at the origin.

        Returns
        -------
        Sketch
            2D sketch of the rectangular outline.
        """
        logger.debug("Drawing outline of %s", type(self).__name__)

        with BuildSketch():
            with BuildLine():
                l1 = Line((0, 0), (self.width, 0))
                l2 = Line(l1 @ 1, l1 @ 1 - (0, self.length))
                l3 = Line(l2 @ 1, l1 @ 0 - (0, self.length))
                Line(l3 @ 1, l1 @ 0)
            return make_face()
