"""
Модуль для работы с встроенным словарем словарей.
"""

# Встроенный словарь библиотеки
LIBRARY_DATA = {
    "3": {
        "1": """ 
            import numpy as np
            
            def functional_iteration(g, x0, tol=1e-5, max_iter=100):
                # Метод функциональной итерации для решения уравнения x = g(x)
                x = x0
                for i in range(max_iter):
                    x_new = g(x)
                    if np.isnan(x_new) or np.isinf(x_new):
                        print(f"Ошибка: итерация {i+1} привела к NaN или inf. Прерывание.")
                        return None, i + 1
                    if abs(x_new - x) < tol:
                        return x_new, i + 1
                    x = x_new
                print(f"Предупреждение: Достигнут максимум итераций ({max_iter}).")
                return x_new, max_iter

            # Исходное уравнение: x^2 - ln(x) - 1 = 0
            # Перепишем в виде x = g(x)
            g1 = lambda x: np.sqrt(np.log(x) + 1)  # Первый вариант функции итерации
            # Второй вариант: используем другую форму, чтобы избежать переполнения
            g2 = lambda x: (x**2 + 1 - np.log(x)) / 2  # Модифицированная функция для сходимости

            # Начальное приближение
            x0 = 1.5

            # Решение первым вариантом
            sol1, iter1 = functional_iteration(g1, x0)
            if sol1 is not None:
                print(f"Решение g1: x = {sol1:.6f}, итераций: {iter1}")
                print(f"Проверка для g1: f(x) = {sol1**2 - np.log(sol1) - 1:.2e}")

            # Решение вторым вариантом
            sol2, iter2 = functional_iteration(g2, x0)
            if sol2 is not None:
                print(f"Решение g2: x = {sol2:.6f}, итераций: {iter2}")
                print(f"Проверка для g2: f(x) = {sol2**2 - np.log(sol2) - 1:.2e}")   
                
            __________________________
            
            Теоретические ответы:

            Выбор g(x) влияет на сходимость через константу Липшица - если |g'(x)| < 1 в окрестности решения, метод сходится.

            Сравнение методов:

            Функциональная итерация: O(n) операций на шаг, устойчив при |g'(x)| < 1

            Метод секущих: O(1) операций на шаг, но может расходиться

            Предпочтительнее когда легко выделить g(x) с малой константой Липшица

            Пример эффективного применения: x = cos(x)     
        """,
        "2": """
            import numpy as np

            def power_method(A, x0, tol=1e-4, max_iter=100):
                # Метод степеней для нахождения наибольшего собственного значения

                x = x0
                for i in range(max_iter):
                    Ax = A @ x
                    x_new = Ax / np.linalg.norm(Ax)
                    # Используем отношение Релея для оценки собственного значения
                    lambda_est = (x_new.T @ A @ x_new) / (x_new.T @ x_new)
                    if np.linalg.norm(x_new - x) < tol:
                        break
                    x = x_new
                return lambda_est, i+1

            # Матрица A
            A = np.array([
                [5, 1, 2, 3, 4],
                [1, 6, 10, 11, 12],
                [2, 10, 7, 13, 14],
                [3, 11, 13, 8, 15],
                [4, 12, 14, 15, 9]
            ])

            # Начальный вектор
            x0 = np.ones(5)

            # Нахождение собственного значения
            lambda_max, iterations = power_method(A, x0)

            print(f"Наибольшее собственное значение: {lambda_max:.6f}")
            print(f"Количество итераций: {iterations}")
            
            __________________________
            
            Теоретические ответы:

            Метод степеней использует итерации Axₖ/||Axₖ|| для нахождения доминирующего собственного вектора

            Отношение Релея λ = (xᵀAx)/(xᵀx) дает более точную оценку собственного значения

            Сходимость зависит от отношения |λ₂/λ₁| - чем оно меньше, тем быстрее сходимость

            Сдвиги позволяют находить другие собственные значения и ускорять сходимость
        """,
        "3": """
            import numpy as np
            import matplotlib.pyplot as plt

            # Правая часть уравнения
            def f(t, y):
                return 0.5 * y * (1 - y/2)

            # Метод Эйлера
            def euler_method(f, t0, y0, h, n):
                t = np.zeros(n+1)
                y = np.zeros(n+1)
                t[0], y[0] = t0, y0
                for i in range(n):
                    y[i+1] = y[i] + h * f(t[i], y[i])
                    t[i+1] = t[i] + h
                return t, y

            # Метод Рунге-Кутты 4-го порядка
            def rk4_method(f, t0, y0, h, n):
                t = np.zeros(n+1)
                y = np.zeros(n+1)
                t[0], y[0] = t0, y0
                for i in range(n):
                    k1 = h * f(t[i], y[i])
                    k2 = h * f(t[i] + h/2, y[i] + k1/2)
                    k3 = h * f(t[i] + h/2, y[i] + k2/2)
                    k4 = h * f(t[i] + h, y[i] + k3)
                    y[i+1] = y[i] + (k1 + 2*k2 + 2*k3 + k4)/6
                    t[i+1] = t[i] + h
                return t, y

            # Параметры решения
            t0, y0 = 0, 0.1
            t_end = 5
            h = 0.1
            n = int((t_end - t0)/h)

            # Решение разными методами
            t_euler, y_euler = euler_method(f, t0, y0, h, n)
            t_rk4, y_rk4 = rk4_method(f, t0, y0, h, n)

            # Визуализация
            plt.figure(figsize=(10, 6))
            plt.plot(t_euler, y_euler, label='Метод Эйлера')
            plt.plot(t_rk4, y_rk4, label='Рунге-Кутта 4-го порядка')
            plt.xlabel('Время')
            plt.ylabel('y(t)')
            plt.title('Решение ОДУ разными методами')
            plt.legend()
            plt.grid()
            plt.show()
            
            __________________________
            
            Теоретические ответы:

            Теоретические ответы:

            Согласованность - метод аппроксимирует ОДУ при h→0

            Устойчивость - ошибки не нарастают неограниченно

            Сходимость требует и согласованности, и устойчивости

            Ошибки округления в методе Эйлера могут вызывать:

            Накопление ошибок на больших интервалах

            Потерю монотонности решения

            Нефизичные колебания
        """
    },
    "настройки": {
        "язык": "русский",
        "тема": "темная",
        "уведомления": "включены",
        "автосохранение": "каждые 5 минут",
        "безопасность": "высокая"
    },
    "города": {
        "москва": "Москва - столица России",
        "питер": "Санкт-Петербург - северная столица",
        "казань": "Казань - столица Татарстана",
        "новосибирск": "Новосибирск - крупнейший город Сибири",
        "екатеринбург": "Екатеринбург - столица Урала"
    },
    "предметы": {
        "математика": "Царица наук",
        "физика": "Изучение природы",
        "химия": "Наука о веществах",
        "биология": "Наука о живом",
        "история": "Изучение прошлого"
    },
    "животные": {
        "кот": "Домашний питомец",
        "собака": "Лучший друг человека",
        "попугай": "Говорящая птица",
        "рыбка": "Аквариумный житель",
        "хомяк": "Маленький грызун"
    }
}

def get_value(key1, key2):
    """
    Получает значение из встроенного словаря библиотеки по двум ключам.
    
    Args:
        key1 (str): Первый ключ (категория)
        key2 (str): Второй ключ (элемент в категории)
    
    Returns:
        str: Значение по пути [key1][key2] из встроенного словаря
    
    Raises:
        KeyError: Если один из ключей не найден
        TypeError: Если ключи не являются строками
    """
    if not isinstance(key1, str) or not isinstance(key2, str):
        raise TypeError("Ключи должны быть строками")
    
    if key1 not in LIBRARY_DATA:
        available_keys = list(LIBRARY_DATA.keys())
        raise KeyError(f"Категория '{key1}' не найдена. Доступные категории: {available_keys}")
    
    if key2 not in LIBRARY_DATA[key1]:
        available_keys = list(LIBRARY_DATA[key1].keys())
        raise KeyError(f"Элемент '{key2}' не найден в категории '{key1}'. Доступные элементы: {available_keys}")
    
    return LIBRARY_DATA[key1][key2]

def get_categories():
    """
    Возвращает список всех доступных категорий.
    
    Returns:
        list: Список категорий (первых ключей)
    """
    return list(LIBRARY_DATA.keys())

def get_items_in_category(category):
    """
    Возвращает список всех элементов в указанной категории.
    
    Args:
        category (str): Название категории
    
    Returns:
        list: Список элементов в категории
    
    Raises:
        KeyError: Если категория не найдена
    """
    if category not in LIBRARY_DATA:
        available_keys = list(LIBRARY_DATA.keys())
        raise KeyError(f"Категория '{category}' не найдена. Доступные категории: {available_keys}")
    
    return list(LIBRARY_DATA[category].keys()) 