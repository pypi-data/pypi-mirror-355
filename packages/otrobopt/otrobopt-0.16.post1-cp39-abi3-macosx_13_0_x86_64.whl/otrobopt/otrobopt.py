# This file was automatically generated by SWIG (https://www.swig.org).
# Version 4.3.1
#
# Do not make changes to this file unless you know what you are doing - modify
# the SWIG interface file instead.

"""otrobopt module"""

from sys import version_info as _swig_python_version_info
# Import the low-level C/C++ module
if __package__ or "." in __name__:
    from . import _otrobopt
else:
    import _otrobopt

try:
    import builtins as __builtin__
except ImportError:
    import __builtin__

def _swig_repr(self):
    try:
        strthis = "proxy of " + self.this.__repr__()
    except __builtin__.Exception:
        strthis = ""
    return "<%s.%s; %s >" % (self.__class__.__module__, self.__class__.__name__, strthis,)


def _swig_setattr_nondynamic_instance_variable(set):
    def set_instance_attr(self, name, value):
        if name == "this":
            set(self, name, value)
        elif name == "thisown":
            self.this.own(value)
        elif hasattr(self, name) and isinstance(getattr(type(self), name), property):
            set(self, name, value)
        else:
            raise AttributeError("You cannot add instance attributes to %s" % self)
    return set_instance_attr


def _swig_setattr_nondynamic_class_variable(set):
    def set_class_attr(cls, name, value):
        if hasattr(cls, name) and not isinstance(getattr(cls, name), property):
            set(cls, name, value)
        else:
            raise AttributeError("You cannot add class attributes to %s" % cls)
    return set_class_attr


def _swig_add_metaclass(metaclass):
    """Class decorator for adding a metaclass to a SWIG wrapped class - a slimmed down version of six.add_metaclass"""
    def wrapper(cls):
        return metaclass(cls.__name__, cls.__bases__, cls.__dict__.copy())
    return wrapper


class _SwigNonDynamicMeta(type):
    """Meta class to enforce nondynamic attributes (no new attributes) for a class"""
    __setattr__ = _swig_setattr_nondynamic_class_variable(type.__setattr__)


import openturns.base
import openturns.common
import openturns.typ
import openturns.statistics
import openturns.graph
import openturns.func
import openturns.geom
import openturns.iterative_statistics
import openturns.diff
import openturns.optim
import openturns.experiment
import openturns.solver
import openturns.algo
import openturns.uncertainty
import openturns.model_copula
import openturns.randomvector
import openturns.dist_bundle1
import openturns.dist_bundle2
import openturns.weightedexperiment
import openturns.classification
import openturns.orthogonalbasis
import openturns.metamodel
import openturns.transformation
import openturns.analytical
import openturns.simulation
import openturns.stattests
import openturns.model_process
import openturns.dist_bundle3
class MeasureEvaluationImplementation(openturns.func.EvaluationImplementation):
    r"""
    Measure evaluation base class.

    Base class for measure function evaluations, allows to define robust
    counterparts of parametric objective or constraint functions.

    See also
    --------
    MeanMeasure, VarianceMeasure, MeanStandardDeviationTradeoffMeasure,
    WorstCaseMeasure, JointChanceMeasure, IndividualChanceMeasure,
    QuantileMeasure, AggregatedMeasure
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def getClassName(self):
        r"""
        Accessor to the object's name.

        Returns
        -------
        class_name : str
            The object class name (`object.__class__.__name__`).
        """
        return _otrobopt.MeasureEvaluationImplementation_getClassName(self)

    def __call__(self, inP):
        return _otrobopt.MeasureEvaluationImplementation___call__(self, inP)

    def setDistribution(self, distribution):
        r"""
        Distribution accessor.

        Parameters
        ----------
        distribution : :py:class:`openturns.Distribution`
            Parameters distribution.
        """
        return _otrobopt.MeasureEvaluationImplementation_setDistribution(self, distribution)

    def getDistribution(self):
        r"""
        Distribution accessor.

        Returns
        -------
        distribution : :py:class:`openturns.Distribution`
            Parameters distribution.
        """
        return _otrobopt.MeasureEvaluationImplementation_getDistribution(self)

    def setFunction(self, function):
        r"""
        Function accessor.

        Parameters
        ----------
        function : :py:class:`openturns.Function`
            Parametric function.
        """
        return _otrobopt.MeasureEvaluationImplementation_setFunction(self, function)

    def getFunction(self):
        r"""
        Function accessor.

        Returns
        -------
        function : :py:class:`openturns.Function`
            Parametric function.
        """
        return _otrobopt.MeasureEvaluationImplementation_getFunction(self)

    def getInputDimension(self):
        r"""
        Accessor to the number of the inputs.

        Returns
        -------
        number_inputs : int
            Number of inputs.

        Examples
        --------
        >>> import openturns as ot
        >>> f = ot.SymbolicFunction(['x1', 'x2'],
        ...                         ['2 * x1^2 + x1 + 8 * x2 + 4 * cos(x1) * x2 + 6'])
        >>> print(f.getInputDimension())
        2
        """
        return _otrobopt.MeasureEvaluationImplementation_getInputDimension(self)

    def getOutputDimension(self):
        r"""
        Accessor to the number of the outputs.

        Returns
        -------
        number_outputs : int
            Number of outputs.

        Examples
        --------
        >>> import openturns as ot
        >>> f = ot.SymbolicFunction(['x1', 'x2'],
        ...                         ['2 * x1^2 + x1 + 8 * x2 + 4 * cos(x1) * x2 + 6'])
        >>> print(f.getOutputDimension())
        1
        """
        return _otrobopt.MeasureEvaluationImplementation_getOutputDimension(self)

    def setIntegrationAlgorithm(self, algorithm):
        r"""
        Integration algorithm accessor.

        Parameters
        ----------
        algorithm : :py:class:`openturns.IntegrationAlgorithm`
            Algorithm used to compute the exact value of the measure.
        """
        return _otrobopt.MeasureEvaluationImplementation_setIntegrationAlgorithm(self, algorithm)

    def getIntegrationAlgorithm(self):
        r"""
        Integration algorithm accessor.

        Returns
        -------
        algorithm : :py:class:`openturns.IntegrationAlgorithm`
            Algorithm used to compute the exact value of the measure.
        """
        return _otrobopt.MeasureEvaluationImplementation_getIntegrationAlgorithm(self)

    def getPDFThreshold(self):
        r"""
        PDF threshold accessor.

        Returns
        -------
        threshold : float
            PDF threshold under which the contribution is not computed.
        """
        return _otrobopt.MeasureEvaluationImplementation_getPDFThreshold(self)

    def setPDFThreshold(self, threshold):
        r"""
        PDF threshold accessor.

        Parameters
        ----------
        threshold : float
            PDF threshold under which the contribution is not computed.
        """
        return _otrobopt.MeasureEvaluationImplementation_setPDFThreshold(self, threshold)

    def __repr__(self):
        return _otrobopt.MeasureEvaluationImplementation___repr__(self)

    def __str__(self, *args):
        return _otrobopt.MeasureEvaluationImplementation___str__(self, *args)

    def __init__(self, *args):
        _otrobopt.MeasureEvaluationImplementation_swiginit(self, _otrobopt.new_MeasureEvaluationImplementation(*args))
    __swig_destroy__ = _otrobopt.delete_MeasureEvaluationImplementation

# Register MeasureEvaluationImplementation in _otrobopt:
_otrobopt.MeasureEvaluationImplementation_swigregister(MeasureEvaluationImplementation)
class _MeasureEvaluationImplementationTypedInterfaceObject(openturns.common.InterfaceObject):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        _otrobopt._MeasureEvaluationImplementationTypedInterfaceObject_swiginit(self, _otrobopt.new__MeasureEvaluationImplementationTypedInterfaceObject(*args))

    def getImplementation(self):
        r"""
        Accessor to the underlying implementation.

        Returns
        -------
        impl : Implementation
            A copy of the underlying implementation object.
        """
        return _otrobopt._MeasureEvaluationImplementationTypedInterfaceObject_getImplementation(self)

    def setName(self, name):
        r"""
        Accessor to the object's name.

        Parameters
        ----------
        name : str
            The name of the object.
        """
        return _otrobopt._MeasureEvaluationImplementationTypedInterfaceObject_setName(self, name)

    def getName(self):
        r"""
        Accessor to the object's name.

        Returns
        -------
        name : str
            The name of the object.
        """
        return _otrobopt._MeasureEvaluationImplementationTypedInterfaceObject_getName(self)

    def __eq__(self, other):
        return _otrobopt._MeasureEvaluationImplementationTypedInterfaceObject___eq__(self, other)

    def __ne__(self, other):
        return _otrobopt._MeasureEvaluationImplementationTypedInterfaceObject___ne__(self, other)
    __swig_destroy__ = _otrobopt.delete__MeasureEvaluationImplementationTypedInterfaceObject

# Register _MeasureEvaluationImplementationTypedInterfaceObject in _otrobopt:
_otrobopt._MeasureEvaluationImplementationTypedInterfaceObject_swigregister(_MeasureEvaluationImplementationTypedInterfaceObject)
class MeasureEvaluation(_MeasureEvaluationImplementationTypedInterfaceObject):
    r"""
    Measure evaluation base class.

    Base class for measure function evaluations, allows to define robust
    counterparts of parametric objective or constraint functions.

    See also
    --------
    MeanMeasure, VarianceMeasure, MeanStandardDeviationTradeoffMeasure,
    WorstCaseMeasure, JointChanceMeasure, IndividualChanceMeasure,
    QuantileMeasure, AggregatedMeasure
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    @staticmethod
    def GetClassName():
        return _otrobopt.MeasureEvaluation_GetClassName()

    def getClassName(self):
        return _otrobopt.MeasureEvaluation_getClassName(self)

    def setDistribution(self, distribution):
        r"""
        Distribution accessor.

        Parameters
        ----------
        distribution : :py:class:`openturns.Distribution`
            Parameters distribution.
        """
        return _otrobopt.MeasureEvaluation_setDistribution(self, distribution)

    def getDistribution(self):
        r"""
        Distribution accessor.

        Returns
        -------
        distribution : :py:class:`openturns.Distribution`
            Parameters distribution.
        """
        return _otrobopt.MeasureEvaluation_getDistribution(self)

    def setFunction(self, function):
        r"""
        Function accessor.

        Parameters
        ----------
        function : :py:class:`openturns.Function`
            Parametric function.
        """
        return _otrobopt.MeasureEvaluation_setFunction(self, function)

    def getFunction(self):
        r"""
        Function accessor.

        Returns
        -------
        function : :py:class:`openturns.Function`
            Parametric function.
        """
        return _otrobopt.MeasureEvaluation_getFunction(self)

    def __call__(self, inP):
        return _otrobopt.MeasureEvaluation___call__(self, inP)

    def __repr__(self):
        return _otrobopt.MeasureEvaluation___repr__(self)

    def __init__(self, *args):
        _otrobopt.MeasureEvaluation_swiginit(self, _otrobopt.new_MeasureEvaluation(*args))
    __swig_destroy__ = _otrobopt.delete_MeasureEvaluation

# Register MeasureEvaluation in _otrobopt:
_otrobopt.MeasureEvaluation_swigregister(MeasureEvaluation)
class MeanMeasure(MeasureEvaluationImplementation):
    r"""
    Mean measure function.

    It is built from a parametric function :math:`f` and a distribution :math:`\cD` of density function :math:`p`.


    In case of a continuous distribution:

    .. math::

        M_{f, \cD}(x) = \int_{Supp(\cD)} f(x, \theta) p(\theta) d \theta

    In case of a discrete distribution:

    .. math::

        M_{f, \cD}(x) = \sum_{\theta_i \in Supp(\cD)} f(x, \theta_i) p_i


    Parameters
    ----------
    function : :py:class:`openturns.Function`
        Parametric function
    distribution : :py:class:`openturns.Distribution`
        Distribution of parameters

    Examples
    --------
    >>> import openturns as ot
    >>> import otrobopt
    >>> thetaDist = ot.Normal(2.0, 0.1)
    >>> f_base = ot.SymbolicFunction(['x', 'theta'], ['x*theta'])
    >>> f = ot.ParametricFunction(f_base, [1], [1.0])
    >>> measure = otrobopt.MeanMeasure(f, thetaDist)
    >>> x = [1.0]
    >>> print(measure(x))
    [2]
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def getClassName(self):
        r"""
        Accessor to the object's name.

        Returns
        -------
        class_name : str
            The object class name (`object.__class__.__name__`).
        """
        return _otrobopt.MeanMeasure_getClassName(self)

    def __call__(self, inP):
        return _otrobopt.MeanMeasure___call__(self, inP)

    def __repr__(self):
        return _otrobopt.MeanMeasure___repr__(self)

    def __init__(self, *args):
        _otrobopt.MeanMeasure_swiginit(self, _otrobopt.new_MeanMeasure(*args))
    __swig_destroy__ = _otrobopt.delete_MeanMeasure

# Register MeanMeasure in _otrobopt:
_otrobopt.MeanMeasure_swigregister(MeanMeasure)
class VarianceMeasure(MeasureEvaluationImplementation):
    r"""
    Variance measure function.

    It is built from a parametric function :math:`f` and a distribution :math:`\cD` of density function :math:`p`.

    In case of a continuous distribution:

    .. math::

        \mu = \int_{Supp(\cD)} f(x, \theta) p(\theta) d \theta

        M_{f,\cD}(x) = \int_{Supp(\cD)} f(x, \theta)^2 p(\theta) d \theta - \mu^2

    In case of a discrete distribution:

    .. math::

        \mu = \sum_{\theta_i \in Supp(\cD)} f(x, \theta_i) p_i

        M_{f, \cD}(x) = \sum_{\theta_i \in Supp(\cD)} f(x, \theta_i)^2 p_i - \mu^2


    Parameters
    ----------
    function : :py:class:`openturns.Function`
        Parametric function
    distribution : :py:class:`openturns.Distribution`
        Distribution of parameters

    Examples
    --------
    >>> import openturns as ot
    >>> import otrobopt
    >>> thetaDist = ot.Normal(2.0, 0.1)
    >>> f_base = ot.SymbolicFunction(['x', 'theta'], ['x*theta'])
    >>> f = ot.ParametricFunction(f_base, [1], [1.0])
    >>> measure = otrobopt.VarianceMeasure(f, thetaDist)
    >>> x = [1.0]
    >>> print(measure(x))
    [0.01]
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def getClassName(self):
        r"""
        Accessor to the object's name.

        Returns
        -------
        class_name : str
            The object class name (`object.__class__.__name__`).
        """
        return _otrobopt.VarianceMeasure_getClassName(self)

    def __call__(self, inP):
        return _otrobopt.VarianceMeasure___call__(self, inP)

    def __repr__(self):
        return _otrobopt.VarianceMeasure___repr__(self)

    def __init__(self, *args):
        _otrobopt.VarianceMeasure_swiginit(self, _otrobopt.new_VarianceMeasure(*args))
    __swig_destroy__ = _otrobopt.delete_VarianceMeasure

# Register VarianceMeasure in _otrobopt:
_otrobopt.VarianceMeasure_swigregister(VarianceMeasure)
class MeanStandardDeviationTradeoffMeasure(MeasureEvaluationImplementation):
    r"""
    Mean/variance tradeoff measure function.


    It is built from a parametric function :math:`f` and a distribution :math:`\cD` of density function :math:`p`.

    In case of a continuous distribution:

    .. math::

        \mu_k = \int_{Supp(\cD)} f_k(x, \theta) p(\theta) d \theta

        Var_k = \int_{Supp(\cD)} f_k(x, \theta)^2 p(\theta) d \theta - \mu^2

        M_{f_k, \cD, \alpha_k}(x) = (1-\alpha_k) \mu_k + \alpha_k \sqrt{Var_k}

    In case of a discrete distribution:

    .. math::

        \mu_k = \sum_{\theta_i \in Supp(\cD)} f_k(x, \theta_i) p_i

        Var_k = \sum_{\theta_i \in Supp(\cD)} f_k(x, \theta_i)^2 p_i - {\mu_k}^2

        M_{f_k, \cD, \alpha_k}(x) = (1-\alpha_k) \mu_k + \alpha_k \sqrt{Var_k}


    Parameters
    ----------
    function : :py:class:`openturns.Function`
        Parametric function
    distribution : :py:class:`openturns.Distribution`
        Distribution of parameters
    alpha : sequence of float, :math:`\alpha_k \in [0,1]`
        Tradeoff coefficient

    Examples
    --------
    >>> import openturns as ot
    >>> import otrobopt
    >>> thetaDist = ot.Normal(2.0, 0.1)
    >>> f_base = ot.SymbolicFunction(['x', 'theta'], ['x*theta'])
    >>> f = ot.ParametricFunction(f_base, [1], [1.0])
    >>> measure = otrobopt.MeanStandardDeviationTradeoffMeasure(f, thetaDist, [0.4])
    >>> x = [1.0]
    >>> print(measure(x))
    [1.24]
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def getClassName(self):
        r"""
        Accessor to the object's name.

        Returns
        -------
        class_name : str
            The object class name (`object.__class__.__name__`).
        """
        return _otrobopt.MeanStandardDeviationTradeoffMeasure_getClassName(self)

    def __call__(self, inP):
        return _otrobopt.MeanStandardDeviationTradeoffMeasure___call__(self, inP)

    def setAlpha(self, alpha):
        r"""
        Tradeoff coefficient accessor.

        Parameters
        ----------
        alpha : sequence of  float in :math:`(0,1)`
            Tradeoff coefficient
        """
        return _otrobopt.MeanStandardDeviationTradeoffMeasure_setAlpha(self, alpha)

    def getAlpha(self):
        r"""
        Tradeoff coefficient accessor.

        Returns
        -------
        alpha : sequence of float in :math:`(0,1)`
            Tradeoff coefficient
        """
        return _otrobopt.MeanStandardDeviationTradeoffMeasure_getAlpha(self)

    def __repr__(self):
        return _otrobopt.MeanStandardDeviationTradeoffMeasure___repr__(self)

    def __init__(self, *args):
        _otrobopt.MeanStandardDeviationTradeoffMeasure_swiginit(self, _otrobopt.new_MeanStandardDeviationTradeoffMeasure(*args))
    __swig_destroy__ = _otrobopt.delete_MeanStandardDeviationTradeoffMeasure

# Register MeanStandardDeviationTradeoffMeasure in _otrobopt:
_otrobopt.MeanStandardDeviationTradeoffMeasure_swigregister(MeanStandardDeviationTradeoffMeasure)
class QuantileMeasure(MeasureEvaluationImplementation):
    r"""
    Quantile measure function.

    It is built from a parametric function :math:`f` and a distribution :math:`\cD` of density function :math:`p`.

    .. math::

        M_{f, \cD, \alpha}(x) = \inf \{ s \in \Rset \: | \: \Pset (f(x, \Theta) \leq s) \geq \alpha \}

    Parameters
    ----------
    function : :py:class:`openturns.Function`
        Parametric function
    distribution : :py:class:`openturns.Distribution`
        Distribution of parameters
    alpha : float, in :math:`[0,1]`
        Quantile level

    Examples
    --------
    >>> import openturns as ot
    >>> import otrobopt
    >>> thetaDist = ot.Normal(2.0, 0.1)
    >>> f_base = ot.SymbolicFunction(['x', 'theta'], ['x*theta'])
    >>> f = ot.ParametricFunction(f_base, [1], [1.0])
    >>> measure = otrobopt.QuantileMeasure(f, thetaDist, 0.99)
    >>> x = [1.0]
    >>> print(measure(x))
    [2.23264]
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def getClassName(self):
        r"""
        Accessor to the object's name.

        Returns
        -------
        class_name : str
            The object class name (`object.__class__.__name__`).
        """
        return _otrobopt.QuantileMeasure_getClassName(self)

    def __call__(self, inP):
        return _otrobopt.QuantileMeasure___call__(self, inP)

    def setAlpha(self, alpha):
        r"""
        Quantile level accessor.

        Parameters
        ----------
        alpha : float
            Quantile level
        """
        return _otrobopt.QuantileMeasure_setAlpha(self, alpha)

    def getAlpha(self):
        r"""
        Quantile level accessor.

        Returns
        -------
        alpha : float
            Quantile level
        """
        return _otrobopt.QuantileMeasure_getAlpha(self)

    def __repr__(self):
        return _otrobopt.QuantileMeasure___repr__(self)

    def __init__(self, *args):
        _otrobopt.QuantileMeasure_swiginit(self, _otrobopt.new_QuantileMeasure(*args))
    __swig_destroy__ = _otrobopt.delete_QuantileMeasure

# Register QuantileMeasure in _otrobopt:
_otrobopt.QuantileMeasure_swigregister(QuantileMeasure)
class WorstCaseMeasure(MeasureEvaluationImplementation):
    r"""
    Worst case measure function.

    It is built from a parametric function :math:`f` and a distribution :math:`\cD` of density function :math:`p`.

    In case of a continuous distribution:

    .. math::

        M_{f, \cD}(x) = \inf_{\theta \in Supp(\cD)} f(x, \theta)

    In case of a discrete distribution:

    .. math::

        M_{f, \cD}(x) = \inf_{\theta_i \in Supp(\cD)} f(x, \theta_i)


    Parameters
    ----------
    function : :py:class:`openturns.Function`
        Parametric function
    distribution : :py:class:`openturns.Distribution`
        Distribution of parameters
    isMinimization : bool (optional, defaults to `True`)
        Whether the worst case is the minimization of the criteria

    Examples
    --------
    >>> import openturns as ot
    >>> import otrobopt
    >>> thetaDist = ot.Uniform(-1.0, 4.0)
    >>> f_base = ot.SymbolicFunction(['x', 'theta'], ['x*theta'])
    >>> f = ot.ParametricFunction(f_base, [1], [1.0])
    >>> measure = otrobopt.WorstCaseMeasure(f, thetaDist, False)
    >>> x = [1.0]
    >>> print(measure(x))
    [4]
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def getClassName(self):
        r"""
        Accessor to the object's name.

        Returns
        -------
        class_name : str
            The object class name (`object.__class__.__name__`).
        """
        return _otrobopt.WorstCaseMeasure_getClassName(self)

    def __call__(self, inP):
        return _otrobopt.WorstCaseMeasure___call__(self, inP)

    def setOptimizationAlgorithm(self, solver):
        r"""
        Optimization solver accessor.

        Parameters
        ----------
        solver : :py:class:`openturns.OptimizationAlgorithm`
            Optimization solver
        """
        return _otrobopt.WorstCaseMeasure_setOptimizationAlgorithm(self, solver)

    def getOptimizationAlgorithm(self):
        r"""
        Optimization solver accessor.

        Returns
        -------
        solver : :py:class:`openturns.OptimizationAlgorithm`
            Optimization solver
        """
        return _otrobopt.WorstCaseMeasure_getOptimizationAlgorithm(self)

    def setMinimization(self, minimization):
        r"""
        Minimization flag accessor.

        Parameters
        ----------
        minimization : bool
            Whether the problem is a minimization.
        """
        return _otrobopt.WorstCaseMeasure_setMinimization(self, minimization)

    def isMinimization(self):
        r"""
        Minimization flag accessor.

        Returns
        -------
        minimization : bool
            Whether the problem is a minimization.
        """
        return _otrobopt.WorstCaseMeasure_isMinimization(self)

    def __repr__(self):
        return _otrobopt.WorstCaseMeasure___repr__(self)

    def __init__(self, *args):
        _otrobopt.WorstCaseMeasure_swiginit(self, _otrobopt.new_WorstCaseMeasure(*args))
    __swig_destroy__ = _otrobopt.delete_WorstCaseMeasure

# Register WorstCaseMeasure in _otrobopt:
_otrobopt.WorstCaseMeasure_swigregister(WorstCaseMeasure)
class MeasureEvaluationCollection(object):
    r"""
    Collection.

    Examples
    --------
    >>> import openturns as ot

    - Collection of **real values**:

    >>> ot.ScalarCollection(2)
    [0,0]
    >>> ot.ScalarCollection(2, 3.25)
    [3.25,3.25]
    >>> vector = ot.ScalarCollection([2.0, 1.5, 2.6])
    >>> vector
    [2,1.5,2.6]
    >>> vector[1] = 4.2
    >>> vector
    [2,4.2,2.6]
    >>> vector.add(3.8)
    >>> vector
    [2,4.2,2.6,3.8]

    - Collection of **complex values**:

    >>> ot.ComplexCollection(2)
    [(0,0),(0,0)]
    >>> ot.ComplexCollection(2, 3+4j)
    [(3,4),(3,4)]
    >>> vector = ot.ComplexCollection([2+3j, 1-4j, 3.0])
    >>> vector
    [(2,3),(1,-4),(3,0)]
    >>> vector[1] = 4+3j
    >>> vector
    [(2,3),(4,3),(3,0)]
    >>> vector.add(5+1j)
    >>> vector
    [(2,3),(4,3),(3,0),(5,1)]

    - Collection of **booleans**:

    >>> ot.BoolCollection(3)
    [0,0,0]
    >>> ot.BoolCollection(3, 1)
    [1,1,1]
    >>> vector = ot.BoolCollection([0, 1, 0])
    >>> vector
    [0,1,0]
    >>> vector[1] = 0
    >>> vector
    [0,0,0]
    >>> vector.add(1)
    >>> vector
    [0,0,0,1]

    - Collection of **distributions**:

    >>> print(ot.DistributionCollection(2))
    [Uniform(a = -1, b = 1),Uniform(a = -1, b = 1)]
    >>> print(ot.DistributionCollection(2, ot.Gamma(2.75, 1.0)))
    [Gamma(k = 2.75, lambda = 1, gamma = 0),Gamma(k = 2.75, lambda = 1, gamma = 0)]
    >>> vector = ot.DistributionCollection([ot.Normal(), ot.Uniform()])
    >>> print(vector)
    [Normal(mu = 0, sigma = 1),Uniform(a = -1, b = 1)]
    >>> vector[1] = ot.Uniform(-0.5, 1)
    >>> print(vector)
    [Normal(mu = 0, sigma = 1),Uniform(a = -0.5, b = 1)]
    >>> vector.add(ot.Gamma(2.75, 1.0))
    >>> print(vector)
    [Normal(mu = 0, sigma = 1),Uniform(a = -0.5, b = 1),Gamma(k = 2.75, lambda = 1, gamma = 0)]
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __swig_destroy__ = _otrobopt.delete_MeasureEvaluationCollection

    def clear(self):
        r"""
        Reset the collection to zero dimension.

        Examples
        --------
        >>> import openturns as ot
        >>> x = ot.Point(2)
        >>> x.clear()
        >>> x
        class=Point name=Unnamed dimension=0 values=[]
        """
        return _otrobopt.MeasureEvaluationCollection_clear(self)

    def __len__(self):
        return _otrobopt.MeasureEvaluationCollection___len__(self)

    def __eq__(self, rhs):
        return _otrobopt.MeasureEvaluationCollection___eq__(self, rhs)

    def __contains__(self, val):
        return _otrobopt.MeasureEvaluationCollection___contains__(self, val)

    def select(self, marginalIndices):
        r"""
        Selection from indices.

        Parameters
        ----------
        indices : sequence of int
            Indices to select

        Returns
        -------
        coll : sequence
            Sub-collection of values at the selection indices.
        """
        return _otrobopt.MeasureEvaluationCollection_select(self, marginalIndices)

    def __getitem__(self, i):
        return _otrobopt.MeasureEvaluationCollection___getitem__(self, i)

    def __setitem__(self, i, val):
        return _otrobopt.MeasureEvaluationCollection___setitem__(self, i, val)

    def __delitem__(self, i):
        return _otrobopt.MeasureEvaluationCollection___delitem__(self, i)

    def at(self, *args):
        r"""
        Access to an element of the collection.

        Parameters
        ----------
        index : positive int
            Position of the element to access.

        Returns
        -------
        element : type depends on the type of the collection
            Element of the collection at the position *index*.
        """
        return _otrobopt.MeasureEvaluationCollection_at(self, *args)

    def add(self, *args):
        r"""
        Append a component (in-place).

        Parameters
        ----------
        value : type depends on the type of the collection.
            The component to append.

        Examples
        --------
        >>> import openturns as ot
        >>> x = ot.Point(2)
        >>> x.add(1.)
        >>> print(x)
        [0,0,1]
        """
        return _otrobopt.MeasureEvaluationCollection_add(self, *args)

    def getSize(self):
        r"""
        Get the collection's dimension (or size).

        Returns
        -------
        n : int
            The number of components in the collection.
        """
        return _otrobopt.MeasureEvaluationCollection_getSize(self)

    def resize(self, newSize):
        r"""
        Change the size of the collection.

        Parameters
        ----------
        newSize : positive int
            New size of the collection.

        Notes
        -----
        If the new size is smaller than the older one, the last elements are thrown
        away, else the new elements are set to the default value of the element type.

        Examples
        --------
        >>> import openturns as ot
        >>> x = ot.Point(2, 4)
        >>> print(x)
        [4,4]
        >>> x.resize(1)
        >>> print(x)
        [4]
        >>> x.resize(4)
        >>> print(x)
        [4,0,0,0]
        """
        return _otrobopt.MeasureEvaluationCollection_resize(self, newSize)

    def isEmpty(self):
        r"""
        Tell if the collection is empty.

        Returns
        -------
        isEmpty : bool
            *True* if there is no element in the collection.

        Examples
        --------
        >>> import openturns as ot
        >>> x = ot.Point(2)
        >>> x.isEmpty()
        False
        >>> x.clear()
        >>> x.isEmpty()
        True
        """
        return _otrobopt.MeasureEvaluationCollection_isEmpty(self)

    def find(self, val):
        r"""
        Find the index of a given value.

        Parameters
        ----------
        val : collection value type
            The value to find

        Returns
        -------
        index : int
            The index of the first occurrence of the value,
            or the size of the container if not found.
            When several values match, only the first index is returned.
        """
        return _otrobopt.MeasureEvaluationCollection_find(self, val)

    def __repr__(self):
        return _otrobopt.MeasureEvaluationCollection___repr__(self)

    def __str__(self, *args):
        return _otrobopt.MeasureEvaluationCollection___str__(self, *args)

    def __init__(self, *args):
        _otrobopt.MeasureEvaluationCollection_swiginit(self, _otrobopt.new_MeasureEvaluationCollection(*args))

# Register MeasureEvaluationCollection in _otrobopt:
_otrobopt.MeasureEvaluationCollection_swigregister(MeasureEvaluationCollection)
class AggregatedMeasure(MeasureEvaluationImplementation):
    r"""
    Aggregated measure function.

    Assembles the output of several measure functions.

    Parameters
    ----------
    collection : sequence of :class:`~otrobopt.MeasureEvaluation`
        The measures to aggregate.

    Examples
    --------
    >>> import openturns as ot
    >>> import otrobopt
    >>> thetaDist = ot.Normal(2.0, 0.1)
    >>> f_base = ot.SymbolicFunction(['x', 'theta'], ['x*theta'])
    >>> f = ot.ParametricFunction(f_base, [1], [1.0])
    >>> measures = [otrobopt.MeanMeasure(f, thetaDist),
    ...             otrobopt.VarianceMeasure(f, thetaDist)]
    >>> measure = otrobopt.AggregatedMeasure(measures)
    >>> x = [1.0]
    >>> print(measure(x))
    [2,0.01]
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def getClassName(self):
        r"""
        Accessor to the object's name.

        Returns
        -------
        class_name : str
            The object class name (`object.__class__.__name__`).
        """
        return _otrobopt.AggregatedMeasure_getClassName(self)

    def __call__(self, inP):
        return _otrobopt.AggregatedMeasure___call__(self, inP)

    def setDistribution(self, distribution):
        r"""
        Distribution accessor.

        Parameters
        ----------
        distribution : :py:class:`openturns.Distribution`
            Parameters distribution.
        """
        return _otrobopt.AggregatedMeasure_setDistribution(self, distribution)

    def getDistribution(self):
        r"""
        Distribution accessor.

        Returns
        -------
        distribution : :py:class:`openturns.Distribution`
            Parameters distribution.
        """
        return _otrobopt.AggregatedMeasure_getDistribution(self)

    def __repr__(self):
        return _otrobopt.AggregatedMeasure___repr__(self)

    def __init__(self, *args):
        _otrobopt.AggregatedMeasure_swiginit(self, _otrobopt.new_AggregatedMeasure(*args))
    __swig_destroy__ = _otrobopt.delete_AggregatedMeasure

# Register AggregatedMeasure in _otrobopt:
_otrobopt.AggregatedMeasure_swigregister(AggregatedMeasure)
class JointChanceMeasure(MeasureEvaluationImplementation):
    r"""
    Joint chance measure function.

    It is built from a parametric function :math:`f` and a distribution :math:`\cD` of density function :math:`p`.

    When the constraint considered is :math:`\Pset (f_k(x, \Theta) \ge 0, \forall k \in K) \geq \alpha`:

    .. math::

        M_{f, \cD, \alpha}(x) = \Pset \left(\bigcap_{k \in K} \{f_k(x, \Theta) \ge 0\}\right) - \alpha

    In case of a continuous distribution:

    .. math::

        M_{f, \cD, \alpha}(x) = \int_{Supp(\cD)} \left( \prod_{k \in K} \mathbf{1}_{f_k(x, \theta) \ge 0} \right) p(\theta) d \theta - \alpha

    In case of a discrete distribution:

    .. math::

        M_{f, \cD, \alpha}(x) = \sum_{\theta_i \in Supp(\cD)}  \left( \prod_{k \in K} \mathbf{1}_{f_k(x, \theta_i) \ge 0} \right) p_i - \alpha

    Parameters
    ----------
    function : :py:class:`openturns.Function`
        Parametric function
    distribution : :py:class:`openturns.Distribution`
        Distribution of parameters
    operator : :py:class:`openturns.ComparisonOperator`
        Comparison operator in front of :math:`\alpha`
    alpha : float in :math:`(0,1)`
        Probability level

    Examples
    --------
    >>> import openturns as ot
    >>> import otrobopt
    >>> thetaDist = ot.Normal(1.0, 1.0)
    >>> f_base = ot.SymbolicFunction(['x', 'theta'], ['x*theta'])
    >>> f = ot.ParametricFunction(f_base, [1], [1.0])
    >>> measure = otrobopt.JointChanceMeasure(f, thetaDist, ot.GreaterOrEqual(), 0.95)
    >>> x = [1.0]
    >>> print(measure(x))
    [-0.108655]
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def getClassName(self):
        r"""
        Accessor to the object's name.

        Returns
        -------
        class_name : str
            The object class name (`object.__class__.__name__`).
        """
        return _otrobopt.JointChanceMeasure_getClassName(self)

    def __call__(self, inP):
        return _otrobopt.JointChanceMeasure___call__(self, inP)

    def setAlpha(self, alpha):
        r"""
        Probability level accessor.

        Parameters
        ----------
        alpha : float in :math:`(0,1)`
            Probability level
        """
        return _otrobopt.JointChanceMeasure_setAlpha(self, alpha)

    def getAlpha(self):
        r"""
        Probability level accessor.

        Returns
        -------
        alpha : float in :math:`(0,1)`
            Probability level
        """
        return _otrobopt.JointChanceMeasure_getAlpha(self)

    def getOutputDimension(self):
        r"""
        Accessor to the number of the outputs.

        Returns
        -------
        number_outputs : int
            Number of outputs.

        Examples
        --------
        >>> import openturns as ot
        >>> f = ot.SymbolicFunction(['x1', 'x2'],
        ...                         ['2 * x1^2 + x1 + 8 * x2 + 4 * cos(x1) * x2 + 6'])
        >>> print(f.getOutputDimension())
        1
        """
        return _otrobopt.JointChanceMeasure_getOutputDimension(self)

    def __repr__(self):
        return _otrobopt.JointChanceMeasure___repr__(self)

    def __init__(self, *args):
        _otrobopt.JointChanceMeasure_swiginit(self, _otrobopt.new_JointChanceMeasure(*args))
    __swig_destroy__ = _otrobopt.delete_JointChanceMeasure

# Register JointChanceMeasure in _otrobopt:
_otrobopt.JointChanceMeasure_swigregister(JointChanceMeasure)
class IndividualChanceMeasure(MeasureEvaluationImplementation):
    r"""
    Individual chance measure function.

    It is built from a parametric function :math:`f` and a distribution :math:`\cD` of density function :math:`p`.

    When the constraint considered is :math:`\Pset (f_k(x, \Theta) \ge 0) \geq \alpha_k, \forall k \in K`:

    .. math::

        M_{f_k, \cD, \alpha_k}(x) = \Pset (f_k(x, \theta) \ge 0) - \alpha_k

    In case of a continuous distribution:

    .. math::

        M_{f_k, \cD, \alpha_k}(x) = \int_{Supp(\cD)} \mathbf{1}_{f_k(x, \theta) \ge 0} p(\theta) d \theta - \alpha_k

    In case of a discrete distribution:

    .. math::

        M_{f_k, \cD, \alpha_k}(x) = \sum_{\theta_i \in Supp(\cD)} \mathbf{1}_{f_k(x, \theta_i) \ge 0} p_i - \alpha_k


    Parameters
    ----------
    function : :py:class:`openturns.Function`
        Parametric function
    distribution : :py:class:`openturns.Distribution`
        Distribution of parameters
    operator : :py:class:`openturns.ComparisonOperator`
        Comparison operator in front of :math:`\alpha_k`
    alpha : sequence of float
        Probability levels

    Examples
    --------
    >>> import openturns as ot
    >>> import otrobopt
    >>> thetaDist = ot.Normal(1.0, 1.0)
    >>> f_base = ot.SymbolicFunction(['x', 'theta'], ['x*theta'])
    >>> f = ot.ParametricFunction(f_base, [1], [1.0])
    >>> measure = otrobopt.IndividualChanceMeasure(f, thetaDist, ot.GreaterOrEqual(), [0.95])
    >>> x = [1.0]
    >>> print(measure(x))
    [-0.108655]
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def getClassName(self):
        r"""
        Accessor to the object's name.

        Returns
        -------
        class_name : str
            The object class name (`object.__class__.__name__`).
        """
        return _otrobopt.IndividualChanceMeasure_getClassName(self)

    def __init__(self, *args):
        _otrobopt.IndividualChanceMeasure_swiginit(self, _otrobopt.new_IndividualChanceMeasure(*args))

    def __call__(self, inP):
        return _otrobopt.IndividualChanceMeasure___call__(self, inP)

    def setAlpha(self, alpha):
        r"""
        Probability levels accessor.

        Parameters
        ----------
        alpha : sequence of float in :math:`(0,1)`
            Probability levels
        """
        return _otrobopt.IndividualChanceMeasure_setAlpha(self, alpha)

    def getAlpha(self):
        r"""
        Probability levels accessor.

        Returns
        -------
        alpha : sequence of float in :math:`(0,1)`
            Probability levels
        """
        return _otrobopt.IndividualChanceMeasure_getAlpha(self)

    def __repr__(self):
        return _otrobopt.IndividualChanceMeasure___repr__(self)
    __swig_destroy__ = _otrobopt.delete_IndividualChanceMeasure

# Register IndividualChanceMeasure in _otrobopt:
_otrobopt.IndividualChanceMeasure_swigregister(IndividualChanceMeasure)
class MeasureFunction(openturns.func.FunctionImplementation):
    r"""
    Measure function.

    Parameters
    ----------
    evaluation : :class:`~otrobopt.MeasureEvaluation`
        Measure evaluation

    Examples
    --------
    First define a measure:

    >>> import openturns as ot
    >>> import otrobopt
    >>> thetaDist = ot.Normal(2.0, 0.1)
    >>> f = ot.SymbolicFunction(['x', 'theta'], ['x*theta'])
    >>> parametric = ot.ParametricFunction(f, [1], [1.0])
    >>> evaluation = otrobopt.MeanMeasure(parametric, thetaDist)
    >>> function = otrobopt.MeasureFunction(evaluation)
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def getClassName(self):
        r"""
        Accessor to the object's name.

        Returns
        -------
        class_name : str
            The object class name (`object.__class__.__name__`).
        """
        return _otrobopt.MeasureFunction_getClassName(self)

    def __call__(self, *args):
        return _otrobopt.MeasureFunction___call__(self, *args)

    def getInputDimension(self):
        r"""
        Accessor to the dimension of the input vector.

        Returns
        -------
        inputDim : int
            Dimension of the input vector :math:`d`.

        Examples
        --------
        >>> import openturns as ot
        >>> f = ot.SymbolicFunction(['x1', 'x2'],
        ...                          ['2 * x1^2 + x1 + 8 * x2 + 4 * cos(x1) * x2 + 6'])
        >>> print(f.getInputDimension())
        2
        """
        return _otrobopt.MeasureFunction_getInputDimension(self)

    def getOutputDimension(self):
        r"""
        Accessor to the number of the outputs.

        Returns
        -------
        number_outputs : int
            Dimension of the output vector :math:`d'`.

        Examples
        --------
        >>> import openturns as ot
        >>> f = ot.SymbolicFunction(['x1', 'x2'],
        ...                          ['2 * x1^2 + x1 + 8 * x2 + 4 * cos(x1) * x2 + 6'])
        >>> print(f.getOutputDimension())
        1
        """
        return _otrobopt.MeasureFunction_getOutputDimension(self)

    def __repr__(self):
        return _otrobopt.MeasureFunction___repr__(self)

    def __init__(self, *args):
        _otrobopt.MeasureFunction_swiginit(self, _otrobopt.new_MeasureFunction(*args))
    __swig_destroy__ = _otrobopt.delete_MeasureFunction

# Register MeasureFunction in _otrobopt:
_otrobopt.MeasureFunction_swigregister(MeasureFunction)
class MeasureFactory(openturns.common.PersistentObject):
    r"""
    Discretize a measure function.

    It consists in replacing the distribution :math:`\cD` of the measure by a discrete
    approximation.

    .. math::

        \cD \rightarrow \sum_{i=1}^N \omega_i \delta_{\theta_i}


    Where :math:`\delta_{\theta_i}` is the Dirac measure at :math:`\theta_i`.

    Parameters
    ----------
    experiment : :py:class:`openturns.WeightedExperiment`
        Parameters design of experiment

    Examples
    --------
    First define a measure:

    >>> import openturns as ot
    >>> import otrobopt
    >>> thetaDist = ot.Normal(2.0, 0.1)
    >>> f_base = ot.SymbolicFunction(['x', 'theta'], ['x*theta'])
    >>> f = ot.ParametricFunction(f_base, [1], [1.0])
    >>> measure = otrobopt.MeanMeasure(f, thetaDist)


    Then discretize it:

    >>> N = 10
    >>> experiment = ot.LHSExperiment(N)
    >>> factory = otrobopt.MeasureFactory(experiment)
    >>> discretizedMeasure = factory.build(measure)


    Discretize several measures at once:

    >>> coll = [otrobopt.MeanMeasure(f, thetaDist),
    ...         otrobopt.VarianceMeasure(f, thetaDist)]
    >>> discretizedMeasures = factory.buildCollection(coll)

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def getClassName(self):
        r"""
        Accessor to the object's name.

        Returns
        -------
        class_name : str
            The object class name (`object.__class__.__name__`).
        """
        return _otrobopt.MeasureFactory_getClassName(self)

    def build(self, measure):
        r"""
        Discretize a measure.

        Parameters
        ----------
        measure : :class:`~otrobopt.MeasureEvaluation`
            Measure

        Returns
        -------
        measure : :class:`~otrobopt.MeasureEvaluation`
            Discretized measure
        """
        return _otrobopt.MeasureFactory_build(self, measure)

    def buildCollection(self, collection):
        r"""
        Discretize several measures.

        Parameters
        ----------
        collection : sequence of :class:`~otrobopt.MeasureEvaluation`
            The measures to discretize.

        Returns
        -------
        measures : sequence of :class:`~otrobopt.MeasureEvaluation`
            Discretized measures
        """
        return _otrobopt.MeasureFactory_buildCollection(self, collection)

    def __repr__(self):
        return _otrobopt.MeasureFactory___repr__(self)

    def __init__(self, *args):
        _otrobopt.MeasureFactory_swiginit(self, _otrobopt.new_MeasureFactory(*args))
    __swig_destroy__ = _otrobopt.delete_MeasureFactory

# Register MeasureFactory in _otrobopt:
_otrobopt.MeasureFactory_swigregister(MeasureFactory)
class RobustOptimizationProblem(openturns.optim.OptimizationProblemImplementation):
    r"""
    Robust optimization problem.

    Must consist at least of one :class:`~otrobopt.MeasureEvaluation`, either on
    the objective or the constraint.

    Available constructors:

        RobustOptimizationProblem(*robustnessMeasure, reliabilityMeasure*)

        RobustOptimizationProblem(*objective, reliabilityMeasure*)

        RobustOptimizationProblem(*robustnessMeasure, inequalityConstraint*)

    Parameters
    ----------
    robustnessMeasure : :class:`~otrobopt.MeasureEvaluation`
        Measure function on the objective.
    reliabilityMeasure : :class:`~otrobopt.MeasureEvaluation`
        Mesure function on the constraints
    objective : :py:class:`openturns.Function`
        Objective function
    inequalityConstraint : :py:class:`openturns.Function`
        Inequality constraint

    Examples
    --------
    >>> import openturns as ot
    >>> import otrobopt


    Pure robustness problem:

    >>> thetaDist = ot.Normal(2.0, 0.1)
    >>> f_base = ot.SymbolicFunction(['x1', 'theta'], ['x1*theta+cos(x1+theta)'])
    >>> f = ot.ParametricFunction(f_base, [1], [1.0])
    >>> robustnessMeasure = otrobopt.VarianceMeasure(f, thetaDist) 
    >>> problem = otrobopt.RobustOptimizationProblem(robustnessMeasure, ot.Function())
    >>> algo = ot.Cobyla(problem)
    >>> algo.setStartingPoint([0.0]*robustnessMeasure.getInputDimension())
    >>> algo.run()
    >>> x_et = algo.getResult().getOptimalPoint()
    >>> print(x_et)
    [0.55...]
    >>> J_et = algo.getResult().getOptimalValue()
    >>> print(J_et)
    [3.42...e-05]

    Robustness problem with deterministic constraint:

    >>> thetaDist = ot.Normal(2.0, 0.1)
    >>> f_base = ot.SymbolicFunction(['x1', 'theta'], ['x1*theta'])
    >>> f = ot.ParametricFunction(f_base, [1], [1.0])
    >>> robustnessMeasure = otrobopt.MeanMeasure(f, thetaDist)
    >>> g = ot.SymbolicFunction(['x1'], ['x1 - 5.0'])
    >>> problem = otrobopt.RobustOptimizationProblem(robustnessMeasure, g)
    >>> algo = ot.Cobyla(problem)
    >>> algo.setStartingPoint([0.0]*robustnessMeasure.getInputDimension())
    >>> algo.run()
    >>> x_et = algo.getResult().getOptimalPoint()
    >>> J_et = algo.getResult().getOptimalValue()

    Pure reliability problem:

    >>> thetaDist = ot.Normal(2.0, 0.1)
    >>> f = ot.SymbolicFunction(['x1'], ['x1+1'])
    >>> g_base = ot.SymbolicFunction(['x1', 'theta'], ['x1+theta'])
    >>> g = ot.ParametricFunction(g_base, [1], [1.0])
    >>> reliabilityMeasure = otrobopt.JointChanceMeasure(g, thetaDist, ot.Greater(), 0.95)
    >>> problem = otrobopt.RobustOptimizationProblem(f, reliabilityMeasure)
    >>> algo = ot.Cobyla(problem)
    >>> algo.setStartingPoint([0.0]*robustnessMeasure.getInputDimension())
    >>> algo.run()
    >>> x_et = algo.getResult().getOptimalPoint()
    >>> print(x_et)
    [-1.83...]
    >>> J_et = algo.getResult().getOptimalValue()
    >>> print(J_et)
    [-0.83...]

    Robustness & reliability problem:

    >>> thetaDist = ot.Normal(2.0, 0.1)
    >>> f_base = ot.SymbolicFunction(['x1', 'theta'], ['x1*theta'])
    >>> f = ot.ParametricFunction(f_base, [1], [1.0])
    >>> robustnessMeasure = otrobopt.MeanMeasure(f, thetaDist)
    >>> g_base = ot.SymbolicFunction(['x1', 'theta'], ['x1+theta'])
    >>> g = ot.ParametricFunction(g_base, [1], [1.0])
    >>> reliabilityMeasure = otrobopt.JointChanceMeasure(g, thetaDist, ot.Greater(), 0.95)
    >>> problem = otrobopt.RobustOptimizationProblem(robustnessMeasure, reliabilityMeasure)
    >>> algo = ot.Cobyla(problem)
    >>> algo.setStartingPoint([0.0]*robustnessMeasure.getInputDimension())
    >>> algo.run()
    >>> x_et = algo.getResult().getOptimalPoint()
    >>> print(x_et)
    [-1.83...]
    >>> J_et = algo.getResult().getOptimalValue()
    >>> print(J_et)
    [-3.67...]
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def getClassName(self):
        r"""
        Accessor to the object's name.

        Returns
        -------
        class_name : str
            The object class name (`object.__class__.__name__`).
        """
        return _otrobopt.RobustOptimizationProblem_getClassName(self)

    def setRobustnessMeasure(self, robustnessMeasure):
        r"""
        Robustness measure accessor.

        The measure on associated to the objective function

        Parameters
        ----------
        robustnessMeasure : :class:`~otrobopt.MeasureEvaluation`
            Measure function on the objective.
        """
        return _otrobopt.RobustOptimizationProblem_setRobustnessMeasure(self, robustnessMeasure)

    def getRobustnessMeasure(self):
        r"""
        Robustness measure accessor.

        The measure on associated to the objective function

        Returns
        -------
        robustnessMeasure : :class:`~otrobopt.MeasureEvaluation`
            Measure function on the objective.
        """
        return _otrobopt.RobustOptimizationProblem_getRobustnessMeasure(self)

    def hasRobustnessMeasure(self):
        r"""
        Robustness measure flag accessor.

        If no robustness measure was set, the problem should have a
        reliability measure.
        The objective is deduced from the robustness measure.

        Returns
        -------
        hasReliabilityMeasure : bool
            Whether a robustness measure was set
        """
        return _otrobopt.RobustOptimizationProblem_hasRobustnessMeasure(self)

    def setReliabilityMeasure(self, reliabilityMeasure):
        r"""
        Reliability measure accessor.

        The measure on associated to the constraint

        Parameters
        ----------
        reliabilityMeasure : :class:`~otrobopt.MeasureEvaluation`
            Mesure function on the constraints
        """
        return _otrobopt.RobustOptimizationProblem_setReliabilityMeasure(self, reliabilityMeasure)

    def getReliabilityMeasure(self):
        r"""
        Reliability measure accessor.

        The measure on associated to the constraint

        Returns
        -------
        reliabilityMeasure : :class:`~otrobopt.MeasureEvaluation`
            Mesure function on the constraints
        """
        return _otrobopt.RobustOptimizationProblem_getReliabilityMeasure(self)

    def hasReliabilityMeasure(self):
        r"""
        Reliability measure flag accessor.

        If no reliability measure was set, the problem should have a
        robustness measure.
        The constraints are deduced from the reliability measure.

        Returns
        -------
        hasReliabilityMeasure : bool
            Whether a reliability measure was set
        """
        return _otrobopt.RobustOptimizationProblem_hasReliabilityMeasure(self)

    def getDistribution(self):
        r"""
        Distribution accessor.

        Returns
        -------
        distribution : :py:class:`openturns.Distribution`
            Parameter distribution
        """
        return _otrobopt.RobustOptimizationProblem_getDistribution(self)

    def __repr__(self):
        return _otrobopt.RobustOptimizationProblem___repr__(self)

    def __init__(self, *args):
        _otrobopt.RobustOptimizationProblem_swiginit(self, _otrobopt.new_RobustOptimizationProblem(*args))
    __swig_destroy__ = _otrobopt.delete_RobustOptimizationProblem

# Register RobustOptimizationProblem in _otrobopt:
_otrobopt.RobustOptimizationProblem_swigregister(RobustOptimizationProblem)
class RobustOptimizationAlgorithm(openturns.optim.OptimizationAlgorithmImplementation):
    r"""
    Robust optimization algorithm base class.

    Operates on a robust optimization problem.

    Parameters
    ----------
    problem : :class:`~otrobopt.RobustOptimizationProblem`
        Robust optimization problem
    solver : :py:class:`openturns.OptimizationAlgorithm`
        Optimization solver

    See also
    --------
    SequentialMonteCarloRobustAlgorithm
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def getClassName(self):
        r"""
        Accessor to the object's name.

        Returns
        -------
        class_name : str
            The object class name (`object.__class__.__name__`).
        """
        return _otrobopt.RobustOptimizationAlgorithm_getClassName(self)

    def setRobustProblem(self, problem):
        r"""
        Robust optimization problem accessor.

        Parameters
        ----------
        problem : :class:`~otrobopt.RobustOptimizationProblem`
            Robust optimization problem
        """
        return _otrobopt.RobustOptimizationAlgorithm_setRobustProblem(self, problem)

    def getRobustProblem(self):
        r"""
        Robust optimization problem accessor.

        Returns
        -------
        problem : :class:`~otrobopt.RobustOptimizationProblem`
            Robust optimization problem
        """
        return _otrobopt.RobustOptimizationAlgorithm_getRobustProblem(self)

    def setOptimizationAlgorithm(self, solver):
        r"""
        Optimization solver accessor.

        Parameters
        ----------
        solver : :py:class:`openturns.OptimizationAlgorithm`
            Optimization solver
        """
        return _otrobopt.RobustOptimizationAlgorithm_setOptimizationAlgorithm(self, solver)

    def getOptimizationAlgorithm(self):
        r"""
        Optimization solver accessor.

        Returns
        -------
        solver : :py:class:`openturns.OptimizationAlgorithm`
            Optimization solver
        """
        return _otrobopt.RobustOptimizationAlgorithm_getOptimizationAlgorithm(self)

    def __repr__(self):
        return _otrobopt.RobustOptimizationAlgorithm___repr__(self)

    def __init__(self, *args):
        _otrobopt.RobustOptimizationAlgorithm_swiginit(self, _otrobopt.new_RobustOptimizationAlgorithm(*args))
    __swig_destroy__ = _otrobopt.delete_RobustOptimizationAlgorithm

# Register RobustOptimizationAlgorithm in _otrobopt:
_otrobopt.RobustOptimizationAlgorithm_swigregister(RobustOptimizationAlgorithm)
class SequentialMonteCarloRobustAlgorithm(RobustOptimizationAlgorithm):
    r"""
    Sequential Monte Carlo robust optimization algorithm.

    Solves a robust optimization problem by alternating discretizing
    measures and solving deterministic problems.

    Measures are discretized using an initial size that can be set with
    :py:meth:`setInitialSamplingSize` and a size increment that is set with
    :py:meth:`setSamplingSizeIncrement`.

    The optimization problems relies on a Multi-Start algorithm from an initial LHS
    experiment and an internal solver that can be set by :py:meth:`setOptimizationAlgorithm`.
    The ResourceMap key `SequentialMonteCarloRobustAlgorithm-ConvergenceFactor`
    can be used to control the convergence criteria of the inner solver.

    The algorithm stops when the number of iterations has been reached or the
    absolute error is small enough.

    Parameters
    ----------
    problem : :class:`~otrobopt.RobustOptimizationProblem`
        Robust optimization problem
    solver : :py:class:`openturns.OptimizationAlgorithm`
        Optimization solver
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def getClassName(self):
        r"""
        Accessor to the object's name.

        Returns
        -------
        class_name : str
            The object class name (`object.__class__.__name__`).
        """
        return _otrobopt.SequentialMonteCarloRobustAlgorithm_getClassName(self)

    def run(self):
        r"""Launch the optimization."""
        return _otrobopt.SequentialMonteCarloRobustAlgorithm_run(self)

    def setInitialSamplingSize(self, N0):
        r"""
        Initial sampling size accessor.

        Initial size of the discretization of :math:`\theta`.

        Parameters
        ----------
        initialSamplingSize : int
            Initial sampling size
        """
        return _otrobopt.SequentialMonteCarloRobustAlgorithm_setInitialSamplingSize(self, N0)

    def getInitialSamplingSize(self):
        r"""
        Initial sampling size accessor.

        Initial size of the discretization of :math:`\theta`.

        Returns
        -------
        initialSamplingSize : int
            Initial sampling size
        """
        return _otrobopt.SequentialMonteCarloRobustAlgorithm_getInitialSamplingSize(self)

    def setSamplingSizeIncrement(self, samplingSizeIncrement):
        r"""
        Sampling size increment accessor.

        Sampling size increment of :math:`\theta` as a function of the total size at
        the previous iteration.

        Parameters
        ----------
        samplingSizeIncrement : :py:class:`openturns.Function`
            Sampling size increment
        """
        return _otrobopt.SequentialMonteCarloRobustAlgorithm_setSamplingSizeIncrement(self, samplingSizeIncrement)

    def getSamplingSizeIncrement(self):
        r"""
        Sampling size increment accessor.

        Sampling size increment of :math:`\theta` as a function of the total size at
        the previous iteration.

        Returns
        -------
        samplingSizeIncrement : :py:class:`openturns.Function`
            Sampling size increment
        """
        return _otrobopt.SequentialMonteCarloRobustAlgorithm_getSamplingSizeIncrement(self)

    def setInitialSearch(self, initialSearch):
        r"""
        Multi-start number accessor.

        Initial number of start points used.

        Problem bounds must be specified when multi-start is used as start points are
        drawn uniformly into the bounding box using an LHS experiment.

        Parameters
        ----------
        initialSearch : int, 0 by default (no multi-start)
            Multi-start number
        """
        return _otrobopt.SequentialMonteCarloRobustAlgorithm_setInitialSearch(self, initialSearch)

    def getInitialSearch(self):
        r"""
        Multi-start number accessor.

        Initial number of start points used.

        Problem bounds must be specified when multi-start is used as start points are
        drawn uniformly into the bounding box.

        Returns
        -------
        initialSearch : int, 0 by default (no multi-start)
            Multi-start number
        """
        return _otrobopt.SequentialMonteCarloRobustAlgorithm_getInitialSearch(self)

    def getResultCollection(self):
        r"""
        Optimization intermediate results accessor.

        Optimization results at each step.

        Returns
        -------
        resultColl : sequence of :class:`openturns.OptimizationResult`
            List of optimization results
        """
        return _otrobopt.SequentialMonteCarloRobustAlgorithm_getResultCollection(self)

    def getInitialStartingPoints(self):
        r"""
        Multi-start optimization starting points accessor.

        Optimization starting points during the initial search phase.

        Returns
        -------
        startPoints : :class:`openturns.Sample`
            List of optimization starting points
        """
        return _otrobopt.SequentialMonteCarloRobustAlgorithm_getInitialStartingPoints(self)

    def __repr__(self):
        return _otrobopt.SequentialMonteCarloRobustAlgorithm___repr__(self)

    def __init__(self, *args):
        _otrobopt.SequentialMonteCarloRobustAlgorithm_swiginit(self, _otrobopt.new_SequentialMonteCarloRobustAlgorithm(*args))
    __swig_destroy__ = _otrobopt.delete_SequentialMonteCarloRobustAlgorithm

# Register SequentialMonteCarloRobustAlgorithm in _otrobopt:
_otrobopt.SequentialMonteCarloRobustAlgorithm_swigregister(SequentialMonteCarloRobustAlgorithm)
class SubsetInverseSamplingResult(openturns.simulation.ProbabilitySimulationResult):
    r"""
    Result for inverse subset simulation.

    Parameters
    ----------
    event : :class:`openturns.RandomVector`
        Event

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def getClassName(self):
        r"""
        Accessor to the object's name.

        Returns
        -------
        class_name : str
            The object class name (`object.__class__.__name__`).
        """
        return _otrobopt.SubsetInverseSamplingResult_getClassName(self)

    def getCoefficientOfVariation(self):
        r"""
        Accessor to the coefficient of variation.

        Returns
        -------
        coefficient : float
            Coefficient of variation of the simulated sample which is equal to
            :math:`\sqrt{Var_e} / P_e` with :math:`Var_e` the variance estimate and
            :math:`P_e` the probability estimate.
        """
        return _otrobopt.SubsetInverseSamplingResult_getCoefficientOfVariation(self)

    def __repr__(self):
        return _otrobopt.SubsetInverseSamplingResult___repr__(self)

    def __init__(self, *args):
        _otrobopt.SubsetInverseSamplingResult_swiginit(self, _otrobopt.new_SubsetInverseSamplingResult(*args))
    __swig_destroy__ = _otrobopt.delete_SubsetInverseSamplingResult

# Register SubsetInverseSamplingResult in _otrobopt:
_otrobopt.SubsetInverseSamplingResult_swigregister(SubsetInverseSamplingResult)
class SubsetInverseSampling(openturns.simulation.EventSimulation):
    r"""
    Subset inverse simulation.

    Parameters
    ----------
    event : :class:`~openturns.RandomVector`
        Event we are computing the probability of. The threshold of the event is not used.
    targetProbability : float
        The wanted final probability.
    proposalRange : float, optional
        Proposal range length
    conditionalProbability : float, optional
        Value of :math:`P(F_i|F_{i-1})` between successive steps

    Notes
    -----
    The goal is to estimate the threshold of the following target probability :

    .. math::

        P_f = \int_{\mathcal D_f} f_{\uX}(\ux)\di{\ux}\\
            = \int_{\mathbb R^{n_X}} \mathbf{1}_{\{g(\ux,\underline{d}) \:\leq 0\: \}}f_{\uX}(\ux)\di{\ux}\\
            = \Prob {\{g(\uX,\underline{d}) \leq q\}}


    The idea of the subset simulation method is to replace simulating a
    rare failure event in the original probability space by a sequence of
    simulations of more frequent conditional events :math:`F_i` :

    .. math::

        F_1 \supset F_2 \supset \dots \supset F_m = F


    The original probability estimate rewrites :

    .. math::

        P_f = P(F_m) = P(\bigcap \limits_{i=1}^m F_i) = P(F_1) \prod_{i=2}^m P(F_i|F_{i-1})


    And each conditional subset failure region is chosen by setting the threshold
    :math:`g_i` so that :math:`P(F_i|F_{i-1})` leads to a conditional failure
    probability of order :math:`0.1` :

    .. math::

        F_i =\Prob {\{g(\uX,\underline{d}) \leq g_i\}}


    The conditional samples are generated by the means of Markov Chains,
    using the Metropolis Hastings algorithm.

    :math:`N` being the number of simulations per subset, and :math:`p_{0i}` the
    conditional probability of each subset event, and :math:`\gamma_i` the
    autocorrelation between Markov chain samples.

    .. math::

        \delta^2 = \sum_{i=1}^m \delta^2_i = \sum_{i=1}^m (1+\gamma_i) \frac{1-p_{0i}}{p_{0i}N}


    The first event :math:`F_1` not being conditional, :math:`\delta^2_1`
    expresses as the classic Monte Carlo c.o.v.

    Examples
    --------
    >>> import openturns as ot
    >>> import otrobopt

    >>> ot.RandomGenerator.SetSeed(0)

    Create a performance function with an associated distribution.

    >>> limitState = ot.SymbolicFunction(['u1', 'u2'], ['u1-u2'])
    >>> dim = limitState.getInputDimension()
    >>> mean = ot.Point([7., 2.])
    >>> sigma = ot.Point(dim, 1.0)
    >>> R = ot.IdentityMatrix(dim)
    >>> distribution = ot.Normal(mean, sigma, R)
    >>> vect = ot.RandomVector(distribution)
    >>> output = ot.CompositeRandomVector(limitState, vect)

    Create an event with a fictional threshold value which will not be used.

    >>> event = ot.ThresholdEvent(output, ot.Less(), 0.)

    Define the target probability for which the threshold will be computed.

    >>> targetProbability = 0.0002
    >>> algo = otrobopt.SubsetInverseSampling(event, targetProbability)
    >>> algo.setMaximumOuterSampling(10000)
    >>> algo.run()

    Get some results.

    >>> result = algo.getResult()
    >>> pf = result.getProbabilityEstimate()
    >>> threshold = algo.getThresholdPerStep()[-1]
    >>> threshold_cl = algo.getThresholdConfidenceLength(0.90)

    See also
    --------
    openturns.EventSimulation
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def getClassName(self):
        r"""
        Accessor to the object's name.

        Returns
        -------
        class_name : str
            The object class name (`object.__class__.__name__`).
        """
        return _otrobopt.SubsetInverseSampling_getClassName(self)

    def getResult(self):
        r"""
        Accessor to the results.

        Returns
        -------
        results : :class:`~openturns.SimulationResult`
            Structure containing all the results obtained after simulation and created
            by the method :py:meth:`run`.
        """
        return _otrobopt.SubsetInverseSampling_getResult(self)

    def setProposalRange(self, proposalRange):
        r"""
        Proposal range length accessor.

        Parameters
        ----------
        range : float
            Range length.
        """
        return _otrobopt.SubsetInverseSampling_setProposalRange(self, proposalRange)

    def getProposalRange(self):
        r"""
        Proposal range length accessor.

        Returns
        -------
        range : float
            Range length.
        """
        return _otrobopt.SubsetInverseSampling_getProposalRange(self)

    def setConditionalProbability(self, conditionalProbability):
        r"""
        Conditional probability accessor.

        Value of :math:`P(F_i|F_{i-1})` between successive steps.

        Parameters
        ----------
        prob : float
            Conditional probability value.
        """
        return _otrobopt.SubsetInverseSampling_setConditionalProbability(self, conditionalProbability)

    def getConditionalProbability(self):
        r"""
        Conditional probability accessor.

        Value of :math:`P(F_i|F_{i-1})` between successive steps.

        Returns
        -------
        prob : float
            Conditional probability value.
        """
        return _otrobopt.SubsetInverseSampling_getConditionalProbability(self)

    def setTargetProbability(self, targetProbability):
        r"""
        Final target probability accessor.

        Value of :math:`P(F_m)`.

        Parameters
        ----------
        prob : float
            Final target probability value.
        """
        return _otrobopt.SubsetInverseSampling_setTargetProbability(self, targetProbability)

    def getTargetProbability(self):
        r"""
        Final target probability accessor.

        Value of :math:`P(F_m)`.

        Returns
        -------
        prob : float
            Final target probability value.
        """
        return _otrobopt.SubsetInverseSampling_getTargetProbability(self)

    def getNumberOfSteps(self):
        r"""
        Subset steps number accesor.

        Returns
        -------
        n : int
            Number of subset steps.
        """
        return _otrobopt.SubsetInverseSampling_getNumberOfSteps(self)

    def getThresholdConfidenceLength(self, *args):
        r"""
        Accessor to the confidence length of the threshold.

        Parameters
        ----------
        level : float, :math:`level \in ]0, 1[`
            Confidence level. By default, it is :math:`0.95`.

        Returns
        -------
        confidenceLength : float
            Length of the confidence interval at the confidence level *level*.
        """
        return _otrobopt.SubsetInverseSampling_getThresholdConfidenceLength(self, *args)

    def getThresholdPerStep(self):
        r"""
        Threshold accessor.

        Returns
        -------
        threshold : :py:class:`openturns.Point`
            Threshold values.
        """
        return _otrobopt.SubsetInverseSampling_getThresholdPerStep(self)

    def getGammaPerStep(self):
        r"""
        Autocorrelation accessor.

        Returns
        -------
        prob : :py:class:`openturns.Point`
            Autocorrelation values.
        """
        return _otrobopt.SubsetInverseSampling_getGammaPerStep(self)

    def getCoefficientOfVariationPerStep(self):
        r"""
        Coefficient of variation per step accessor.

        Returns
        -------
        coef : :py:class:`openturns.Point`
            Coefficient of variation at each subset step.
        """
        return _otrobopt.SubsetInverseSampling_getCoefficientOfVariationPerStep(self)

    def getProbabilityEstimatePerStep(self):
        r"""
        Probability estimate accessor.

        Returns
        -------
        prob : :py:class:`openturns.Point`
            Probability estimate values.
        """
        return _otrobopt.SubsetInverseSampling_getProbabilityEstimatePerStep(self)

    def getThresholdCoefficientOfVariationPerStep(self):
        r"""
        Threshold coefficient of variation per step accessor.

        Returns
        -------
        coef : :py:class:`openturns.Point`
            Coefficient of variation at each subset step.
        """
        return _otrobopt.SubsetInverseSampling_getThresholdCoefficientOfVariationPerStep(self)

    def setKeepEventSample(self, keepEventSample):
        r"""
        Sample storage accessor.

        Parameters
        ----------
        prob : bool
            Whether to keep the event samples.
        """
        return _otrobopt.SubsetInverseSampling_setKeepEventSample(self, keepEventSample)

    def getEventInputSample(self):
        r"""
        Input sample accessor.

        Returns
        -------
        inputSample : :py:class:`openturns.Sample`
            Input sample.
        """
        return _otrobopt.SubsetInverseSampling_getEventInputSample(self)

    def getEventOutputSample(self):
        r"""
        Output sample accessor.

        Returns
        -------
        outputSample : :py:class:`openturns.Sample`
            Ouput sample.
        """
        return _otrobopt.SubsetInverseSampling_getEventOutputSample(self)

    def getOutputSample(self):
        r"""
        All output sample accessor.

        Returns
        -------
        outputSample : :py:class:`openturns.Sample`
            Output sample.
        """
        return _otrobopt.SubsetInverseSampling_getOutputSample(self)

    def getInputSample(self):
        r"""
        All input sample accessor.

        Returns
        -------
        inputSample : :py:class:`openturns.Sample`
            Input sample.
        """
        return _otrobopt.SubsetInverseSampling_getInputSample(self)

    def setISubset(self, iSubset):
        r"""
        Conditonal simulation activation accessor.

        Parameters
        ----------
        isubset : bool
            Activate or not the conditional simulation for the first step of the 
            simulation.
        """
        return _otrobopt.SubsetInverseSampling_setISubset(self, iSubset)

    def setBetaMin(self, betaMin):
        r"""
        Radius of the hypershere accessor.

        Parameters
        ----------
        beta : float
            Radius value of the exclusion hypershere when the conditional simulation is activated.
        """
        return _otrobopt.SubsetInverseSampling_setBetaMin(self, betaMin)

    def run(self):
        r"""
        Launch simulation.

        Notes
        -----
        It launches the simulation and creates a :class:`~openturns.SimulationResult`,
        structure containing all the results obtained after simulation.
        It computes the probability of occurrence of the given event by computing the
        empirical mean of a sample of size at most *outerSampling * blockSize*,
        this sample being built by blocks of size *blockSize*. It allows one to use
        efficiently the distribution of the computation as well as it allows one to deal
        with a sample size :math:`> 2^{32}` by a combination of *blockSize* and
        *outerSampling*.

        see also
        --------
        openturns.EventSimulation.setBlockSize
        openturns.EventSimulation.setMaximumOuterSampling
        openturns.ResourceMap
        openturns.SimulationResult
        """
        return _otrobopt.SubsetInverseSampling_run(self)

    def __repr__(self):
        return _otrobopt.SubsetInverseSampling___repr__(self)

    def __init__(self, *args):
        _otrobopt.SubsetInverseSampling_swiginit(self, _otrobopt.new_SubsetInverseSampling(*args))
    __swig_destroy__ = _otrobopt.delete_SubsetInverseSampling

# Register SubsetInverseSampling in _otrobopt:
_otrobopt.SubsetInverseSampling_swigregister(SubsetInverseSampling)
cvar = _otrobopt.cvar
SubsetInverseSampling.DefaultMaximumOuterSampling = _otrobopt.cvar.SubsetInverseSampling_DefaultMaximumOuterSampling
SubsetInverseSampling.DefaultProposalRange = _otrobopt.cvar.SubsetInverseSampling_DefaultProposalRange
SubsetInverseSampling.DefaultConditionalProbability = _otrobopt.cvar.SubsetInverseSampling_DefaultConditionalProbability
SubsetInverseSampling.DefaultBetaMin = _otrobopt.cvar.SubsetInverseSampling_DefaultBetaMin

class InverseFORMResult(openturns.analytical.FORMResult):
    r"""Result of Inverse FORM."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def getClassName(self):
        r"""
        Accessor to the object's name.

        Returns
        -------
        class_name : str
            The object class name (`object.__class__.__name__`).
        """
        return _otrobopt.InverseFORMResult_getClassName(self)

    def __repr__(self):
        return _otrobopt.InverseFORMResult___repr__(self)

    def getParameter(self):
        r"""
        Parameter accessor.

        Returns
        -------
        parameter : :py:class:`openturns.Point`
            Parameter value.
        """
        return _otrobopt.InverseFORMResult_getParameter(self)

    def getParameterDescription(self):
        r"""
        Parameter description accessor.

        Returns
        -------
        description : :py:class:`openturns.Description`
            Parameter description.
        """
        return _otrobopt.InverseFORMResult_getParameterDescription(self)

    def getConvergenceCriteria(self):
        r"""
        Convergence criteria accessor.

        Returns
        -------
        description : :py:class:`openturns.Point`
            Parameter description.
        """
        return _otrobopt.InverseFORMResult_getConvergenceCriteria(self)

    def __init__(self, *args):
        _otrobopt.InverseFORMResult_swiginit(self, _otrobopt.new_InverseFORMResult(*args))
    __swig_destroy__ = _otrobopt.delete_InverseFORMResult

# Register InverseFORMResult in _otrobopt:
_otrobopt.InverseFORMResult_swigregister(InverseFORMResult)
class InverseFORM(openturns.common.PersistentObject):
    r"""
    Inverse FORM.

    Parameters
    ----------
    event : :class:`~openturns.RandomVector`
        Event we are computing the probability of.
    parameterName : str
        The optimized parameter
    physicalStartingPoint : sequence of float
        Optimization starting point

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def getClassName(self):
        r"""
        Accessor to the object's name.

        Returns
        -------
        class_name : str
            The object class name (`object.__class__.__name__`).
        """
        return _otrobopt.InverseFORM_getClassName(self)

    def setTargetBeta(self, targetBeta):
        r"""Target beta accessor."""
        return _otrobopt.InverseFORM_setTargetBeta(self, targetBeta)

    def getTargetBeta(self):
        r"""Target beta accessor."""
        return _otrobopt.InverseFORM_getTargetBeta(self)

    def setFixedStep(self, fixedStep):
        r"""Fixed-step mode accessor."""
        return _otrobopt.InverseFORM_setFixedStep(self, fixedStep)

    def getFixedStep(self):
        r"""Fixed-step mode accessor."""
        return _otrobopt.InverseFORM_getFixedStep(self)

    def setFixedStepValue(self, fixedStepValue):
        r"""Fixed-step value accessor."""
        return _otrobopt.InverseFORM_setFixedStepValue(self, fixedStepValue)

    def getFixedStepValue(self):
        r"""Fixed-step value accessor."""
        return _otrobopt.InverseFORM_getFixedStepValue(self)

    def setVariableStepMaxIterations(self, variableStepMaxIterations):
        r"""Line search maximum iteration accessor."""
        return _otrobopt.InverseFORM_setVariableStepMaxIterations(self, variableStepMaxIterations)

    def getVariableStepMaxIterations(self):
        r"""Line search maximum iteration accessor."""
        return _otrobopt.InverseFORM_getVariableStepMaxIterations(self)

    def setMaximumIteration(self, maximumIteration):
        r"""Maximum iteration accessor."""
        return _otrobopt.InverseFORM_setMaximumIteration(self, maximumIteration)

    def getMaximumIteration(self):
        r"""Maximum iteration accessor."""
        return _otrobopt.InverseFORM_getMaximumIteration(self)

    def setVariableConvergence(self, variableConvergence):
        r"""Variable convergence criterion accessor."""
        return _otrobopt.InverseFORM_setVariableConvergence(self, variableConvergence)

    def getVariableConvergence(self):
        r"""Variable convergence criterion accessor."""
        return _otrobopt.InverseFORM_getVariableConvergence(self)

    def setBetaConvergence(self, betaConvergence):
        r"""Beta convergence criterion accessor."""
        return _otrobopt.InverseFORM_setBetaConvergence(self, betaConvergence)

    def getBetaConvergence(self):
        r"""Beta convergence criterion accessor."""
        return _otrobopt.InverseFORM_getBetaConvergence(self)

    def setLimitStateConvergence(self, limitStateConvergence):
        r"""Limit-state convergence criterion accessor."""
        return _otrobopt.InverseFORM_setLimitStateConvergence(self, limitStateConvergence)

    def getLimitStateConvergence(self):
        r"""Limit-state convergence criterion accessor."""
        return _otrobopt.InverseFORM_getLimitStateConvergence(self)

    def setResult(self, result):
        r"""Result accessor."""
        return _otrobopt.InverseFORM_setResult(self, result)

    def getResult(self):
        r"""
        Result accessor.

        Returns
        -------
        result : :class:`~otrobopt.InverseFORMResult`
            Result.
        """
        return _otrobopt.InverseFORM_getResult(self)

    def __repr__(self):
        return _otrobopt.InverseFORM___repr__(self)

    def run(self):
        r"""Run algorithm."""
        return _otrobopt.InverseFORM_run(self)

    def __init__(self, *args):
        _otrobopt.InverseFORM_swiginit(self, _otrobopt.new_InverseFORM(*args))
    __swig_destroy__ = _otrobopt.delete_InverseFORM

# Register InverseFORM in _otrobopt:
_otrobopt.InverseFORM_swigregister(InverseFORM)

